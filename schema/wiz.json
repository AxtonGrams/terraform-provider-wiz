directive @specifiedBy(url: String!) on SCALAR

type _AuthStub {
  _stub: String
  id: ID!
}

type _IaCStub {
  _stub: String
  id: ID!
}

type ActionTemplate implements Node {
  createdAt: DateTime!
  createdBy: User
  id: ID!
  name: String!
  params: ActionTemplateParams
  project: Project
  source: ActionTemplateSource!
  type: ActionTemplateType!
}

type ActionTemplateConnection {
  edges: [ActionTemplateEdge!]
  nodes: [ActionTemplate!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ActionTemplateEdge {
  cursor: String!
  node: ActionTemplate!
}

input ActionTemplateFilters {
  search: String
  type: [ActionTemplateType!]
  projectId: String
  source: [ActionTemplateSource!]
}

union ActionTemplateParams = AwsSnsActionTemplateParams | EmailActionTemplateParams | WebhookActionTemplateParams | SlackActionTemplateParams | SlackBotActionTemplateParams | AzureServiceBusActionTemplateParams | GcpPubSubActionTemplateParams | GoogleChatActionTemplateParams | PagerDutyActionCreateIncidentTemplateParams | JiraActionCreateTicketTemplateParams | JiraActionAddCommentTemplateParams | JiraActionTransitionTicketTemplateParams | ServiceNowActionCreateTicketTemplateParams | ServiceNowActionUpdateTicketTemplateParams | OpsgenieCreateAlertTemplateParams | OpsgenieCloseAlertTemplateParams | ClickUpCreateTaskActionTemplateParams

input ActionTemplateParamsInput {
  awsSNS: AwsSNSActionTemplateParamsInput
  email: EmailActionTemplateParamsInput
  webhook: WebhookActionTemplateParamsInput
  slack: SlackActionTemplateParamsInput
  slackBot: SlackBotActionTemplateParamsInput
  azureServiceBus: AzureServiceBusActionTemplateParamsInput
  googleChat: GoogleChatActionTemplateParamsInput
  gcpPubSub: GcpPubSubActionTemplateParamsInput
  pagerDutyCreateIncident: PagerDutyActionCreateIncidentTemplateParamsInput
  jiraCreateTicket: JiraActionCreateTicketTemplateParamsInput
  jiraAddComment: JiraActionAddCommentTemplateParamsInput
  jiraTransitionTicket: JiraActionTransitionTicketTemplateParamsInput
  serviceNowCreateTicket: ServiceNowActionCreateTicketTemplateParamsInput
  serviceNowUpdateTicket: ServiceNowActionUpdateTicketTemplateParamsInput
  opsgenieCreateAlert: OpsgenieCreateAlertTemplateParamsInput
  opsgenieCloseAlert: OpsgenieCloseAlertTemplateParamsInput
  clickUpCreateTask: ClickUpCreateTaskActionTemplateParamsInput
}

enum ActionTemplateSource {
  ISSUES
  CLOUD_EVENTS
  CONTROL
}

enum ActionTemplateType {
  AWS_SNS
  AWS_SECURITY_HUB
  AZURE_DEVOPS
  AZURE_LOGIC_APPS
  AZURE_SENTINEL
  AZURE_SERVICE_BUS
  CISCO_WEBEX
  CORTEX_XSOAR
  CYWARE
  EMAIL
  AWS_EVENT_BRIDGE
  GOOGLE_CHAT
  GCP_PUB_SUB
  JIRA_CREATE_TICKET
  JIRA_ADD_COMMENT
  JIRA_TRANSITION_TICKET
  MICROSOFT_TEAMS
  PAGER_DUTY_CREATE_INCIDENT
  PAGER_DUTY_RESOLVE_INCIDENT
  SERVICE_NOW_CREATE_TICKET
  SERVICE_NOW_UPDATE_TICKET
  SLACK
  SLACK_BOT
  SPLUNK
  SUMO_LOGIC
  TORQ
  WEBHOOK
  OPSGENIE_CREATE_ALERT
  OPSGENIE_CLOSE_ALERT
  FRESHSERVICE
  TINES
  HUNTERS
  CLICK_UP_CREATE_TASK
}

input AddSecurityScanInput {
  uploadId: String!
  scopeObject: String
  source: String
}

type AddSecurityScanPayload {
  securityScan: SecurityScan
}

type AdmissionController implements Node {
  clientConfig: AdmissionControllerClientConfig!
  cluster: KubernetesCluster
  createdAt: DateTime
  healthStatus: AdmissionControllerStatus
  healthStatusDetails: JSON
  id: ID!
  lastSeen: DateTime
  serverConfig: JSON
  updatedAt: DateTime
}

type AdmissionControllerClientConfig {
  errorEnforcement: AdmissionControllerEnforcementMethod
  policies: [String!]
  policyEnforcement: AdmissionControllerEnforcementMethod
  version: String!
}

enum AdmissionControllerEnforcementMethod {
  BLOCK
  AUDIT
}

enum AdmissionControllerStatus {
  FAILED
  RUNNING
}

enum AdmissionReviewEnforcementMethod {
  BLOCK
  AUDIT
}

enum AdmissionReviewVerdict {
  PASS
  FAIL
}

enum AlibabaCloudType {
  ALICLOUD
  ALIYUN
}

enum AlibabaConnectorCredentialsType {
  ACCOUNT
  RESOURCE_DIRECTORY
}

enum AlibabaCredentialsType {
  ACCOUNT
  RESOURCE_DIRECTORY
}

type AlibabaOutpostCredentials {
  autoscalerRoleARN: String!
  csiDriverRoleARN: String!
  externalSecretsRoleARN: String!
  orchestratorAccessKeyID: String!
  orchestratorAccessKeySecret: String!
  orchestratorRoleARN: String!
  outpostFilesCsiDriverRoleARN: String!
  scanBrokerRoleARN: String!
  scanSourceOperatorRoleARN: String!
  stateBucketRoleARN: String!
}

input AlibabaOutpostCredentialsInput {
  orchestratorAccessKeyID: String!
  orchestratorAccessKeySecret: String!
  orchestratorRoleARN: String!
  scanBrokerRoleARN: String!
  scanSourceOperatorRoleARN: String!
  csiDriverRoleARN: String!
  stateBucketRoleARN: String!
  autoscalerRoleARN: String!
  externalSecretsRoleARN: String!
  outpostFilesCsiDriverRoleARN: String!
}

scalar AnyValue

type ArtifactAnalyticsVulnerabilities {
  counts: [ArtifactAnalyticsVulnerabilityCount!]!
  hasCritical: Boolean!
}

type ArtifactAnalyticsVulnerabilityCount {
  count: Int!
  level: VulnerabilitySeverity!
}

type ArtifactFinding implements Node {
  detailedName: String!
  detectionMethod: ArtifactFindingDetectionMethod
  id: ID!
  name: String!
  severity: VulnerabilitySeverity!
  version: String!
  vulnerability: Vulnerability!
}

enum ArtifactFindingDetectionMethod {
  PACKAGE
  LIBRARY
  OS
  FILE_PATH
}

type ArtifactFindingEdge {
  cursor: String!
  node: ArtifactFinding!
}

type ArtifactFindingsConnection {
  edges: [ArtifactFindingEdge!]!
  nodes: [ArtifactFinding!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AssociateServiceTicketControlTypeInput {
  controlId: ID!
  projectId: ID
}

input AssociateServiceTicketInput {
  issueId: ID
  control: AssociateServiceTicketControlTypeInput
  ticketId: String!
  ticketUrl: String!
}

type AssociateServiceTicketPayload {
  serviceTicket: ServiceTicket!
}

type AuditLogEntry {
  action: String!
  actionParameters: JSON!
  id: ID!
  requestId: String
  serviceAccount: ServiceAccount
  sourceIP: String
  status: AuditLogEntryStatus!
  timestamp: DateTime!
  user: User
  userAgent: String
}

type AuditLogEntryConnection {
  edges: [AuditLogEntryEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 1000): String
  nodes: [AuditLogEntry!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type AuditLogEntryEdge {
  cursor: String!
  node: AuditLogEntry!
}

input AuditLogEntryFilters {
  action: String
  search: String
  status: [AuditLogEntryStatus!]
  user: [String!]
  userType: [AuditLogEntryUserType!]
  userAgent: String
  timestamp: AuditLogEntryTimestampFilter
  sourceIP: String
}

enum AuditLogEntryStatus {
  SUCCESS
  FAILED
  INVALID
  ACCESS_DENIED
}

input AuditLogEntryTimestampFilter {
  before: DateTime
  after: DateTime
}

enum AuditLogEntryUserType {
  USER_ACCOUNT
  SERVICE_ACCOUNT
}

enum AuthenticationSource {
  LEGACY
  MODERN
}

type AuthMigration {
  status: AuthMigrationStatus!
}

enum AuthMigrationStatus {
  NOT_STARTED
  ADMIN_ONLY
  IN_PROGRESS
  COMPLETED
}

input AuthProviderConfigAKSInput {
  serviceAccountToken: String!
}

input AuthProviderConfigEKSInput {
  serviceAccountToken: String!
  vpcEndpointServiceName: String
}

input AuthProviderConfigKubernetesInput {
  serviceAccountToken: String!
}

input AuthProviderConfigOKEInput {
  serviceAccountToken: String!
}

type AutomationAction implements Node {
  createdAt: DateTime!
  id: ID!
  isAccessibleToAllProjects: Boolean
  name: String!
  params: AutomationActionParams!
  project: Project
  status: AutomationActionStatus
  type: AutomationActionType!
  updatedAt: DateTime!
  usedByRules: [AutomationRule!]!
}

type AutomationActionConnection {
  edges: [AutomationActionEdge!]
  nodes: [AutomationAction!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type AutomationActionEdge {
  cursor: String!
  node: AutomationAction!
}

input AutomationActionFilters {
  search: String
  type: [AutomationActionType!]
  projectId: String
}

input AutomationActionIssueEntityTag {
  key: String!
  value: String
}

union AutomationActionParams = EmailAutomationActionParams | WebhookAutomationActionParams | SlackMessageAutomationActionParams | GoogleChatMessageAutomationActionParams | JiraAutomationActionParams | JiraTransitionAutomationActionParams | ServiceNowAutomationActionParams | ServiceNowUpdateTicketAutomationActionParams | AwsMessageAutomationActionParams | AzureServiceBusAutomationActionParams | GooglePubSubAutomationActionParams

input AutomationActionRuleIssueEntityTagFilter {
  containsAll: [AutomationActionIssueEntityTag!]
  containsAny: [AutomationActionIssueEntityTag!]
  doesNotContainAll: [AutomationActionIssueEntityTag!]
  doesNotContainAny: [AutomationActionIssueEntityTag!]
}

enum AutomationActionStatus {
  SUCCESS @deprecated
  FAILURE @deprecated
}

type AutomationActionTLSConfig {
  allowInsecureTLS: Boolean
  clientCertificateAndPrivateKey: String
  serverCA: String
}

enum AutomationActionType {
  EMAIL @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  WEBHOOK @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SLACK_MESSAGE @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  GOOGLE_CHAT_MESSAGE @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  MICROSOFT_TEAMS @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  EVENT_BRIDGE @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SECURITY_HUB @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  JIRA_TICKET @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SERVICENOW_TICKET @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  AZURE_DEVOPS @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  AZURE_SENTINEL @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  AZURE_LOGIC_APPS @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SPLUNK @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SUMO_LOGIC @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  TORQ @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SNOWFLAKE @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  CYWARE @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  AWS_SNS @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  AZURE_SERVICE_BUS @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  GOOGLE_PUB_SUB @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  CISCO_WEBEX @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  CORTEX_XSOAR @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  JIRA_TICKET_TRANSITION @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  SERVICENOW_UPDATE_TICKET @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  PAGER_DUTY_CREATE_INCIDENT @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  PAGER_DUTY_RESOLVE_INCIDENT @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  OPSGENIE_CREATE_ALERT @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  OPSGENIE_CLOSE_ALERT @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
  FRESHSERVICE @deprecated(reason: "use the matching `IntegrationType` and `ActionTemplateType` instead")
}

scalar AutomationActionTypeValue

type AutomationRule implements Node {
  action: AutomationAction!
  actions: [AutomationRuleAction!]!
  createdAt: DateTime!
  createdBy: User!
  description: String
  enabled: Boolean!
  filters: JSON
  id: ID!
  lastExecutionError: String
  name: String!
  overrideActionParams: JSON
  project: Project
  triggerSource: AutomationRuleTriggerSource!
  triggerType: [AutomationRuleTriggerType!]!
  updatedAt: DateTime!
}

type AutomationRuleAction implements Node {
  actionTemplateParams: ActionTemplateParams
  actionTemplateType: ActionTemplateType!
  id: ID!
  integration: Integration!
}

input AutomationRuleActionInput {
  id: ID
  integrationId: ID!
  actionTemplateParams: ActionTemplateParamsInput
  actionTemplateType: ActionTemplateType!
}

input AutomationRuleCloudEventFilters {
  matchedRules: [String!]
  severity: [String!]
}

type AutomationRuleConnection {
  edges: [AutomationRuleEdge!]
  nodes: [AutomationRule!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input AutomationRuleControlFilters {
  control: [String!]
  notControl: [String!]
  project: [String!]
  severity: [String!]
  frameworkCategory: [String!]
  controlType: [ControlType!]
}

type AutomationRuleEdge {
  cursor: String!
  node: AutomationRule!
}

input AutomationRuleFilters {
  search: String
  triggerSource: [AutomationRuleTriggerSource!]
  action: [String!]
  integration: [String!]
  enabled: Boolean
}

input AutomationRuleIssueEntityFilters {
  subscriptionId: [String!]
  notSubscriptionId: [String!]
  resourceGroupId: [String!]
  nativeType: [String!]
  cloudPlatform: [String!]
  type: [String!]
  id: String
  ids: [String!]
  status: [CloudResourceStatus!]
  region: [String!]
  tag: AutomationActionRuleIssueEntityTagFilter
}

input AutomationRuleIssueFilters {
  project: [String!]
  notProject: [String!]
  sourceControl: [String!]
  notSourceControl: [String!]
  severity: [String!]
  status: [String!]
  relatedEntity: AutomationRuleIssueEntityFilters
  resolutionReason: [String!]
  hasServiceTicket: Boolean
  hasNote: Boolean
  frameworkCategory: [String!]
  riskEqualsAny: [String!]
  riskEqualsAll: [String!]
  riskExcludesAny: [String!]
  excludeFrameworkCategory: [String!]
  controlType: [ControlType!]
}

enum AutomationRuleTriggerSource {
  ISSUES
  CLOUD_EVENTS
  CONTROL
}

enum AutomationRuleTriggerType {
  CREATED
  UPDATED
  RESOLVED
  REOPENED
}

type AvailableRegions {
  regions: [String!]
}

enum AwsMessageAutomationActionAccessMethodType {
  ASSUME_CONNECTOR_ROLE @deprecated
  ASSUME_SPECIFIED_ROLE @deprecated
}

type AwsMessageAutomationActionParams {
  accessMethod: AwsMessageAutomationActionAccessMethodType!
  body: String!
  connectorForAccess: Connector
  customerRoleARN: String
  snsTopicARN: String!
}

type AwsSnsActionTemplateParams {
  body: String!
}

input AwsSNSActionTemplateParamsInput {
  body: String!
}

input AwsSNSIntegrationAccessMethodInput {
  type: AwsSNSIntegrationAccessMethodType!
  accessConnectorId: ID
  customerRoleARN: String
}

enum AwsSNSIntegrationAccessMethodType {
  ASSUME_CONNECTOR_ROLE
  ASSUME_SPECIFIED_ROLE
}

type AwsSNSIntegrationParams {
  accessConnector: Connector
  accessMethod: AwsSNSIntegrationAccessMethodType!
  customerRoleARN: String
  topicARN: String!
}

type AzureServiceBusActionTemplateParams {
  body: String!
}

input AzureServiceBusActionTemplateParamsInput {
  body: String!
}

enum AzureServiceBusAutomationActionAccessMethodType {
  CONNECTOR_CREDENTIALS
  CONNECTION_STRING_WITH_SAS
}

type AzureServiceBusAutomationActionParams {
  accessMethod: AzureServiceBusAutomationActionAccessMethodType!
  body: String!
  connectionStringWithSAS: String
  connectorForAccess: Connector
  queueUrl: String!
}

input AzureServiceBusIntegrationAccessMethodInput {
  type: AzureServiceBusIntegrationAccessMethodType!
  accessConnectorId: ID
  connectionStringWithSas: String
}

enum AzureServiceBusIntegrationAccessMethodType {
  CONNECTOR_CREDENTIALS
  CONNECTION_STRING_WITH_SAS
}

type AzureServiceBusIntegrationParams {
  accessConnector: Connector
  accessMethod: AzureServiceBusIntegrationAccessMethodType!
  connectionStringWithSAS: String
  queueUrl: String!
}

type BasicAuthSettings {
  requireMFA: Boolean!
}

type BillableWorkloadSample implements Node {
  bucketScanCount: Int!
  computeWorkloadCount: Int!
  containerHostCount: Int!
  dataWorkloadCount: Int!
  ecsCount: Int! @deprecated(reason: "License page using serverless containers instead of ecs containers")
  iaasDatabaseScanGB: Int!
  id: ID!
  nonOSDiskScansCount: Int!
  nonOSDiskWorkloadCount: Int!
  paasDatabaseScanGB: Int!
  registryContainerImageScanCount: Int!
  serverlessContainerCount: Int!
  serverlessCount: Int!
  timestamp: DateTime!
  virtualMachineCount: Int!
  workloadCount: Int!
}

type BillableWorkloadTrendData {
  accumulatedBucketScanCount: Int!
  accumulatedDataWorkloadCount: Int!
  accumulatedIaasDatabaseScannedGB: Int!
  accumulatedNonOSDiskScansCount: Int!
  accumulatedNonOSDiskWorkloadCount: Int!
  accumulatedPaasDatabaseScannedGB: Int!
  averageComputeWorkloadCount: Int!
  averageContainerHostCount: Int!
  averageECSCount: Int! @deprecated(reason: "License page using serverless containers instead of ecs containers")
  averageRegistryContainerImageScanCount: Int!
  averageServerlessContainerCount: Int!
  averageServerlessCount: Int!
  averageVirtualMachineCount: Int!
  averageWorkloadCount: Int! @deprecated(reason: "License page using totalWorkloadCount instead of averageWorkloadCount")
  dataPoints: [BillableWorkloadSample!]!
  totalWorkloadCount: Int!
}

type Broker implements Node {
  id: ID!
  image: String!
  latestVersionPublishedAt: DateTime!
  name: String!
  publishedAt: DateTime!
  status: String!
}

enum BuiltinReportTypeIds {
  AWS_CIS_1_2_0
  AWS_CIS_1_3_0
  AZURE_CIS_1_1_0
  AZURE_CIS_1_3_0
  GCP_CIS_1_1_0
  GRAPH_QUERY
  OS_CIS
  NETWORK_EXPOSURE
  CONFIGURATION_FINDINGS
  VULNERABILITIES
  COMPLIANCE_EXECUTIVE_SUMMARY
  ISSUES
  HOST_CONFIGURATION
  CLOUD_RESOURCE
  COMPLIANCE_ASSESSMENTS
}

enum BuiltInUserRoleId {
  GLOBAL_ADMIN
  GLOBAL_READER
  GLOBAL_LIMITED_RESPONDER
  GLOBAL_RESPONDER
  GLOBAL_POLICY_MANAGER
  GLOBAL_VULNERABILITY_MANAGER
  GLOBAL_CONTRIBUTOR
  GLOBAL_GRAPH_READER
  CONNECTOR_ADMIN
  CONNECTOR_READER
  PROJECT_ADMIN
  PROJECT_MEMBER
  PROJECT_READER
  PROJECT_VULNERABILITY_MANAGER
  PROJECT_GRAPH_READER
  PROJECT_EXTERNAL_DIGITAL_TRUST_READER
  SETTINGS_ADMIN
  DOCUMENTATION_READER
}

enum BusinessImpact {
  LBI
  MBI
  HBI
}

enum BusinessImpactFilter {
  LBI
  MBI
  HBI
}

type CICDDiskScanResult {
  analytics: CICDDiskScanResultAnalytics!
  applications: [CICDDiskScanResultApplication!]
  cpes: [CICDDiskScanResultCpe!]
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  libraries: [CICDDiskScanResultLibrary!]
  osPackages: [CICDDiskScanResultOSPackage!]
  secrets: [DiskScanSecret!]
}

type CICDDiskScanResultAnalytics {
  secrets: CICDDiskScanResultSecretAnalytics!
  vulnerabilities: CICDDiskScanResultVulnerabilityAnalytics!
}

type CICDDiskScanResultApplication {
  detectionMethod: VulnerabilityDetectionMethod!
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  name: String!
  vulnerabilities: [DiskScanApplicationVulnerability!]!
}

type CICDDiskScanResultCpe {
  detectionMethod: VulnerabilityDetectionMethod!
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  name: String!
  path: String!
  version: String!
  vulnerabilities: [DiskScanVulnerability!]!
}

type CICDDiskScanResultLibrary {
  detectionMethod: VulnerabilityDetectionMethod!
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  name: String!
  path: String!
  version: String!
  vulnerabilities: [DiskScanVulnerability!]!
}

type CICDDiskScanResultOSPackage {
  detectionMethod: VulnerabilityDetectionMethod!
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  name: String!
  version: String!
  vulnerabilities: [DiskScanVulnerability!]!
}

type CICDDiskScanResultSecretAnalytics {
  cloudKeyCount: Int!
  dbConnectionStringCount: Int!
  gitCredentialCount: Int!
  passwordCount: Int!
  privateKeyCount: Int!
}

type CICDDiskScanResultVulnerabilityAnalytics {
  criticalCount: Int!
  highCount: Int!
  infoCount: Int!
  lowCount: Int!
  mediumCount: Int!
  unfixedCount: Int!
}

type CICDIACScanResult {
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  ruleMatches: [IACScanRuleResult!]
  scanStatistics: IACScanStatistics!
  secrets: [DiskScanSecret!]
}

type CICDOutdatedScanPolicy {
  name: String!
}

type CICDPolicyCustomIgnoreTag {
  ignoreAllRules: Boolean!
  key: String!
  rules: [CloudConfigurationRule]!
  value: String!
}

input CICDPolicyCustomIgnoreTagCreateInput {
  key: String!
  value: String!
  ruleIDs: [String!]
  ignoreAllRules: Boolean
}

input CICDPolicyCustomIgnoreTagUpdateInput {
  key: String!
  value: String!
  ruleIDs: [String!]
  ignoreAllRules: Boolean
}

type CICDScan implements Node {
  createdAt: DateTime!
  createdBy: CICDScanCreator!
  extraInfo: ExtraInfo
  id: ID!
  outdatedPolicies: [CICDOutdatedScanPolicy!]
  policies: [CICDScanPolicy!]!
  projects: [Project!]
  result: CICDScanResult
  resultJSON: JSON
  scanOriginResource: CICDScanOriginResourceBase!
  scanOriginResourceType: CICDScanOriginResourceType!
  status: CICDScanStatus!
  tags: [CICDScanTag!] @deprecated(reason: "use extraInfo instead")
}

type CICDScanConnection {
  edges: [CICDScanEdge!]
  nodes: [CICDScan!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CICDScanCreator {
  serviceAccount: ServiceAccount
  user: User
}

input CICDScanCreatorFilter {
  serviceAccount: String
}

input CICDScanDateTimeFilter {
  after: DateTime
  before: DateTime
}

type CICDScanEdge {
  cursor: String!
  node: CICDScan!
}

input CICDScanFilters {
  search: [String!]
  id: [String!]
  createdAt: CICDScanDateTimeFilter
  createdBy: [CICDScanCreatorFilter!]
  state: [CICDScanState!]
  verdict: [CICDScanVerdict!]
  tag: [CICDScanTagFilter!]
  originResourceName: [String!]
  originResourceType: [CICDScanOriginResourceType!]
  originResourceSubType: [String!]
  projectID: [String!]
}

input CICDScanOrder {
  direction: OrderDirection!
  field: CICDScanOrderField!
}

enum CICDScanOrderField {
  CREATED_AT
  SCAN_ORIGIN
}

type CICDScanOriginContainerImage implements CICDScanOriginResourceBase {
  name: String!
}

type CICDScanOriginIAC implements CICDScanOriginResourceBase {
  name: String!
  subTypes: [CICDScanOriginIACSubType!]!
}

enum CICDScanOriginIACSubType {
  TERRAFORM
  CLOUD_FORMATION
  KUBERNETES
  DOCKERFILE
  AZURE_RESOURCE_MANAGER
}

interface CICDScanOriginResourceBase {
  name: String!
}

enum CICDScanOriginResourceType {
  VIRTUAL_MACHINE
  VIRTUAL_MACHINE_IMAGE
  CONTAINER_IMAGE
  IAC
}

type CICDScanOriginVirtualMachine implements CICDScanOriginResourceBase {
  name: String!
}

type CICDScanOriginVirtualMachineImage implements CICDScanOriginResourceBase {
  name: String!
}

type CICDScanPolicy implements Node {
  builtin: Boolean!
  description: String
  id: ID!
  name: String!
  params: CICDScanPolicyParams!
  projects: [Project!]
  type: CICDScanPolicyType!
}

type CICDScanPolicyConnection {
  edges: [CICDScanPolicyEdge!]
  nodes: [CICDScanPolicy!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CICDScanPolicyEdge {
  cursor: String!
  node: CICDScanPolicy!
}

input CICDScanPolicyFilters {
  search: String
  type: [CICDScanPolicyType!]
  builtin: Boolean
  names: [String!]
  projectIDs: [String!]
}

type CICDScanPolicyMatch {
  policy: CICDScanPolicy!
}

input CICDScanPolicyOrder {
  direction: OrderDirection!
  field: CICDScanPolicyOrderField!
}

enum CICDScanPolicyOrderField {
  NAME
}

union CICDScanPolicyParams = CICDScanPolicyParamsVulnerabilities | CICDScanPolicyParamsSecrets | CICDScanPolicyParamsIAC

type CICDScanPolicyParamsIAC {
  builtinIgnoreTagsEnabled: Boolean!
  countThreshold: Int!
  customIgnoreTags: [CICDPolicyCustomIgnoreTag!]!
  ignoredRules: [CloudConfigurationRule]!
  securityFrameworks: [SecurityFramework!]
  severityThreshold: IACScanSeverity!
  validatableIgnoredRules: [ValidatableCloudConfigurationRule!]! @deprecated(reason: "Use ignoredRules instead")
}

type CICDScanPolicyParamsSecrets {
  countThreshold: Int!
  pathAllowList: [String!]!
}

type CICDScanPolicyParamsVulnerabilities {
  detectionMethods: [VulnerabilityDetectionMethod!]
  ignoreUnfixed: Boolean!
  packageAllowList: [String!]!
  packageCountThreshold: Int!
  severity: DiskScanVulnerabilitySeverity!
}

enum CICDScanPolicyType {
  VULNERABILITIES
  SECRETS
  IAC
}

union CICDScanResult = CICDDiskScanResult | CICDIACScanResult

enum CICDScanState {
  SUCCESS
  FAILURE
  PENDING
  SKIPPED
}

type CICDScanStatus {
  details: String
  state: CICDScanState!
  verdict: CICDScanVerdict
}

type CICDScanTag {
  key: String!
  value: String
}

input CICDScanTagFilter {
  key: String!
  value: String
}

input CICDScanTagInput {
  key: String!
  value: String
}

enum CICDScanVerdict {
  FAILED_BY_POLICY
  PASSED_BY_POLICY
}

input ClearUIUserPreferencesInput {
  keys: [String!]
  all: Boolean
}

type ClearUIUserPreferencesPayload {
  preferences: UIUserPreferences
}

type ClickUpCreateTaskActionTemplateParams {
  body: String!
  listId: String!
}

input ClickUpCreateTaskActionTemplateParamsInput {
  listId: String!
  body: String!
}

type ClickUpIntegrationParams {
  key: String!
}

type CLIConfigurationRule {
  description: String
  iacMatchers: [CloudConfigurationRuleMatcher!]
  id: String!
  name: String!
  securityFrameworkIDs: [String!]
  severity: IACScanSeverity!
  shortName: String!
  targetNativeTypes: [String!]
}

type CLIConfigurationRulesConnection {
  edges: [CLIConfigurationRulesEdge!]
  nodes: [CLIConfigurationRule!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CLIConfigurationRulesEdge {
  cursor: String!
  node: CLIConfigurationRule!
}

input CLIConfigurationRulesFilters {
  matcherType: [CloudConfigurationRuleMatcherType!]
  scanPolicies: [String!]
}

type CLIDownloadInformation {
  docker: CLIDownloadInformationDocker!
  linux: CLIDownloadInformationBinary!
  mac: CLIDownloadInformationBinary!
  windows: CLIDownloadInformationBinary!
}

type CLIDownloadInformationBinary {
  downloadURL: String!
  sha256: String
  version: String
}

type CLIDownloadInformationDocker {
  url: String!
  version: String
}

type CloudAccount implements Node {
  cloudProvider: CloudProvider!
  complianceAnalytics(selection: CloudAccountComplianceAnalyticsSelection): CloudAccountComplianceAnalytics!
  complianceAnalyticsOverview(selection: ComplianceAnalyticsOverviewSelection): ComplianceAnalyticsOverview!
  complianceTrend(endDate: DateTime!, interval: CloudAccountComplianceTrendTimeInterval, selection: CloudAccountComplianceTrendSelection, startDate: DateTime!): CloudAccountComplianceTrendDataSeries!
  connector: Connector! @deprecated(reason: "Cloud account can be scanned by one or more connectors. Use sourceConnectors instead.")
  connectorIssues: [CloudAccountConnectorIssues!]!
  containerCount: Int!
  externalId: String!
  firstScannedAt: DateTime!
  id: ID!
  issues(after: String, filterBy: IssueFilters, first: Int, orderBy: IssueOrder): IssueConnection!
  lastScannedAt: DateTime!
  linkedProjects: [Project!]
  name: String!
  resourceCount: Int!
  sourceConnectors: [Connector!]!
  status: CloudAccountStatus!
  virtualMachineCount: Int!
}

type CloudAccountComplianceAnalytics {
  averageCompliancePosture: Int
  emptyPostureReason: ComplianceEmptyPostureReason
  failSubCategoryCount: Int!
  passSubCategoryCount: Int!
}

input CloudAccountComplianceAnalyticsSelection {
  framework: String!
}

type CloudAccountComplianceTrendDataPoint {
  failCount: Int
  passCount: Int
  score: Int
  time: DateTime!
}

type CloudAccountComplianceTrendDataSeries {
  dataPoints: [CloudAccountComplianceTrendDataPoint!]!
}

input CloudAccountComplianceTrendSelection {
  framework: String!
}

enum CloudAccountComplianceTrendTimeInterval {
  DAY
}

type CloudAccountConnection {
  edges: [CloudAccountEdge!]
  nodes: [CloudAccount!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CloudAccountConnectorIssue {
  context: [String!]!
  description: String!
  impact: String!
  issueIdentifier: String!
  moduleNames: [String!]
  remediation: String!
  severity: CloudAccountConnectorIssueSeverity!
}

type CloudAccountConnectorIssues {
  connector: Connector!
  issues: [CloudAccountConnectorIssue!]!
}

enum CloudAccountConnectorIssueSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type CloudAccountEdge {
  cursor: String!
  node: CloudAccount!
}

input CloudAccountFilters {
  id: [String!]
  search: [String!]
  projectId: String
  cloudProvider: [CloudProvider!]
  status: [CloudAccountStatus!]
  connectorId: [String!]
  connectorIssueId: [String!]
  assignedToProject: Boolean
  hasMultipleConnectorSources: Boolean
}

enum CloudAccountStatus {
  CONNECTED
  ERROR
  DISABLED
  INITIAL_SCANNING
  PARTIALLY_CONNECTED
  DISCONNECTED
  DISCOVERED
}

type CloudAccountWithComplianceAnalyticsConnection {
  edges: [CloudAccountWithComplianceAnalyticsEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 1000): String
  nodes: [CloudAccount!]
  overviewExportUrl(format: ExportFormats = CSV, selection: ComplianceAnalyticsOverviewSelection): String
  pageInfo: PageInfo!
  totalCount: Int!
}

type CloudAccountWithComplianceAnalyticsEdge {
  cursor: String!
  node: CloudAccount!
}

input CloudAccountWithComplianceAnalyticsFilters {
  framework: String
  projectId: [String!]
  search: String
  cloudAccountId: [String!]
  policyTypes: [SecurityFrameworkPolicyType!]
}

input CloudAccountWithComplianceAnalyticsOrder {
  direction: OrderDirection!
  field: CloudAccountWithComplianceAnalyticsOrderField!
}

enum CloudAccountWithComplianceAnalyticsOrderField {
  POSTURE
  PASSED_CHECKS
}

type CloudConfigRuleLinterError {
  from: CloudConfigRuleLinterPosition!
  message: String!
  to: CloudConfigRuleLinterPosition
}

type CloudConfigRuleLinterPosition {
  character: Int
  line: Int!
}

type CloudConfigurationRule implements Node {
  analytics(selection: CloudConfigurationRuleAnalyticsSelection): CloudConfigurationRuleAnalytics!
  builtin: Boolean!
  cloudProvider: CloudProvider
  control: Control
  createdAt: DateTime!
  createdBy: User
  description: String
  enabled: Boolean!
  externalReferences: [CloudConfigurationRuleExternalReference!]
  findings(after: String, filterBy: ConfigurationFindingFilters, first: Int, orderBy: ConfigurationFindingOrder): ConfigurationFindingConnection!
  functionAsControl: Boolean!
  graphId: String!
  hasAutoRemediation: Boolean!
  iacMatchers: [CloudConfigurationRuleMatcher!]
  id: ID!
  matcherTypes: [CloudConfigurationRuleMatcherTypeFilter!]! @deprecated(reason: "A Temporary field. Do not use this as it will be removed soon.")
  name: String!
  opaPolicy: String
  remediationInstructions: String
  scopeAccounts: [CloudAccount!]!
  securitySubCategories: [SecuritySubCategory!]
  serviceType: CloudConfigurationRuleServiceType
  severity: Severity!
  shortId: String!
  subjectEntityType: GraphEntityTypeValue!
  supportsNRT: Boolean!
  targetNativeType: String
  targetNativeTypes: [String!]
  updatedAt: DateTime!
}

type CloudConfigurationRuleAnalytics {
  errorCount: Int!
  failCount: Int!
  notAssessedCount: Int!
  passCount: Int!
  totalCount: Int!
}

input CloudConfigurationRuleAnalyticsSelection {
  projectId: [String!]
}

type CloudConfigurationRuleConnection {
  analyticsUpdatedAt: DateTime!
  edges: [CloudConfigurationRuleEdge!]
  enabledAsControlCount: Int!
  nodes: [CloudConfigurationRule!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum CloudConfigurationRuleCreatorType {
  USER
  BUILT_IN
}

type CloudConfigurationRuleEdge {
  cursor: String!
  node: CloudConfigurationRule!
}

type CloudConfigurationRuleExternalReference {
  id: String!
  name: String!
}

input CloudConfigurationRuleFilters {
  search: String
  scopeAccountIds: [String!]
  cloudProvider: [CloudProvider!]
  serviceType: [CloudConfigurationRuleServiceType!]
  subjectEntityType: [GraphEntityTypeValue!]
  severity: [Severity!]
  enabled: Boolean
  hasAutoRemediation: Boolean
  hasRemediation: Boolean
  benchmark: [ConfigurationBenchmarkTypeId!]
  securityFramework: [String!]
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
  targetNativeType: [String!]
  createdBy: [String!]
  createdByType: [CloudConfigurationRuleCreatorType!]
  isOPAPolicy: Boolean
  project: [String!]
  matcherType: [CloudConfigurationRuleMatcherTypeFilter!]
  id: [String!]
  functionAsControl: Boolean
  riskEqualsAny: [String!]
  riskEqualsAll: [String!]
  supportsNRT: Boolean
  createdAt: CommonDateFilter
  updatedAt: CommonDateFilter
}

type cloudConfigurationRuleIaCTest {
  evidence: CloudConfigurationRuleTestEvaluationEvidence
  output: JSON
  result: CloudConfigurationRuleTestEvaluationResult!
}

type CloudConfigurationRuleJsonTest {
  evidence: CloudConfigurationRuleTestEvaluationEvidence
  output: JSON
  result: CloudConfigurationRuleTestEvaluationResult!
}

type CloudConfigurationRuleMatcher {
  enabled: Boolean!
  id: ID!
  regoCode: String!
  shortName: String!
  type: CloudConfigurationRuleMatcherType!
}

enum CloudConfigurationRuleMatcherType {
  TERRAFORM
  CLOUD_FORMATION
  KUBERNETES
  AZURE_RESOURCE_MANAGER
  DOCKER_FILE
  ADMISSION_CONTROLLER
}

enum CloudConfigurationRuleMatcherTypeFilter {
  CLOUD
  TERRAFORM
  CLOUD_FORMATION
  KUBERNETES
  AZURE_RESOURCE_MANAGER
  DOCKER_FILE
  ADMISSION_CONTROLLER
}

input CloudConfigurationRuleOrder {
  direction: OrderDirection!
  field: CloudConfigurationRuleOrderField!
}

enum CloudConfigurationRuleOrderField {
  FAILED_CHECK_COUNT
  SEVERITY
  NAME
}

enum CloudConfigurationRuleServiceType {
  AWS
  Azure
  GCP
  OCI
  Alibaba
  vSphere
  AKS
  EKS
  GKE
  Kubernetes
  OKE
  Linode
}

type CloudConfigurationRuleTest {
  evaluations: [CloudConfigurationRuleTestEvaluation!]!
  failCount: Int!
  passCount: Int!
  skipCount: Int!
}

type CloudConfigurationRuleTestEvaluation {
  entity: GraphEntity
  evidence: CloudConfigurationRuleTestEvaluationEvidence
  output: JSON
  result: CloudConfigurationRuleTestEvaluationResult!
}

type CloudConfigurationRuleTestEvaluationEvidence {
  current: String
  expected: String
  path: String
}

enum CloudConfigurationRuleTestEvaluationResult {
  PASSED
  FAILED
  SKIPPED
}

type CloudEvent {
  actor: CloudEventActor!
  actorGraphEntity: GraphEntity
  category: String!
  cloudPlatform: String!
  cloudProviderUrl: String!
  errorCode: String
  errorMessage: String
  externalId: String!
  externalName: String!
  extraDetails: CloudEventExtraDetails
  hash: [String!]
  id: ID!
  kind: CloudEventKind!
  matchedRules: [CloudEventMatchedRule!]
  name: String!
  origin: CloudEventOrigin!
  path: [String!]
  rawAuditLogRecord: JSON!
  resources: [CloudEventResource!]!
  resourcesGraphEntities: [GraphEntity]!
  severity: CloudEventRuleSeverity
  source: String!
  subjectResource: CloudEventResource!
  subjectResourceGraphEntity: GraphEntity
  timestamp: DateTime!
  trigger: CloudEventTrigger
}

type CloudEventActor {
  accessKeyId: String
  actingAs: CloudEventActor
  cloudAccount: CloudAccount
  email: String
  externalId: String
  externalOwnerTech: Technology
  federated: Boolean
  friendlyName: String
  hasAdminKubernetesPrivileges: Boolean!
  hasAdminPrivileges: Boolean!
  hasHighKubernetesPrivileges: Boolean!
  hasHighPrivileges: Boolean!
  id: ID!
  inactiveInLast90Days: Boolean!
  IP: String
  IPMeta: CloudEventActorIPMeta!
  isExternalCloudAccount: Boolean!
  isForeignIP: Boolean!
  MFA: Boolean
  name: String
  providerUniqueId: String
  type: CloudEventActorType
  userAgent: String
}

input CloudEventActorFilters {
  id: CloudEventStringFilter
  externalId: CloudEventStringFilter
  providerUniqueId: CloudEventStringFilter
  type: CloudEventActorType
  cloudAccountId: CloudEventStringFilter
  isExternalCloudAccount: CloudEventBooleanFilter
  friendlyName: CloudEventStringFilter
  name: CloudEventStringFilter
  email: CloudEventStringFilter
  IP: CloudEventStringFilter
  IPMetaCountry: CloudEventStringFilter
  IPMetaCountryCode: CloudEventStringFilter
  IPMetaCity: CloudEventStringFilter
  IPMetaAutonomousSystemNumber: CloudEventIntFilter
  IPMetaAutonomousSystemOrganization: CloudEventStringFilter
  isForeignIP: CloudEventBooleanFilter
  userAgent: CloudEventStringFilter
  MFA: CloudEventBooleanFilter
  federated: CloudEventBooleanFilter
  accessKeyId: CloudEventStringFilter
  externalOwnerTechId: CloudEventStringFilter
  actingAsId: CloudEventStringFilter
  actingAsExternalId: CloudEventStringFilter
  actingAsProviderUniqueId: CloudEventStringFilter
  actingAsType: CloudEventActorType
  actingAsName: CloudEventStringFilter
  actingAsEmail: CloudEventStringFilter
  hasHighPrivileges: CloudEventBooleanFilter
  hasAdminPrivileges: CloudEventBooleanFilter
  hasHighKubernetesPrivileges: CloudEventBooleanFilter
  hasAdminKubernetesPrivileges: CloudEventBooleanFilter
  inactiveInLast90Days: CloudEventBooleanFilter
}

type CloudEventActorIPMeta {
  autonomousSystemNumber: Int
  autonomousSystemOrganization: String
  city: String
  country: String
  countryCode: String
}

enum CloudEventActorType {
  UNKNOWN
  USER_ACCOUNT
  SERVICE_ACCOUNT
  INTERNAL_CLOUD_SERVICE
  SUBSCRIPTION
}

input CloudEventAdmissionControllerReviewFilters {
  passedPolicy: Boolean
  policyId: [String!]
}

type CloudEventAdmissionReview {
  cloudConfigurationRuleMatches: [CloudEventCloudConfigurationRuleMatch!]
}

type CloudEventAdmissionReviewDetails {
  AdmissionReview: JSON!
  criticalMatches: Int!
  highMatches: Int!
  infoMatches: Int!
  lowMatches: Int!
  mediumMatches: Int!
  policies: [CICDScanPolicy!]!
  policyEnforcement: AdmissionReviewEnforcementMethod!
  reviewDuration: Int!
  totalMatches: Int!
  verdict: AdmissionReviewVerdict!
}

input CloudEventBooleanFilter {
  equals: Boolean
  notEquals: Boolean
  isSet: Boolean
}

type CloudEventCloudConfigurationRuleMatch {
  cicdScanPolicies: [CICDScanPolicy]!
  cloudConfigurationRule: CloudConfigurationRule
}

input CloudEventDateTimeFilter {
  before: DateTime
  after: DateTime
}

type CloudEventExternalType {
  cloudProvider: CloudProvider!
  name: String!
}

input CloudEventExternalTypeFilters {
  cloudPlatform: [String!]
  nameStartsWith: String
  nameContains: String
}

union CloudEventExtraDetails = CloudEventRuntimeDetails | CloudEventAdmissionReviewDetails | CloudEventFimDetails

type CloudEventFileReputationHashMatch {
  malwareClassification: CloudEventMalwareClassification
  md5: String!
  name: String
  sampleFirstSeen: DateTime
  sampleLastSeen: DateTime
  scannerCount: Int
  scannerMatch: Int
  scannerPercent: Int
  sha1: String!
  sha256: String!
  trustFactor: Int
}

input CloudEventFilters {
  or: [CloudEventFilters!]
  and: [CloudEventFilters!]
  timestamp: CloudEventDateTimeFilter
  cloudPlatform: CloudEventStringFilter
  id: CloudEventStringFilter
  name: CloudEventStringFilter
  externalId: CloudEventStringFilter
  externalName: CloudEventStringFilter
  source: CloudEventStringFilter
  category: CloudEventStringFilter
  actor: CloudEventActorFilters
  resource: CloudEventResourceFilters
  rawAuditLogRecord: CloudEventStringFilter
  rawAuditLogRecordPath: CloudEventJsonPathFilter
  matchedRules: [CloudEventFiltersMatchedRule!]
  kind: CloudEventKindFilter
  severity: CloudEventSeverityFilter
  origin: CloudEventOriginFilter
  path: CloudEventStringArrayFilter
  hash: CloudEventStringArrayFilter
  errorCode: CloudEventStringFilter
  errorMessage: CloudEventStringFilter
  admissionControllerReview: CloudEventAdmissionControllerReviewFilters
}

input CloudEventFiltersMatchedRule {
  id: String!
  minVersion: Int
  version: [Int!]
}

type CloudEventFimDetails {
  previousHash: [String!]
}

input CloudEventGroupBy {
  fields: [String!]!
  countConstraint: CloudEventGroupByCountConstraint
  eventTimeBin: CloudEventGroupByTimeBin
}

input CloudEventGroupByCountConstraint {
  greaterThan: Int
  equals: Int
  lessThan: Int
}

type CloudEventGroupByResult {
  cloudEvents: [CloudEvent!]!
  count: Int!
  resourceCloudAccount: CloudAccount @deprecated(reason: "use cloudEvents field instead")
  values: [AnyValue!]
}

enum CloudEventGroupByTimeBin {
  MINUTE
  HOUR
  DAY
}

input CloudEventIntFilter {
  equals: [Int!]
  notEquals: [Int!]
}

input CloudEventJsonPathFilter {
  path: String!
  equals: [AnyValue]
  notEquals: [AnyValue]
  startsWith: [String!]
  doesNotStartWith: [String!]
  endsWith: [String!]
  doesNotEndWith: [String!]
  contains: [String!]
  doesNotContain: [String!]
  before: DateTime
  after: DateTime
  greaterThan: Int
  lessThan: Int
}

enum CloudEventKind {
  CLOUD_AUDIT_LOG
  CSP_THREAT_DETECTION
  KUBERNETES_AUDIT_LOG
  FILE_INTEGRITY_MONITORING
  WORKLOAD_RUNTIME
  ADMISSION_CONTROLLER
}

input CloudEventKindFilter {
  equals: [CloudEventKind!]
  notEquals: [CloudEventKind!]
}

input CloudEventKubernetesFlavorFilter {
  equals: [KubernetesFlavor!]
  notEquals: [KubernetesFlavor!]
}

type CloudEventMalwareClassification {
  family: String
  isGeneric: Boolean
  platform: String
  subPlatform: String
  type: String
  vulnerability: Vulnerability
}

type CloudEventMatchedRule {
  rule: CloudEventRule!
  version: Int!
}

enum CloudEventOrigin {
  WIZ_SENSOR
  WIZ_ADMISSION_CONTROLLER
  WIZ_FILE_INTEGRITY_MONITORING
  AWS_GUARD_DUTY
  AWS_CLOUDTRAIL
  AZURE_DEFENDER_FOR_CLOUD
  AZURE_ACTIVITY_LOGS
  GCP_SECURITY_COMMAND_CENTER
  GCP_AUDIT_LOGS
  WIZ_AGENTLESS_FILE_INTEGRITY_MONITORING
}

input CloudEventOriginFilter {
  equals: [CloudEventOrigin!]
  notEquals: [CloudEventOrigin!]
}

type CloudEventResource {
  cloudAccount: CloudAccount
  externalId: String
  hostname: String
  id: ID
  kubernetesCluster: GraphEntity
  kubernetesClusterFlavor: KubernetesFlavor
  kubernetesClusterNamespace: GraphEntity
  name: String
  nativeType: String
  openToAllInternet: Boolean!
  providerUniqueId: String
  region: String
  type: GraphEntityTypeValue
}

input CloudEventResourceFilters {
  id: CloudEventStringArrayFilter
  externalId: CloudEventStringArrayFilter
  providerUniqueId: CloudEventStringArrayFilter
  type: CloudEventResourceTypeFilter
  nativeType: CloudEventStringFilter
  name: CloudEventStringFilter
  cloudAccountId: CloudEventStringFilter
  region: CloudEventStringFilter
  openToAllInternet: CloudEventBooleanFilter
  kubernetesFlavor: CloudEventKubernetesFlavorFilter
  kubernetesClusterId: CloudEventStringFilter
  kubernetesNamespaceId: CloudEventStringFilter
}

input CloudEventResourceTypeFilter {
  equals: [GraphEntityTypeValue!]
  notEquals: [GraphEntityTypeValue!]
}

type CloudEventRule {
  builtin: Boolean!
  builtInId: String
  cloudProviders: [CloudProvider!]!
  createdAt: DateTime!
  createdBy: User
  description: String
  enabled: Boolean!
  generateFindings: Boolean!
  id: ID!
  matchedEventCount(after: DateTime, latestVersion: Boolean = true): Int!
  name: String!
  opaMatcher: String!
  opaMatcherLastUpdatedAt: DateTime!
  project: Project
  rateLimitedAt: DateTime
  severity: CloudEventRuleSeverity!
  sourceType: CloudEventSourceType
  subCategories: [SecuritySubCategory]
  targetEventNames: [String!]
  updatedAt: DateTime!
  version: Int!
}

type CloudEventRuleConnection {
  edges: [CloudEventRuleEdge!]
  nodes: [CloudEventRule!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum CloudEventRuleCreatorType {
  USER
  BUILT_IN
}

type CloudEventRuleEdge {
  cursor: String!
  node: CloudEventRule!
}

input CloudEventRuleFilters {
  search: String
  targetEventName: [String!]
  project: [String!]
  createdBy: [CloudEventRuleCreatorType!]
  frameworkCategory: [String!]
  severity: [CloudEventRuleSeverity!]
  enabled: Boolean
  cloudProvider: [CloudProvider!]
  hasMatches: Boolean
  riskEqualsAny: [String!]
  riskEqualsAll: [String!]
  sourceType: [CloudEventSourceType!]
}

type CloudEventRuleJsonTest {
  match: Boolean!
}

input CloudEventRuleOrder {
  direction: OrderDirection!
  field: CloudEventRuleOrderField!
}

enum CloudEventRuleOrderField {
  MATCHED_EVENT_COUNT
  SEVERITY
  NAME
}

enum CloudEventRuleSeverity {
  INFORMATIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type CloudEventRuntimeContainer {
  externalId: String!
  id: ID!
  image: CloudEventRuntimeContainerImage
  imageGraphEntity: GraphEntity
  kubernetesController: CloudEventRuntimeKubernetesController
  kubernetesControllerGraphEntity: GraphEntity
  pod: CloudEventRuntimeContainerPod
  podGraphEntity: GraphEntity
}

type CloudEventRuntimeContainerImage {
  externalId: String!
  id: ID!
}

type CloudEventRuntimeContainerPod {
  externalId: String!
  id: ID!
  ips: [String!]
  namespace: String!
}

type CloudEventRuntimeDetails {
  host: CloudEventRuntimeHost
  hostGraphEntity: GraphEntity
  processTree: [CloudEventRuntimeProcess!]
  sensor: Sensor
}

type CloudEventRuntimeHost {
  externalId: String
  hostname: String!
  id: String!
  ips: [String!]
  kernelVersion: String!
  type: GraphEntityTypeValue!
}

type CloudEventRuntimeKubernetesController {
  externalId: String!
  id: ID!
  type: CloudEventRuntimeKubernetesControllerType
}

enum CloudEventRuntimeKubernetesControllerType {
  JOB
  CRON_JOB
  DEPLOYMENT
  REPLICA_SET
  STATEFUL_SET
  DAEMON_SET
}

type CloudEventRuntimeProcess {
  command: String
  container: CloudEventRuntimeContainer
  containerGraphEntity: GraphEntity
  executionTime: DateTime
  hash: String
  id: String!
  name: String
  path: String!
  size: Int
  userId: String
  userName: String
}

union CloudEventSearchResult = CloudEvent | CloudEventGroupByResult

type CloudEventSearchResultConnection {
  edges: [CloudEventSearchResultEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 5000): String
  maxCountReached: Boolean!
  nodes: [CloudEventSearchResult!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CloudEventSearchResultEdge {
  cursor: String!
  node: CloudEventSearchResult!
}

type CloudEventSensorRulesMatch {
  fileReputationHashMatch: [CloudEventFileReputationHashMatch!]
  sensorEngineRules: [SensorEngineMatchedRule]
}

input CloudEventSeverityFilter {
  equals: [CloudEventRuleSeverity!]
  notEquals: [CloudEventRuleSeverity!]
}

enum CloudEventSourceType {
  WIZ
  GUARD_DUTY
  SECURITY_COMMAND_CENTER
  DEFENDER_FOR_CLOUD
}

input CloudEventStringArrayFilter {
  equals: [String!]
  notEquals: [String!]
  contains: [String!]
  doesNotContain: [String!]
}

input CloudEventStringFilter {
  equals: [String!]
  notEquals: [String!]
  startsWith: [String!]
  doesNotStartWith: [String!]
  endsWith: [String!]
  doesNotEndWith: [String!]
  contains: [String!]
  doesNotContain: [String!]
}

union CloudEventTrigger = CloudEventSensorRulesMatch | CloudEventAdmissionReview

type CloudEventType {
  cloudProvider: CloudProvider!
  name: String!
}

input CloudEventTypeFilters {
  cloudPlatform: [String!]
  nameStartsWith: String
  nameContains: String
}

type CloudOrganization implements Node {
  cloudProvider: CloudProvider!
  externalId: String!
  id: ID!
  name: String!
  path: String!
}

type CloudOrganizationConnection {
  edges: [CloudOrganizationEdge!]
  nodes: [CloudOrganization!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CloudOrganizationEdge {
  cursor: String!
  node: CloudOrganization!
}

input CloudOrganizationFilters {
  search: [String!]
  projectId: String
  cloudProvider: [CloudProvider!]
}

enum CloudPlatform {
  GCP
  AWS
  Azure
  OCI
  Alibaba
  vSphere
  AKS
  EKS
  GKE
  Kubernetes
  OpenShift
  OKE
  Linode
}

enum CloudProvider {
  GCP
  AWS
  Azure
  OCI
  Alibaba
  vSphere
  OpenShift
  Kubernetes
  Linode
}

enum CloudResourceStatus {
  Active
  Inactive
  Error
}

input CommonDateFilter {
  before: DateTime
  after: DateTime
  inLast: DurationFilter
  beforeLast: DurationFilter
}

input CommonNumberFilter {
  isSet: Boolean
  equals: Float
  notEquals: Float
  greaterThan: Float
  lessThan: Float
}

type CompleteAuthMigrationStatusPayload {
  authMigration: AuthMigration!
}

union ComplianceAnalyticsDataPointPolicy = Control | CloudConfigurationRule | HostConfigurationRule

type ComplianceAnalyticsOverview {
  dataPoints: [ComplianceAnalyticsOverviewDataPoint!]!
}

type ComplianceAnalyticsOverviewDataPoint {
  category: SecurityCategory
  framework: SecurityFramework
  policy: ComplianceAnalyticsDataPointPolicy
  posture: Int
  subCategory: SecuritySubCategory
}

input ComplianceAnalyticsOverviewSelection {
  frameworkCategory: [String!]
  selectChildren: Boolean
}

enum ComplianceEmptyPostureReason {
  NO_POLICIES
  NO_RESOURCES
}

type ComputeGroupTagsSet implements Node {
  id: ID!
  name: String!
  tags: [String!]!
}

enum ConfigurationBenchmarkTypeId {
  AWS_CIS_1_2_0
  AWS_CIS_1_3_0
  AZURE_CIS_1_1_0
  AZURE_CIS_1_3_0
  GCP_CIS_1_1_0
}

type ConfigurationFinding implements Node {
  analyzedAt: DateTime!
  evidence: ConfigurationFindingEvidence!
  firstSeenAt: DateTime!
  id: ID!
  ignoreRules: [IgnoreRule]
  note: ConfigurationFindingNote
  remediation: String
  resolutionReason: FindingResolutionReason
  resource: ConfigurationFindingResource
  result: ConfigurationFindingResult!
  rule: CloudConfigurationRule!
  securitySubCategories: [SecuritySubCategory!]
  severity: ConfigurationFindingSeverity!
  source: ConfigurationSource!
  status: FindingCommonStatus!
  subscription: CloudAccount
  targetExternalId: String
  targetObjectProviderUniqueId: String
  type: ConfigurationFindingType! @deprecated(reason: "Deprecated property")
}

type ConfigurationFindingConnection {
  edges: [ConfigurationFindingEdge!]
  errorCount: Int!
  exportUrl(format: ExportFormats = CSV, limit: Int = 1000): String
  failCount: Int!
  maxCountReached: Boolean!
  nodes: [ConfigurationFinding!]
  notAssessedCount: Int!
  pageInfo: PageInfo!
  passCount: Int!
  totalCount: Int!
}

input ConfigurationFindingDateFilters {
  before: DateTime
  after: DateTime
}

type ConfigurationFindingEdge {
  cursor: String!
  node: ConfigurationFinding!
}

type ConfigurationFindingEvidence {
  cloudConfigurationLink: String
  configurationPath: String
  currentValue: String
  expectedValue: String
}

enum ConfigurationFindingField {
  ID
  ANALYZED_AT
  FIRST_SEEN_AT
}

input ConfigurationFindingFilters {
  id: [ID!]
  source: [ConfigurationSource!]
  rule: ConfigurationRuleFilters
  resource: ConfigurationFindingResourceFilters
  analyzedAt: ConfigurationFindingDateFilters
  firstSeenAt: ConfigurationFindingDateFilters
  result: [ConfigurationFindingResult!]
  severity: [ConfigurationFindingSeverity!]
  benchmark: [ConfigurationBenchmarkTypeId!]
  securityFramework: [String!]
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
  type: [ConfigurationFindingType!]
  hasRemediationInstructions: Boolean
  status: [FindingCommonStatus!]
}

type ConfigurationFindingNote implements Node {
  createdAt: DateTime!
  id: ID!
  serviceAccount: ServiceAccount
  text: String!
  updatedAt: DateTime!
  user: User
}

input ConfigurationFindingOrder {
  direction: OrderDirection!
  field: ConfigurationFindingField!
}

type ConfigurationFindingResource implements Node {
  cloudPlatform: String
  connectors: [Connector]
  id: ID!
  name: String
  nativeType: String
  projects: [Project]
  providerId: String
  region: String
  resourceGroupId: String
  status: ConfigurationFindingResourceStatus
  subscription: CloudAccount
  tags: [ConfigurationFindingResourceTag!]
  type: GraphEntityTypeValue!
}

input ConfigurationFindingResourceFilters {
  id: [String!]
  type: [GraphEntityTypeValue!]
  projectId: [String!]
  name: [String!]
  status: [ConfigurationFindingResourceStatus!]
  subscriptionId: [String!]
  cloudPlatform: [String!]
  nativeType: [String!]
  tags: [String!]
}

enum ConfigurationFindingResourceStatus {
  Active
  Inactive
  Error
}

type ConfigurationFindingResourceTag {
  key: String
  value: String
}

enum ConfigurationFindingResult {
  PASS
  FAIL
  ERROR
  NOT_ASSESSED
}

enum ConfigurationFindingSeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ConfigurationFindingType {
  WIZ_CSPM
}

input ConfigurationRuleFilters {
  id: [String!]
  name: [String!]
  description: [String!]
}

enum ConfigurationSource {
  WIZ_CSPM
  ASC
  AWSInspector
}

type Connector implements Node {
  addedBy: User!
  authParams: JSON!
  config: ConnectorConfigs
  connectorIssues: [ConnectorCloudAccountIssues!]
  connectorModules: [ConnectorModule!]
  createdAt: DateTime!
  createdBy: ConnectorCreator
  criticalIssueCount: Int!
  enabled: Boolean!
  errorCode: ConnectorErrorCode
  eventTriggeredScanning: ConnectorEventTriggeredScanning
  extraConfig: JSON
  highIssueCount: Int!
  id: ID!
  identityClient: TenantIdentityClient
  lastActivity: DateTime
  lowIssueCount: Int!
  mediumIssueCount: Int!
  name: String!
  outpost: Outpost
  resourceAnalytics: ConnectorResourceAnalytics
  scannedEntities: [ConnectorScannedEntity!]
  status: ConnectorStatus!
  statusLog: JSON!
  type: ConnectorType!
}

input ConnectorAuthConfigAKSInput {
  apiServerEndpoint: String!
  tlsConfig: TLSConfigInput!
  athProviderConfig: AuthProviderConfigAKSInput!
}

input ConnectorAuthConfigAlibabaInput {
  credentialsType: AlibabaConnectorCredentialsType!
  accessKeyID: String!
  accessKeySecret: String!
  assumeRoleDelegatorARN: String!
  accessRoleARN: String!
  accessRoleName: String
  resourceScanner: ConnectorConfigAlibabaResourceScannerInput
}

input ConnectorAuthConfigAWSInput {
  customerRoleARN: String!
  externalIdNonce: String!
}

type ConnectorAuthConfigAWSOutpost {
  scanner: ConnectorAuthConfigAWSOutpostScanner!
}

type ConnectorAuthConfigAWSOutpostScanner {
  externalID: String!
  roleARN: String!
}

input ConnectorAuthConfigAzureInput {
  tenantId: String!
  clientId: String!
  clientSecret: String!
  isManagedIdentity: Boolean!
  groupId: String
  subscriptionId: String
  monitorEventHubConnectionString: String
}

input ConnectorAuthConfigContainerRegistryInput {
  username: String!
  password: String!
  proxyURL: String
  isOnPrem: Boolean
  onPremTunnelDomain: String
  onPremTunnelToken: String
}

input ConnectorAuthConfigECRInput {
  reader: ECRRoleConfig!
  scanner: ECRRoleConfig
}

input ConnectorAuthConfigEKSInput {
  apiServerEndpoint: String!
  tlsConfig: TLSConfigInput!
  authProviderConfig: AuthProviderConfigEKSInput!
}

input ConnectorAuthConfigFiremonInput {
  host: String
  username: String!
  password: String!
  serverUrl: String
  isOnPrem: Boolean!
}

input ConnectorAuthConfigGCPInput {
  configFile: JSON!
}

input ConnectorAuthConfigGithubInput {
  serverType: String!
  token: String
  serverUrl: String
  isOnPrem: Boolean!
}

input ConnectorAuthConfigGKEInput {
  configFile: JSON
  apiServerEndpoint: String!
  tlsConfig: TLSConfigInput!
}

input ConnectorAuthConfigJenkinsInput {
  user: String!
  token: String!
  url: String!
}

input ConnectorAuthConfigJFrogArtifactoryInput {
  serverType: String!
  baseUrl: String
  user: String!
  apiKey: String!
  serverUrl: String
  isOnPrem: Boolean!
}

input ConnectorAuthConfigJiraInput {
  jiraUrl: String!
  user: String!
  token: String!
}

input ConnectorAuthConfigKubernetesInput {
  apiServerEndpoint: String!
  tlsConfig: TLSConfigInput!
  authProviderConfig: AuthProviderConfigKubernetesInput!
}

input ConnectorAuthConfigLinodeInput {
  token: String!
}

input ConnectorAuthConfigOCIInput {
  TenancyOCID: String!
  HomeRegion: String!
  UserOCID: String!
  Fingerprint: String!
  PrivateKey: String!
}

input ConnectorAuthConfigOKEInput {
  apiServerEndpoint: String!
  tlsConfig: TLSConfigInput!
  authProviderConfig: AuthProviderConfigOKEInput!
  clusterExternalID: String!
}

input ConnectorAuthConfigServiceNowInput {
  baseUrl: String!
  user: String!
  password: String!
}

input ConnectorAuthConfigSnykInput {
  token: String!
}

input ConnectorAuthConfigVSphereInput {
  username: String!
  password: String!
  serverUrl: String!
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
}

type ConnectorCategory implements Node {
  id: ID!
  name: String!
}

type ConnectorCloudAccountIssues {
  affectedCloudAccounts: [ConnectorIssueAffectedCloudAccount!]!
  connectorIssue: ConnectorIssue!
  count: Int!
}

input ConnectorConfigAKSInput {
  authParams: ConnectorAuthConfigAKSInput!
  name: String!
  type: String!
}

type ConnectorConfigAlibaba {
  accessKeyID: String!
  accessKeySecret: String!
  accessRoleARN: String
  accessRoleName: String
  assumeRoleDelegatorARN: String!
  cloudType: String!
  credentialsType: AlibabaCredentialsType!
  diskAnalyzerInFlightDisabled: Boolean
  excludedAccounts: [String!]
  includedAccounts: [String!]
  resourceScanner: ConnectorConfigAlibabaResourceScanner
}

input ConnectorConfigAlibabaInput {
  authParams: ConnectorAuthConfigAlibabaInput!
  name: String!
  type: String!
}

type ConnectorConfigAlibabaResourceScanner {
  resourcesGroupID: String!
  roleName: String!
}

input ConnectorConfigAlibabaResourceScannerInput {
  roleName: String!
  resourcesGroupID: String!
}

type ConnectorConfigAWS {
  auditLogMonitorEnabled: Boolean
  cloudTrailConfig: ConnectorConfigAWSCloudTrail
  customerRoleARN: String!
  diskAnalyzer: ConnectorAuthConfigAWSOutpost
  diskAnalyzerInFlightDisabled: Boolean
  excludedAccounts: [String!]
  excludedOUs: [String!]
  externalIdNonce: String!
  includedAccounts: [String!]
  optedInRegions: [String!]
  region: String
  skipOrganizationScan: Boolean
  subAccountRole: String
}

type ConnectorConfigAWSCloudTrail {
  bucketName: String
  bucketSubAccount: String
  notificationType: ConnectorConfigAWSCloudTrailNotificationType! @deprecated(reason: "notification type is now auto-detectable")
  trailOrg: String
  trailPrefix: String @deprecated(reason: "known prefix templates are automatically skipped")
}

enum ConnectorConfigAWSCloudTrailNotificationType {
  cloudtrail
  s3
}

input ConnectorConfigAWSInput {
  authParams: ConnectorAuthConfigAWSInput!
  name: String!
  type: String!
}

type ConnectorConfigAzure {
  auditLogMonitorEnabled: Boolean
  azureMonitorConfig: ConnectorConfigAzureMonitor
  clientId: String
  clientSecret: String
  diskAnalyzerInFlightDisabled: Boolean
  diskanalyzerSecretName: String
  environment: String
  excludedSubscriptions: [String!]
  groupId: String
  includedSubscriptions: [String!]
  isManagedIdentity: Boolean!
  monitorEventHubConnectionString: String!
  snapshotsResourceGroupId: String
  subscriptionId: String
  tenantId: String!
}

input ConnectorConfigAzureInput {
  authParams: ConnectorAuthConfigAzureInput!
  name: String!
  type: String!
}

type ConnectorConfigAzureMonitor {
  eventHub: ConnectorConfigAzureMonitorEventHub
}

type ConnectorConfigAzureMonitorEventHub {
  resourceGroup: String!
  subscriptionId: String!
}

type ConnectorConfigContainerRegistry {
  authParams: JSON
  filter: ConnectorConfigContainerRegistryFilter
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  proxyURL: String @deprecated(reason: "Set through auth params instead")
  pullURL: String
  registryURL: String
  scan: ConnectorConfigContainerRegistryScan
  url: String!
}

type ConnectorConfigContainerRegistryFilter {
  exclude: [String!]
  include: [String!]
}

input ConnectorConfigContainerRegistryInput {
  authParams: ConnectorAuthConfigContainerRegistryInput!
  extraConfig: ConnectorExtraConfigContainerRegistryInput
  name: String!
  type: String!
}

type ConnectorConfigContainerRegistryScan {
  cap: Int!
  maxImageAgeDays: Int
  scanIntervalHours: Int!
}

input ConnectorConfigECRInput {
  authParams: ConnectorAuthConfigECRInput!
  extraConfig: ConnectorExtraConfigContainerRegistryInput
  name: String!
  type: String!
}

input ConnectorConfigEKSInput {
  authParams: ConnectorAuthConfigEKSInput!
  name: String!
  type: String!
}

type ConnectorConfigFiremon {
  host: String!
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  password: String!
  serverUrl: String
  username: String!
}

input ConnectorConfigFiremonInput {
  authParams: ConnectorAuthConfigFiremonInput!
  name: String!
  type: String!
}

type ConnectorConfigGCP {
  auditLogMonitorEnabled: Boolean
  auditLogsConfig: ConnectorConfigGCPAuditLogs
  auth_provider_x509_cert_url: String
  auth_uri: String
  client_email: String
  client_id: String
  client_x509_cert_url: String
  delegateUser: String
  diskAnalyzerInFlightDisabled: Boolean
  excludedFolders: [String!]
  excludedProjects: [String!]
  includedFolders: [String!]
  isManagedIdentity: Boolean!
  organization_id: String
  private_key: String
  private_key_id: String
  project_id: String
  projects: [String!]
  token_uri: String
  type: String
}

type ConnectorConfigGCPAuditLogs {
  pub_sub: ConnectorConfigGCPPubSub
}

input ConnectorConfigGCPInput {
  authParams: ConnectorAuthConfigGCPInput!
  extraConfig: ConnectorExtraConfigGCPInput
  name: String!
  type: String!
}

type ConnectorConfigGCPPubSub {
  subscriptionID: String!
  topicName: String!
}

type ConnectorConfigGithub {
  branches: [String!]
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  repos: [String!]
  serverType: String!
  serverUrl: String
  token: String!
}

input ConnectorConfigGithubInput {
  authParams: ConnectorAuthConfigGithubInput!
  extraConfig: ConnectorExtraConfigGithubInput
  name: String!
  type: String!
}

input ConnectorConfigGKEInput {
  authParams: ConnectorAuthConfigGKEInput!
  name: String!
  type: String!
}

input ConnectorConfigJenkinsInput {
  authParams: ConnectorAuthConfigJenkinsInput!
  name: String!
  type: String!
}

type ConnectorConfigJFrogArtifactory {
  apiKey: String!
  baseUrl: String!
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  serverType: String!
  serverUrl: String
  user: String!
}

input ConnectorConfigJFrogArtifactoryInput {
  authParams: ConnectorAuthConfigJFrogArtifactoryInput!
  name: String!
  type: String!
}

type ConnectorConfigJira {
  alternativeDescriptionField: String
  assignee: String
  components: [String!]
  customFields: String
  fixVersion: [String!]
  isOnPrem: Boolean!
  issueType: String!
  jiraUrl: String!
  labels: [String!]
  onPremTunnelDomain: String
  onPremTunnelToken: String
  priority: String!
  project: String!
  serverType: String
  serverUrl: String
  token: String!
  user: String!
}

input ConnectorConfigJiraInput {
  authParams: ConnectorAuthConfigJiraInput!
  extraConfig: ConnectorExtraConfigJiraInput!
  name: String!
  type: String!
}

type ConnectorConfigKubernetes {
  apiServerEndpoint: String!
  authProvider: String
  authProviderConfig: JSON
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  serverUrl: String
  tlsConfig: TLSConfig
}

input ConnectorConfigKubernetesInput {
  authParams: ConnectorAuthConfigKubernetesInput!
  name: String!
  type: String!
}

type ConnectorConfigLinode {
  token: String!
}

input ConnectorConfigLinodeInput {
  authParams: ConnectorAuthConfigLinodeInput!
  name: String!
  type: String!
}

type ConnectorConfigOCI {
  diskAnalyzerInFlightDisabled: Boolean
  fingerprint: String!
  homeRegion: String!
  privateKey: String!
  tenancyOCID: String!
  userOCID: String!
}

input ConnectorConfigOCInput {
  authParams: ConnectorAuthConfigOCIInput!
  name: String!
  type: String!
}

input ConnectorConfigOKEInput {
  authParams: ConnectorAuthConfigOKEInput!
  name: String!
  type: String!
}

union ConnectorConfigs = ConnectorConfigAWS | ConnectorConfigAzure | ConnectorConfigGCP | ConnectorConfigOCI | ConnectorConfigAlibaba | ConnectorConfigVSphere | ConnectorConfigKubernetes | ConnectorConfigContainerRegistry | ConnectorConfigGithub | ConnectorConfigJFrogArtifactory | ConnectorConfigServiceNow | ConnectorConfigJira | ConnectorConfigFiremon | ConnectorConfigLinode

type ConnectorConfigServiceNow {
  baseUrl: String!
  customFields: String
  password: String!
  tableName: String!
  user: String!
}

input ConnectorConfigServiceNowInput {
  authParams: ConnectorAuthConfigServiceNowInput!
  extraConfig: ConnectorExtraConfigServiceNowInput!
  name: String!
  type: String!
}

input ConnectorConfigSnykInput {
  authParams: ConnectorAuthConfigSnykInput!
  name: String!
  type: String!
}

type ConnectorConfigTestResult {
  success: Boolean!
}

type ConnectorConfigVSphere {
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  password: String!
  serverUrl: String
  username: String!
}

input ConnectorConfigVSphereInput {
  authParams: ConnectorAuthConfigVSphereInput!
  name: String!
  type: String!
}

type ConnectorConnection {
  edges: [ConnectorEdge!]
  nodes: [Connector!]
  pageInfo: PageInfo!
  totalCount: Int!
}

union ConnectorCreator = User | Connector

enum ConnectorCreatorType {
  USER
  BUILT_IN
}

type ConnectorEdge {
  cursor: String!
  node: Connector!
}

enum ConnectorErrorCode {
  CONNECTION_ERROR
  DISK_SCAN_ERROR
}

type ConnectorEventTriggeredScanning {
  errors: [ConnectorEventTriggeredScanningError!]
  status: ConnectorEventTriggeredScanningStatus!
  updatedAt: DateTime!
}

type ConnectorEventTriggeredScanningError {
  message: String!
  updatedAt: DateTime!
}

enum ConnectorEventTriggeredScanningStatus {
  DISABLED
  INITIALIZING
  CONNECTED
  ERROR
}

input ConnectorExtraConfigContainerRegistryAccessTokenInput {
  provider: ConnectorExtraConfigContainerRegistryAccessTokenProvider!
}

enum ConnectorExtraConfigContainerRegistryAccessTokenProvider {
  artifactory
}

input ConnectorExtraConfigContainerRegistryFilterInput {
  include: [String!]
  exclude: [String!]
}

input ConnectorExtraConfigContainerRegistryInput {
  url: String!
  pullURL: String
  filter: ConnectorExtraConfigContainerRegistryFilterInput
  scan: ConnectorExtraConfigContainerRegistryScanInput
  accessToken: ConnectorExtraConfigContainerRegistryAccessTokenInput
  registryURL: String
  proxyURL: String
}

input ConnectorExtraConfigContainerRegistryScanInput {
  scanIntervalHours: Int!
  cap: Int!
  maxImageAgeDays: Int
}

input ConnectorExtraConfigGCPInput {
  projects: [String!]
  delegateUser: String
  excludedProjects: [String!]
}

input ConnectorExtraConfigGithubInput {
  repos: [String!]
  branches: [String!]
}

input ConnectorExtraConfigJiraInput {
  project: String!
  issueType: String!
  components: [String!]
  fixVersion: String
  assignee: String
  priority: String!
  labels: [String!]
  customFields: JSON
}

input ConnectorExtraConfigServiceNowInput {
  tableName: String!
  customFields: JSON
}

input ConnectorFilters {
  search: String
  connectorType: [String!]
  enabled: Boolean
  status: [ConnectorStatus!]
  cloudAccountExternalId: [String!]
  createdByType: [ConnectorCreatorType!]
  outpostID: [String!]
  kubernetesClusterExternalIds: [String!]
  eventTriggeredScanningEnabled: Boolean
}

type ConnectorIssue {
  context: [String!]!
  description: String!
  impact: String!
  issueIdentifier: String!
  moduleNames: [String!]
  regions: [String!]
  remediation: String!
  severity: ConnectorIssueSeverity!
}

type ConnectorIssueAffectedCloudAccount {
  externalId: ID!
  name: String!
  regions: [String!]
}

type ConnectorIssueCountInfo {
  connectedCount: Int!
  count: Int!
  entityType: GraphEntityTypeValue!
  errorCount: Int!
  partiallyConnectedCount: Int!
}

enum ConnectorIssueSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type ConnectorModule {
  issues: [ConnectorModuleIssue!]
  name: String!
  stats: [ConnectorIssueCountInfo!]
  status: ConnectorModuleStatus!
}

type ConnectorModuleIssue {
  issue: ConnectorIssue!
  issuesCounters: [ConnectorIssueCountInfo!]
}

enum ConnectorModuleStatus {
  CONNECTED
  PARTIALLY_CONNECTED
  ERROR
}

input ConnectorOrder {
  direction: OrderDirection!
  field: ConnectorOrderField!
}

enum ConnectorOrderField {
  CREATED_AT
  LAST_ACTIVITY
}

type ConnectorResourceAnalytics {
  cloudAccountCount: Int!
  serverlessCount: Int!
  virtualMachineCount: Int!
}

union ConnectorScannedEntity = CloudAccount | Repository

enum ConnectorStatus {
  INITIAL_SCANNING
  PARTIALLY_CONNECTED
  ERROR
  CONNECTED
  DISABLED
}

type ConnectorType implements Node {
  authorizeUrls: [String!]
  categories: [ConnectorCategory!]!
  id: ID!
  name: String!
  technology: Technology!
}

type ContainerImageAnalytics {
  vulnerabilities: ArtifactAnalyticsVulnerabilities
}

interface ContainerImageBase {
  analytics: ContainerImageAnalytics!
  digest: String!
  findings(after: String, first: Int): ArtifactFindingsConnection
  id: ID!
  imageTags: [String!]
  lastScannedAt: DateTime
  name: String!
  nativeType: String
  repository: ContainerRepository!
  shortName: String!
  updatedAt: DateTime
}

type ContainerImageConnection {
  edges: [ContainerImageEdge!]
  nodes: [ContainerImageBase!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input ContainerImageDateTimeFilter {
  after: DateTime
  before: DateTime
}

type ContainerImageEdge {
  cursor: String!
  node: ContainerImageBase!
}

input ContainerImageFilters {
  id: [ID!]
  search: String
  registry: [ID!]
  repository: [ID!]
  vulnerability: ContainerImageVulnerabilityFilter
  lastScannedAt: ContainerImageDateTimeFilter
}

type ContainerImageGeneric implements Node & ContainerImageBase {
  analytics: ContainerImageAnalytics!
  digest: String!
  findings(after: String, first: Int): ArtifactFindingsConnection
  id: ID!
  imageTags: [String!]
  lastScannedAt: DateTime
  name: String!
  nativeType: String
  repository: ContainerRepository!
  shortName: String!
  updatedAt: DateTime
}

input ContainerImageOrder {
  field: ContainerImageOrderField!
  direction: OrderDirection!
}

enum ContainerImageOrderField {
  UPDATED_AT
  SEVERITY
}

enum ContainerImageScanSource {
  WORKLOAD
  REGISTRY
}

input ContainerImageVulnerabilityFilter {
  severity: [ContainerImageVulnerabilitySeverityFilter!]
}

input ContainerImageVulnerabilitySeverityFilter {
  level: VulnerabilitySeverity!
}

type ContainerRegistry implements Node {
  id: ID!
  name: String!
}

type ContainerRegistryConnection {
  edges: [ContainerRegistryEdge!]
  nodes: [ContainerRegistry!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ContainerRegistryEdge {
  cursor: String!
  node: ContainerRegistry!
}

input ContainerRegistryFilters {
  id: [ID!]
  search: String
}

input ContainerRegistryOrder {
  field: ContainerRegistryOrderField!
  direction: OrderDirection!
}

enum ContainerRegistryOrderField {
  NAME
}

type ContainerRepository implements Node {
  id: ID!
  name: String!
  registry: ContainerRegistry!
  shortName: String!
}

type ContainerRepositoryConnection {
  edges: [ContainerRepositoryEdge!]
  nodes: [ContainerRepository!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ContainerRepositoryEdge {
  cursor: String!
  node: ContainerRepository!
}

input ContainerRepositoryFilters {
  id: [ID!]
  search: String
}

input ContainerRepositoryOrder {
  field: ContainerRepositoryOrderField!
  direction: OrderDirection!
}

enum ContainerRepositoryOrderField {
  NAME
}

type Control implements Node {
  createdAt: DateTime
  createdBy: User
  description: String!
  descriptionPlainText: String!
  enabled: Boolean!
  enabledForHBI: Boolean!
  enabledForLBI: Boolean!
  enabledForMBI: Boolean!
  enabledForUnattributed: Boolean!
  externalReferences: [ControlExternalReference!]
  hasAutoRemediation: Boolean!
  id: ID!
  issueAnalytics(selection: ControlIssueAnalyticsSelection): IssueAnalytics!
  issues(after: String, filterBy: IssueFilters, first: Int, orderBy: IssueOrder): IssueConnection!
  lastRunAt: DateTime
  lastRunError: String
  lastSuccessfulRunAt: DateTime
  name: String!
  originalControl: Control
  originalControlOverridden: Boolean!
  query: GraphEntityQueryValue
  resolutionRecommendation: String
  resolutionRecommendationPlainText: String
  scopeProject: Project
  scopeQuery: GraphEntityQueryValue
  securitySubCategories: [SecuritySubCategory!]
  serviceTickets(selection: ControlServiceTicketsSelectionFilter): [ServiceTicket!]
  severity: Severity!
  sourceCloudConfigurationRule: CloudConfigurationRule
  supportsNRT: Boolean!
  tags: [String!]!
  type: ControlType!
}

type ControlConnection {
  edges: [ControlEdge!]
  enabledCount: Int!
  exportUrl(format: ExportFormats = CSV, issueAnalyticsSelection: ControlIssueAnalyticsSelection, limit: Int = 1000): String
  nodes: [Control!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ControlCreatorType {
  USER
  BUILT_IN
}

type ControlEdge {
  cursor: String!
  node: Control!
}

type ControlExternalReference {
  id: String!
  name: String!
}

input ControlFilters {
  id: [String!]
  search: String
  type: [ControlType!]
  project: [String!]
  createdBy: [ControlCreatorType!]
  securityFramework: [String!]
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
  tag: String
  entityType: [GraphEntityTypeValue!]
  severity: [Severity!]
  withIssues: IssueFilters
  enabled: Boolean
  hasAutoRemediation: Boolean
  riskEqualsAny: [String!]
  riskEqualsAll: [String!]
  excludeFrameworkCategory: [String!]
  originalControlOverridden: Boolean
}

input ControlIssueAnalyticsSelection {
  project: [String!]
}

input ControlOrder {
  direction: OrderDirection!
  field: ControlOrderField!
}

enum ControlOrderField {
  SEVERITY
  ISSUE_COUNT
}

input ControlServiceTicketsSelectionFilter {
  project: [String!]
}

enum ControlType {
  SECURITY_GRAPH
  CLOUD_CONFIGURATION
}

input CreateActionTemplateInput {
  name: String!
  projectId: String
  source: ActionTemplateSource!
  type: ActionTemplateType!
  params: ActionTemplateParamsInput!
}

type CreateActionTemplatePayload {
  actionTemplate: ActionTemplate!
}

input CreateAutomationRuleInput {
  name: String!
  description: String
  triggerSource: AutomationRuleTriggerSource!
  triggerType: [AutomationRuleTriggerType!]!
  filters: JSON
  enabled: Boolean = true
  projectId: String
  actions: [AutomationRuleActionInput!]!
}

type CreateAutomationRulePayload {
  automationRule: AutomationRule
}

input CreateAwsSNSIntegrationParamsInput {
  topicARN: String!
  accessMethod: AwsSNSIntegrationAccessMethodInput!
}

input CreateAzureServiceBusIntegrationParamsInput {
  queueUrl: String!
  accessMethod: AzureServiceBusIntegrationAccessMethodInput!
}

input CreateCICDScanPolicyDiskSecretsInput {
  countThreshold: Int!
  pathAllowList: [String!]
}

input CreateCICDScanPolicyDiskVulnerabilitiesInput {
  severity: DiskScanVulnerabilitySeverity!
  packageCountThreshold: Int!
  ignoreUnfixed: Boolean!
  packageAllowList: [String!]
  detectionMethods: [VulnerabilityDetectionMethod!]
}

input CreateCICDScanPolicyIACInput {
  severityThreshold: IACScanSeverity!
  countThreshold: Int!
  ignoredRules: [String!]
  builtinIgnoreTagsEnabled: Boolean
  customIgnoreTags: [CICDPolicyCustomIgnoreTagCreateInput!]
  securityFrameworks: [String!]
}

input CreateCICDScanPolicyInput {
  name: String!
  description: String
  projectIDs: [String!]
  diskVulnerabilitiesParams: CreateCICDScanPolicyDiskVulnerabilitiesInput
  diskSecretsParams: CreateCICDScanPolicyDiskSecretsInput
  iacParams: CreateCICDScanPolicyIACInput
}

type CreateCICDScanPolicyPayload {
  scanPolicy: CICDScanPolicy
}

input CreateClickUpIntegrationParamsInput {
  key: String!
}

input CreateCloudConfigurationRuleInput {
  name: String!
  description: String
  targetNativeType: String
  targetNativeTypes: [String!]!
  opaPolicy: String
  severity: Severity
  enabled: Boolean
  remediationInstructions: String
  scopeAccountIds: [String!]
  functionAsControl: Boolean
  securitySubCategories: [String!]
  iacMatchers: [CreateCloudConfigurationRuleMatcherInput!]
}

input CreateCloudConfigurationRuleMatcherInput {
  type: CloudConfigurationRuleMatcherType!
  regoCode: String!
}

type CreateCloudConfigurationRulePayload {
  rule: CloudConfigurationRule
}

input CreateCloudEventRuleInput {
  name: String!
  description: String
  targetEventNames: [String!]!
  opaMatcher: String!
  severity: CloudEventRuleSeverity!
  enabled: Boolean
  generateFindings: Boolean
  securitySubCategories: [String!]
  projectId: String
  cloudProviders: [CloudProvider!]!
}

type CreateCloudEventRulePayload {
  rule: CloudEventRule
}

input CreateComputeGroupTagsSetInput {
  name: String!
  tags: [String!]!
}

type CreateComputeGroupTagsSetPayload {
  computeGroupTagsSet: ComputeGroupTagsSet!
}

input CreateConnectorInput {
  name: String!
  type: ID!
  enabled: Boolean = true
  authParams: JSON!
  extraConfig: JSON
}

type CreateConnectorPayload {
  connector: Connector
}

input CreateControlInput {
  query: GraphEntityQueryValue!
  name: String!
  description: String
  resolutionRecommendation: String
  severity: Severity!
  scopeQuery: JSON!
  securitySubCategories: [String!]
  projectId: String!
}

type CreateControlPayload {
  control: Control
}

input CreateCustomIPRangeInput {
  name: String!
  ipRanges: [String!]!
  isInternal: Boolean!
}

type CreateCustomIPRangePayload {
  customIPRange: CustomIPRange
}

input CreateDataClassifierInput {
  name: String!
  description: String
  enabled: Boolean
  category: DataClassifierCategory!
  valueRegex: String!
  excludeRegex: String
  keyRegex: String
  minLength: Int
  maxLength: Int
  minUniqueMatches: Int
  opaValidator: String
  exampleCount: Int
  anonymizerType: DataAnonymizerType
}

type CreateDataClassifierPayload {
  dataClassifier: DataClassifier!
}

input CreateFileIntegrityMonitoringExclusionInput {
  name: String!
  resourceIDs: [String!]
  resourceNames: FileIntegrityMonitoringStringFilterInput
  tags: FileIntegrityMonitoringTagsFilterInput
  filePaths: FileIntegrityMonitoringStringFilterInput
  fileNames: FileIntegrityMonitoringStringFilterInput
}

type CreateFileIntegrityMonitoringExclusionPayload {
  fileIntegrityMonitoringExclusion: FileIntegrityMonitoringExclusion
}

input CreateGcpPubSubIntegrationParamsInput {
  projectId: String!
  topicId: String!
  accessMethod: GooglePubSubIntegrationAccessMethodInput!
}

input CreateHostConfigurationRuleInput {
  name: String!
  description: String
  remediationInstructions: String
  severity: Severity!
  directOVAL: String!
  targetPlatformIds: [String!]
  targetOperatingSystems: [String!]
  targetTechnologies: [String!]
  enabled: Boolean
  securitySubCategories: [String!]
}

type CreateHostConfigurationRulePayload {
  rule: HostConfigurationRule
}

input CreateIgnoreRuleInput {
  name: String!
  description: String!
  findingType: IgnoreRuleFindingType!
  disabledOnCloudScanning: Boolean
  projectId: String
  cloudConfigurationRuleIds: [String!]
  hostConfigurationRuleIds: [String!]
  vulnerabilityIds: [String!]
  findingIgnoreReason: FindingResolutionReason!
  expiredAt: DateTime
  resourceConditions: IgnoreRuleResourceConditionsInput
  cloudConfigurationFindingConditions: IgnoreRuleCloudConfigurationFindingConditionsInput
  hostConfigurationFindingConditions: IgnoreRuleHostConfigurationFindingConditionsInput
  vulnerabilityFindingConditions: IgnoreRuleVulnerabilityFindingConditionsInput
}

type CreateIgnoreRulePayload {
  rule: IgnoreRule!
}

input CreateIntegrationInput {
  name: String!
  type: IntegrationType!
  projectId: String
  params: CreateIntegrationParamsInput!
  isAccessibleToAllProjects: Boolean
}

input CreateIntegrationParamsInput {
  awsSNS: CreateAwsSNSIntegrationParamsInput
  webhook: CreateWebhookIntegrationParamsInput
  slack: CreateSlackIntegrationParamsInput
  slackBot: CreateSlackBotIntegrationParamsInput
  azureServiceBus: CreateAzureServiceBusIntegrationParamsInput
  gcpPubSub: CreateGcpPubSubIntegrationParamsInput
  pagerDuty: CreatePagerDutyIntegrationParamsInput
  jira: CreateJiraIntegrationParamsInput
  serviceNow: CreateServiceNowIntegrationParamsInput
  opsgenie: CreateOpsgenieIntegrationParamsInput
  clickUp: CreateClickUpIntegrationParamsInput
}

type CreateIntegrationPayload {
  integration: Integration!
}

input CreateIssueNoteInput {
  issueId: ID!
  text: String!
}

type CreateIssueNotePayload {
  issueNote: IssueNote!
}

input CreateJiraIntegrationParamsInput {
  serverUrl: String!
  serverType: JiraServerType!
  isOnPrem: Boolean!
  tlsConfig: IntegrationTLSConfigInput
  authorization: JiraIntegrationAuthorizationInput!
}

input CreateJiraTicketFieldsInput {
  summary: String!
  description: String!
  issueType: String!
  assignee: String
  components: [String!]
  fixVersion: [String!]
  labels: [String!]
  priority: String
  project: String!
  alternativeDescriptionField: String
  customFields: JSON
  attachEvidenceCSV: Boolean
}

input CreateMalwareExclusionInput {
  name: String
  resourceIDs: [String!]
  paths: [String!]
  fileNames: [String!]
  fileExtensions: [String!]
}

type CreateMalwareExclusionPayload {
  malwareExclusion: MalwareExclusion
}

input CreateOpsgenieIntegrationParamsInput {
  key: String!
}

input CreateOutpostClusterInput {
  outpostId: ID!
  region: String!
  httpProxyConfig: OutpostClusterHttpProxyConfigInput
  internetAccessConfig: OutpostClusterInternetAccessConfigInput
  selfManagedOutpostCluster: SelfManagedOutpostClusterInput
  manualNetworkOutpostCluster: ManualNetworkOutpostClusterInput
  config: OutpostClusterConfigInput
}

type CreateOutpostClusterPayload {
  cluster: OutpostCluster
}

input CreateOutpostCustomTagInput {
  key: String!
  value: String
}

input CreateOutpostInput {
  name: String!
  serviceType: OutpostServiceType!
  enabled: Boolean = true
  awsConfig: OutpostAWSConfigInput
  gcpConfig: OutpostGCPConfigInput
  azureConfig: OutpostAzureConfigInput
  ociConfig: OutpostOCIConfigInput
  alibabaConfig: OutpostAlibabaConfigInput
  selfManagedConfig: CreateOutpostSelfManagedConfigInput
  managedConfig: CreateOutpostManagedConfigInput
  clusterNamespacePrefix: String
  podAnnotations: [CreateOutpostCustomTagInput!]
  externalInternetAccess: OutpostExternalInternetAccess
  selfManaged: Boolean = false
  customConfig: OutpostCustomConfigInput
  config: OutpostConfigInput
}

input CreateOutpostManagedConfigInput {
  resourceTags: [CreateOutpostCustomTagInput!]
  kubernetesLoggingEnabled: Boolean
  kubernetesCloudMonitoringEnabled: Boolean
  manualNetwork: Boolean
  allowedRegions: [String!]
}

type CreateOutpostPayload {
  outpost: Outpost
}

input CreateOutpostSelfManagedConfigInput {
  imageRepository: String
  imagePullSecret: String
  versionID: ID
  disableAutomaticConfigurationBucketSync: Boolean
  externalInternetAccess: OutpostExternalInternetAccess
}

input CreatePagerDutyIntegrationParamsInput {
  integrationKey: String!
}

input CreateProjectInput {
  name: String!
  slug: String
  description: String
  archived: Boolean
  identifiers: [String!]
  businessUnit: String
  projectOwners: [String!]
  securityChampions: [String!]
  riskProfile: ProjectRiskProfileInput
  repositoryLinks: [ProjectRepositoryLinkInput!]
  cloudAccountLinks: [ProjectCloudAccountLinkInput!]
  cloudOrganizationLinks: [ProjectCloudOrganizationLinkInput!]
  kubernetesClusterLinks: [ProjectKubernetesClusterLinkInput!]
  resourceTagLinks: [ProjectResourceTagsLinkInput!]
}

type CreateProjectPayload {
  project: Project
}

input CreateReportCloudResourceParamsInput {
  includeCloudNativeJSON: Boolean!
  includeWizJSON: Boolean!
  entityType: [GraphEntityTypeValue!]!
  subscriptionId: [String!]
  nativeType: [String!]
  region: [String!]
  cloudPlatform: [String!]
}

input CreateReportComplianceAssessmentsParamsInput {
  subscriptionIds: [String!]
  securityFrameworkIds: [String!]
  securityCategories: [String!]
  result: [PolicyAssessmentResult!]
}

input CreateReportComplianceExecutiveSummaryParamsInput {
  subscriptionIds: [String!]
  securityFrameworkId: String
}

input CreateReportConfigurationFindingParamsInput {
  subscriptionIds: [String!]
  entityIds: [String!]
}

input CreateReportGraphQueryEntityOptions {
  entityType: GraphEntityTypeValue!
  propertyOptions: [CreateReportGraphQueryPropertyOptions!]!
}

input CreateReportGraphQueryParamsInput {
  query: GraphEntityQueryValue!
  entityOptions: [CreateReportGraphQueryEntityOptions!]
}

input CreateReportGraphQueryPropertyOptions {
  key: String!
}

input CreateReportHostConfigurationParamsInput {
  hostConfigurationRuleAssessmentsFilters: HostConfigurationRuleAssessmentFilters
}

input CreateReportInput {
  name: String!
  type: String!
  projectId: String
  runIntervalHours: Int
  runStartsAt: DateTime
  emailTargetParams: EmailTargetParams
  graphQueryParams: CreateReportGraphQueryParamsInput
  vulnerabilityParams: CreateReportVulnerabilityParamsInput
  complianceExecutiveSummaryParams: CreateReportComplianceExecutiveSummaryParamsInput
  complianceAssessmentsParams: CreateReportComplianceAssessmentsParamsInput
  networkExposureParams: CreateReportNetworkExposureParamsInput
  configurationFindingParams: CreateReportConfigurationFindingParamsInput
  securityFrameworkParams: CreateReportSecurityFrameworkParamsInput
  issueParams: CreateReportIssueParamsInput
  hostConfigurationParams: CreateReportHostConfigurationParamsInput
  cloudResourceParams: CreateReportCloudResourceParamsInput
  columnSelection: [String!]
  csvDelimiter: CSVDelimiter
}

input CreateReportIssueParamsInput {
  type: IssueReportType!
  evidenceGraphEntityTypesToInclude: [GraphEntityTypeValue!]
  issueFilters: IssueFilters
}

input CreateReportNetworkExposureParamsInput {
  subscriptionIds: [String!]
  entityIds: [String!]
}

type CreateReportPayload {
  report: Report
}

input CreateReportSecurityFrameworkParamsInput {
  subscriptionIds: [String!]
  entityIds: [String!]
}

input CreateReportVulnerabilityParamsInput {
  type: VulnerabilityReportType
  assetType: VulnerableAssetObjectType
  filters: VulnerabilityFindingFilters
}

input CreateSAMLIdentityProviderInput {
  name: String!
  issuerURL: String
  loginURL: String!
  logoutURL: String
  useProviderManagedRoles: Boolean!
  allowManualRoleOverride: Boolean
  certificate: String!
  domains: [String!]
  groupMapping: [SAMLGroupMappingCreateInput!]
  mergeGroupsMappingByRole: Boolean
  attributeMapping: SAMLAttributeMappingInput
}

type CreateSAMLIdentityProviderPayload {
  samlIdentityProvider: SAMLIdentityProvider
}

input CreateSAMLUserInput {
  email: String!
  idpID: String!
  name: String!
  role: String!
  assignedProjectIds: [String!]
}

type CreateSAMLUserPayload {
  user: User!
}

input CreateSavedCloudEventFilterInput {
  name: String!
  projectId: String
  description: String
  securitySubCategories: [String!]
  filters: JSON!
}

type CreateSavedCloudEventFilterPayload {
  savedCloudEventFilter: SavedCloudEventFilter
}

input CreateSavedGraphQueryInput {
  name: String!
  projectId: String
  description: String
  securitySubCategories: [String!]
  query: GraphEntityQueryValue!
}

type CreateSavedGraphQueryPayload {
  savedGraphQuery: SavedGraphQuery
}

input CreateScannerAPIRateLimitInput {
  cloudProvider: CloudProvider!
  service: ScannerAPIRateLimitService!
  queryRequestsPerSecond: Int
  mutationRequestsPerSecond: Int
}

type CreateScannerAPIRateLimitPayload {
  scannerAPIRateLimit: ScannerAPIRateLimit
}

input CreateSecurityFrameworkInput {
  name: String!
  description: String
  enabled: Boolean = true
  categories: [SecurityCategoryInput!]!
}

type CreateSecurityFrameworkPayload {
  errors: [SecuritySubCategoryAssignmentError!]
  framework: SecurityFramework
}

input CreateServiceAccountInput {
  name: String!
  scopes: [String!]
  assignedProjectIds: [String!]
  type: ServiceAccountType
}

type CreateServiceAccountPayload {
  serviceAccount: ServiceAccount
}

input CreateServiceNowFieldsInput {
  tableName: String!
  customFields: JSON
  summary: String!
  description: String!
  attachEvidenceCSV: Boolean
}

input CreateServiceNowIntegrationParamsInput {
  url: String!
  authorization: ServiceNowIntegrationAuthorizationInput!
}

input CreateSlackBotIntegrationParamsInput {
  token: String!
}

input CreateSlackIntegrationParamsInput {
  url: String!
}

input CreateSupportTicketInput {
  title: String!
  body: String!
}

type CreateSupportTicketPayload {
  id: ID!
  url: String!
}

input CreateUserInput {
  email: String!
  name: String!
  role: String!
  assignedProjectIds: [String!]
  sendEmailInvite: Boolean = true
}

type CreateUserPayload {
  user: User
}

input CreateWebhookIntegrationParamsInput {
  url: String!
  isOnPrem: Boolean
  authorization: WebhookIntegrationAuthorizationInput
  headers: [WebhookHeaderInput!]
  tlsConfig: IntegrationTLSConfigInput
}

enum CSVDelimiter {
  US
  EU
}

type CustomIPRange implements Node {
  createdBy: User
  id: ID!
  ipRanges: [String!]!
  isInternal: Boolean!
  name: String!
}

type CustomIPRangeConnection {
  edges: [CustomIPRangeEdge!]
  nodes: [CustomIPRange!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CustomIPRangeEdge {
  cursor: String!
  node: CustomIPRange!
}

input CustomIPRangeFilters {
  search: String
}

type Dashboard implements Node {
  createdAt: DateTime
  createdBy: User
  description: String
  id: ID!
  name: String!
  widgets: [DashboardWidget!]!
}

type DashboardConnection {
  edges: [DashboardEdge!]
  nodes: [Dashboard!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum DashboardCreatorType {
  USER
  BUILT_IN
}

type DashboardEdge {
  cursor: String!
  node: Dashboard!
}

input DashboardFilters {
  createdBy: [DashboardCreatorType!]
}

type DashboardWidget {
  dataSourceType: DashboardWidgetDataSourceType!
  description: String
  id: ID!
  parameters: JSON!
  size: Int!
  title: String!
  viewType: DashboardWidgetViewType!
}

enum DashboardWidgetDataSourceType {
  GRAPH_QUERY
  SAVED_QUERY
  CONTROL
  ISSUES
  ISSUES_BY_RESOURCE
  ISSUES_BY_CONTROL
  ISSUES_BY_CLOUD_ACCOUNT
  ISSUES_TREND
  INVENTORY
  PROJECTS
  PROJECT
  REPORTS
  GRAPH_QUERIES
  COMPLIANCE
}

enum DashboardWidgetViewType {
  TABLE
  METRIC
  TREND_LINE
  PIE
  BAR
  BUBBLE
  METRICS
}

enum DataAnonymizerType {
  DEFAULT
  EMAIL
  CREDIT_CARD
}

type DataClassifier {
  anonymizerType: DataAnonymizerType
  category: DataClassifierCategory!
  createdAt: DateTime
  createdBy: DataClassifierCreatedBy!
  description: String
  enabled: Boolean!
  exampleCount: Int
  excludeRegex: String
  id: ID!
  keyRegex: String
  maxLength: Int
  minLength: Int
  minUniqueMatches: Int
  name: String!
  opaValidator: String
  query: GraphEntityQueryValue!
  updatedAt: DateTime
  valueRegex: String!
}

enum DataClassifierCategory {
  PII
  PHI
  FINANCIAL
  DIGITAL_IDENTITY
  SECRETS
  OTHER
}

type DataClassifierConnection {
  edges: [DataClassifierEdge!]
  nodes: [DataClassifier!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum DataClassifierCreatedBy {
  BUILT_IN
  USER
}

type DataClassifierEdge {
  cursor: String!
  node: DataClassifier!
}

input DataClassifierFilters {
  search: String
  id: [String!]
  category: [DataClassifierCategory!]
  createdBy: [DataClassifierCreatedBy!]
  enabled: Boolean
}

type DataClassifierTestMatch {
  value: String!
}

input DataClassifierTestMatchInput {
  valueRegex: String!
  excludeRegex: String
  minLength: Int
  maxLength: Int
  opaValidator: String
}

type DataClassifierTestMatchResult {
  match: Boolean!
  matches: [DataClassifierTestMatch!]
}

type DataScannerBucketConfig {
  enabled: Boolean!
  excludedScope: DataScannerScanScope
  includedScope: DataScannerScanScope
  privateBucketsEnabled: Boolean!
  scanIntervalDays: Int!
}

type DataScannerCloudDbConfig {
  enabled: Boolean!
  excludedScope: DataScannerScanScope
  includedScope: DataScannerScanScope
  scanIntervalDays: Int!
}

type DataScannerDiskDbConfig {
  enabled: Boolean!
  scanIntervalDays: Int!
}

type DataScannerDiskFileConfig {
  enabled: Boolean!
  scanIntervalDays: Int!
}

type DataScannerScanScope {
  tags: [ScannerResourceTag!]
}

type DataScannerSettings {
  bucketConfig: DataScannerBucketConfig!
  cloudDbConfig: DataScannerCloudDbConfig!
  diskDbConfig: DataScannerDiskDbConfig!
  diskFileConfig: DataScannerDiskFileConfig!
  enabled: Boolean!
}

input DataScannerSettingsBucketConfigInput {
  enabled: Boolean!
  privateBucketsEnabled: Boolean
  scanIntervalDays: Int!
  excludedScope: DataScannerSettingsScanScopeInput
  includedScope: DataScannerSettingsScanScopeInput
}

input DataScannerSettingsCloudDbConfigInput {
  enabled: Boolean!
  scanIntervalDays: Int!
  excludedScope: DataScannerSettingsScanScopeInput
  includedScope: DataScannerSettingsScanScopeInput
}

input DataScannerSettingsDiskDbConfigInput {
  enabled: Boolean!
  scanIntervalDays: Int!
}

input DataScannerSettingsDiskFileConfigInput {
  enabled: Boolean!
  scanIntervalDays: Int!
}

input DataScannerSettingsResourceTagInput {
  key: String!
  value: String
}

input DataScannerSettingsScanScopeInput {
  tags: [DataScannerSettingsResourceTagInput!]
}

scalar DateTime

input DeleteActionTemplateInput {
  id: ID!
}

type DeleteActionTemplatePayload {
  _stub: String!
}

input DeleteAutomationRuleInput {
  id: ID!
}

type DeleteAutomationRulePayload {
  _stub: String!
}

input DeleteCICDScanInput {
  id: ID!
}

type DeleteCICDScanPayload {
  id: ID!
}

input DeleteCICDScanPolicyInput {
  id: ID!
}

type DeleteCICDScanPolicyPayload {
  id: ID!
}

input DeleteCloudConfigurationRuleInput {
  id: ID!
}

type DeleteCloudConfigurationRulePayload {
  _stub: String!
}

input DeleteCloudEventRuleInput {
  id: ID!
}

type DeleteCloudEventRulePayload {
  _stub: String!
}

input DeleteComputeGroupTagsSetInput {
  id: ID!
}

type DeleteComputeGroupTagsSetPayload {
  success: Boolean!
}

input DeleteConnectorInput {
  id: ID!
}

type DeleteConnectorPayload {
  _stub: String!
}

input DeleteControlInput {
  id: ID!
}

type DeleteControlPayload {
  _stub: String!
}

input DeleteCustomIPRangeInput {
  id: ID!
}

type DeleteCustomIPRangePayload {
  _stub: String!
}

input DeleteDataClassifierInput {
  id: ID!
}

type DeleteDataClassifierPayload {
  _stub: String!
}

input DeleteFileIntegrityMonitoringExclusionInput {
  id: ID!
}

type DeleteFileIntegrityMonitoringExclusionPayload {
  _stub: String!
}

input DeleteHostConfigurationRuleInput {
  id: ID!
}

type DeleteHostConfigurationRulePayload {
  _stub: String!
}

input DeleteIgnoreRuleInput {
  id: ID!
}

type DeleteIgnoreRulePayload {
  _stub: String
}

input DeleteIntegrationInput {
  id: ID!
}

type DeleteIntegrationPayload {
  _stub: String!
}

input DeleteIssueNoteInput {
  id: ID!
}

type DeleteIssueNotePayload {
  _stub: String!
}

input DeleteMalwareExclusionInput {
  id: ID!
}

type DeleteMalwareExclusionPayload {
  _stub: String!
}

input DeleteOutpostClusterInput {
  id: ID!
}

type DeleteOutpostClusterPayload {
  _stub: String!
}

input DeleteOutpostInput {
  id: ID!
}

type DeleteOutpostPayload {
  _stub: String!
}

input DeleteReportInput {
  id: ID!
}

type DeleteReportPayload {
  _stub: String
}

input DeleteSAMLIdentityProviderInput {
  id: ID!
}

type DeleteSAMLIdentityProviderPayload {
  _stub: String!
}

input DeleteSavedCloudEventFilterInput {
  id: ID!
}

type DeleteSavedCloudEventFilterPayload {
  _stub: String!
}

input DeleteSavedGraphQueryInput {
  id: ID!
}

type DeleteSavedGraphQueryPayload {
  _stub: String!
}

type DeleteScannerAPIRateLimitPayload {
  success: Boolean!
}

input DeleteSecurityFrameworkInput {
  id: ID!
}

type DeleteSecurityFrameworkPayload {
  _stub: String!
}

input DeleteSecurityScanInput {
  id: ID!
}

type DeleteSecurityScanPayload {
  _stub: String!
}

input DeleteServiceAccountInput {
  id: ID!
}

type DeleteServiceAccountPayload {
  _stub: String!
}

input DeleteUserInput {
  id: ID!
}

type DeleteUserPayload {
  _stub: String!
}

type Deployment {
  childDeployments(after: String, filterBy: DeploymentFilters, first: Int): DeploymentConnection!
  criticalSystemHealthIssueCount: Int!
  highSystemHealthIssueCount: Int!
  id: ID!
  informationalSystemHealthIssueCount: Int!
  lastSeenAt: DateTime
  lowSystemHealthIssueCount: Int!
  mediumSystemHealthIssueCount: Int!
  modules: [DeploymentModule!]!
  name: String!
  object: DeploymentObject!
  status: DeploymentStatus!
  type: DeploymentType!
}

type DeploymentConnection {
  edges: [DeploymentEdge!]
  nodes: [Deployment!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentEdge {
  cursor: String!
  node: Deployment!
}

input DeploymentFilters {
  id: [String!]
  search: String
  status: [DeploymentStatus!]
  type: [DeploymentType!]
  cloudProvider: [CloudProvider!]
  modules: [DeploymentModule!]
  excludeModules: [DeploymentModule!]
  sourceIds: [String!]
  parentDeploymentIds: [String!]
  onlyTopLevelDeployments: Boolean
}

enum DeploymentModel {
  CLOUD_SERVICE
  CLOUD_PLATFORM_SERVICE
  SERVER_APPLICATION
  CLIENT_APPLICATION
  CODE_LIBRARY
  CODE
  VIRTUAL_APPLIANCE
}

enum DeploymentModule {
  CLOUD_SCANNER
  EVENT_SCANNER
  DISK_SCANNER
  KEY_VAULT_SCANNER
  AZURE_ACTIVE_DIRECTORY_SCANNER
  ADMISSION_CONTROLLER
  OUTPOST_CLUSTER
}

union DeploymentObject = Connector | AdmissionController | Outpost

union DeploymentSource = CloudAccount | KubernetesCluster | ContainerRegistry

type DeploymentSourceConnection {
  edges: [DeploymentSourceEdge!]
  nodes: [DeploymentSource!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentSourceEdge {
  cursor: String!
  node: DeploymentSource!
}

input DeploymentSourceFilters {
  id: [String!]
  search: String
}

enum DeploymentStatus {
  INITIALIZING
  DISABLED
  ENABLED
}

enum DeploymentType {
  CLOUD_CONNECTOR
  KUBERNETES_CONNECTOR
  REGISTRY_CONNECTOR
  ADMISSION_CONTROLLER
  SENSOR
  OUTPOST
}

type DigitalTrustDashboardSettings {
  brandColor: String
  brandLogo: String
  enabled: Boolean!
}

type DirectoryUser implements Node {
  email: String!
  id: ID!
  name: String
}

type DirectoryUserConnection {
  edges: [DirectoryUserEdge!]
  nodes: [DirectoryUser!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DirectoryUserEdge {
  cursor: String!
  node: DirectoryUser!
}

type DisassociateServiceTicketPayload {
  _stub: String
}

type DiskScanApplicationVulnerability {
  path: String
  pathType: DiskScanApplicationVulnerabilityPathType
  version: String!
  vulnerability: DiskScanVulnerability!
}

enum DiskScanApplicationVulnerabilityPathType {
  FILE
  REGISTRY
}

type DiskScanSecret {
  contains: [DiskScanSecretData!]!
  description: String!
  details: DiskScanSecretDetails
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  lineNumber: Int
  offset: Int!
  path: String!
  snippet: String
  type: DiskScanSecretType!
}

type DiskScanSecretData {
  name: String!
  type: DiskScanSecretType!
}

union DiskScanSecretDetails = DiskScanSecretDetailsCloudKey | DiskScanSecretDetailsGitCredential | DiskScanSecretDetailsDBConnectionString | DiskScanSecretDetailsPrivateKey | DiskScanSecretDetailsPassword

type DiskScanSecretDetailsCloudKey {
  isLongTerm: Boolean
  keyType: Int
  providerUniqueID: String
}

type DiskScanSecretDetailsDBConnectionString {
  connectionString: String
  database: String
  user: String
}

type DiskScanSecretDetailsGitCredential {
  url: String
  user: String
}

type DiskScanSecretDetailsPassword {
  isComplex: Boolean
  length: Int
}

type DiskScanSecretDetailsPrivateKey {
  algorithm: Int
  bits: Int
}

enum DiskScanSecretType {
  CLOUD_KEY
  GIT_CREDENTIAL
  DB_CONNECTION_STRING
  PRIVATE_KEY
  PASSWORD
}

type DiskScanVulnerability {
  fixedVersion: String
  name: String!
  severity: DiskScanVulnerabilitySeverity!
  source: String!
}

enum DiskScanVulnerabilitySeverity {
  INFORMATIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

input DuplicateHostConfigurationRuleInput {
  name: String!
  ruleID: String!
}

type DuplicateHostConfigurationRulePayload {
  rule: HostConfigurationRule
}

input DuplicateSecurityFrameworkInput {
  id: ID!
  name: String!
}

type DuplicateSecurityFrameworkPayload {
  framework: SecurityFramework
}

input DurationFilter {
  amount: Int
  unit: DurationFilterValueUnit
}

enum DurationFilterValueUnit {
  DurationFilterValueUnitInvalid
  DurationFilterValueUnitHours
  DurationFilterValueUnitDays
  DurationFilterValueUnitWeeks
  DurationFilterValueUnitMonths
}

input ECRRoleConfig {
  roleARN: String!
}

type EmailActionTemplateParams {
  attachEvidenceCSV: Boolean
  cc: [String!]
  note: String
  to: [String!]!
}

input EmailActionTemplateParamsInput {
  note: String
  to: [String!]!
  cc: [String!]
  attachEvidenceCSV: Boolean
}

type EmailAutomationActionParams {
  attachEvidenceCSV: Boolean
  cc: [String!]
  note: String
  to: [String!]!
}

type EmailTarget {
  to: [String!]!
}

input EmailTargetParams {
  to: [String!]!
}

input EntityScanParamsInput {
  externalId: String!
  region: String
  subscriptionId: String
}

enum Environment {
  PRODUCTION
  STAGING
  DEVELOPMENT
  TESTING
  OTHER
}

type ErrorBadUserInput {
  invalidArgs: [ErrorContextInvalidArg!]!
}

enum ErrorCode {
  UNAUTHENTICATED
  UNAUTHORIZED
  BAD_USER_INPUT
  INTERNAL
  RATE_LIMIT_EXCEEDED
  FORBIDDEN_IP
  NOT_FOUND
}

type ErrorContextInvalidArg {
  code: String!
  message: String!
  path: String!
}

type ErrorUnauthorizedAction {
  effectiveScopes: [String!]!
  requiredScopes: [String!]!
}

type ExcessiveAccessFindingConfigurationInformation {
  content: String!
  policyName: String!
}

enum ExportFormats {
  CSV
  JSON
}

type ExternalExposureScannerSettings {
  isEnabled: Boolean!
  projectAllowlist: [Project!]
  projectBlocklist: [Project!]
  scanIntervalDays: Int
}

type ExtraInfo {
  clientName: String
  clientVersion: String
  tags: [CICDScanTag!]
}

type FileIntegrityMonitoringExclusion {
  createdBy: User!
  fileNames: FileIntegrityMonitoringStringFilter
  filePaths: FileIntegrityMonitoringStringFilter
  id: ID!
  name: String!
  resourceNames: FileIntegrityMonitoringStringFilter
  resources: [GraphEntity!]
  tags: FileIntegrityMonitoringTagsFilter
}

type FileIntegrityMonitoringExclusionConnection {
  edges: [FileIntegrityMonitoringExclusionEdge!]
  nodes: [FileIntegrityMonitoringExclusion!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type FileIntegrityMonitoringExclusionEdge {
  cursor: String!
  node: FileIntegrityMonitoringExclusion!
}

type FileIntegrityMonitoringSettings {
  enabled: Boolean!
}

type FileIntegrityMonitoringStringFilter {
  contains: [String!]
  doesNotContain: [String!]
  doesNotEndWith: [String!]
  doesNotStartWith: [String!]
  endsWith: [String!]
  equals: [String!]
  notEquals: [String!]
  startsWith: [String!]
}

input FileIntegrityMonitoringStringFilterInput {
  equals: [String!]
  notEquals: [String!]
  startsWith: [String!]
  doesNotStartWith: [String!]
  endsWith: [String!]
  doesNotEndWith: [String!]
  contains: [String!]
  doesNotContain: [String!]
}

type FileIntegrityMonitoringTagKeyValue {
  key: String
  value: String
}

input FileIntegrityMonitoringTagKeyValueInput {
  key: String
  value: String
}

type FileIntegrityMonitoringTagsFilter {
  containsAll: [FileIntegrityMonitoringTagKeyValue!]
  containsAny: [FileIntegrityMonitoringTagKeyValue!]
  doesNotContainAll: [FileIntegrityMonitoringTagKeyValue!]
  doesNotContainAny: [FileIntegrityMonitoringTagKeyValue!]
}

input FileIntegrityMonitoringTagsFilterInput {
  containsAll: [FileIntegrityMonitoringTagKeyValueInput!]
  containsAny: [FileIntegrityMonitoringTagKeyValueInput!]
  doesNotContainAll: [FileIntegrityMonitoringTagKeyValueInput!]
  doesNotContainAny: [FileIntegrityMonitoringTagKeyValueInput!]
}

type FileUpload implements Node {
  createdAt: DateTime!
  createdBy: UserOrConnector!
  id: ID!
  method: FileUploadMethod!
  name: String!
  url: String!
}

enum FileUploadMethod {
  PORTAL
  API
}

input FinalizeCICDScanInput {
  token: String!
  scanPolicies: [String!]
  tags: [CICDScanTagInput!]
}

enum FindingCommonResolutionReason {
  OBJECT_DELETED
  FINDING_FIXED
  FALSE_POSITIVE
  EXCEPTION
  WONT_FIX
}

enum FindingCommonStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  REJECTED
}

type FindingCommonStatusNote {
  id: ID!
  text: String!
}

enum FindingResolutionReason {
  OBJECT_DELETED
  FINDING_FIXED
  FALSE_POSITIVE
  EXCEPTION
  WONT_FIX
}

enum FindingSeverity {
  INFORMATIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum FindingStatus {
  UNRESOLVED
  RESOLVED
  PASSED
  IGNORED
}

type GcpPubSubActionTemplateParams {
  body: String!
}

input GcpPubSubActionTemplateParamsInput {
  body: String!
}

enum GcpPubSubIntegrationAccessMethodType {
  CONNECTOR_CREDENTIALS
  SERVICE_ACCOUNT_KEY
}

type GcpPubSubIntegrationParams {
  accessConnector: Connector
  accessMethod: GcpPubSubIntegrationAccessMethodType!
  projectId: String!
  serviceAccountKey: JSON
  topicId: String!
}

type GEAADServicePrincipalMetadata {
  appId: String
  appOwnerTenantId: String
  objectId: String
  publisherName: String
  signInAudience: String
  vertexId: ID!
}

type GEAccessKey {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  active: Boolean
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  credentialId: String
  credentialType: GECredentialType
  danglingDomain: Boolean
  everUsed: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  kubernetes: GEKubernetesIAMExtraData
  lastUsedAt: DateTime
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  rotatedAt: DateTime
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  userDirectory: String
  validAfter: DateTime
  validBefore: DateTime
  vertexId: ID!
  wizMockResource: Boolean
}

type GEAccessRole {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  description: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPartialAnalysis: Boolean
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
}

type GEAccessRoleBinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsConditions: GEAccessRoleBindingAWSConditions
  cloudPlatform: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  gcpCondition: GEGCPAccessRoleCondition
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPartialAnalysis: Boolean
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
}

type GEAccessRoleBindingAWSCondition {
  key: String
  operator: String
  rawPolicyExternalId: String
  statementId: String
  type: GEType
  values: [String!]
  vertexId: ID!
}

type GEAccessRoleBindingAWSConditions {
  conditions: [GEAccessRoleBindingAWSCondition!]
  vertexId: ID!
}

type GEAccessRolePermission {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  accessTypes: [GEAccessType!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  description: String
  documentation: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
}

enum GEAccessType {
  READ
  WRITE
  MANAGE
  HIGH_PRIVILEGE
  ADMIN
  DATA
  LIST
  IMPERSONATE
}

enum GEAddressType {
  IPV4
  IPV6
}

type GEAffinity {
  nodeAffinity: GENodeAffinity
  podAffinity: GEPodAffinity
  podAntiAffinity: GEPodAntiAffinity
  vertexId: ID!
}

type GEAllowedCSIDriver {
  name: String
  vertexId: ID!
}

type GEAllowedFlexVolume {
  driver: String
  vertexId: ID!
}

type GEAllowedHostPath {
  pathPrefix: String
  readOnly: Boolean
  vertexId: ID!
}

union GEAny = GEAPIGateway | GEAccessKey | GEAccessRole | GEAccessRoleBinding | GEAccessRolePermission | GEApplication | GEAuthenticationConfiguration | GEAuthenticationPolicy | GEBackendBucket | GEBackupService | GEBranchPackage | GEBucket | GECdn | GECICDService | GECallCenterService | GECertificate | GECloudLogConfiguration | GECloudOrganization | GEComputeInstanceGroup | GEConfigMap | GEConfigurationFinding | GEConfigurationRule | GEConfigurationScan | GEContainer | GEContainerGroup | GEContainerImage | GEContainerRegistry | GEContainerRepository | GEContainerService | GEControllerRevision | GEDBServer | GEDNSRecord | GEDNSZone | GEDaemonSet | GEDataFinding | GEDataInventory | GEDataSchema | GEDataStore | GEDataWorkflow | GEDataWorkload | GEDatabase | GEDeployment | GEDomain | GEEmailService | GEEncryptionKey | GEEndpoint | GEExcessiveAccessFinding | GEFileDescriptor | GEFileDescriptorFinding | GEFileSystemService | GEFirewall | GEGateway | GEGovernancePolicy | GEGovernancePolicyGroup | GEGroup | GEHostConfigurationFinding | GEHostConfigurationRule | GEHostedApplication | GEHostedTechnology | GEIACDeclarationInstance | GEIACResourceDeclaration | GEIACStateInstance | GEIAMBinding | GEIPRange | GEIdentityProvider | GEKubernetesCluster | GEKubernetesCronJob | GEKubernetesIngress | GEKubernetesIngressController | GEKubernetesJob | GEKubernetesNetworkPolicy | GEKubernetesNode | GEKubernetesPersistentVolume | GEKubernetesPersistentVolumeClaim | GEKubernetesPodSecurityPolicy | GEKubernetesService | GEKubernetesStorageClass | GEKubernetesVolume | GELastLogin | GELateralMovementFinding | GELoadBalancer | GELocalUser | GEMalware | GEMalwareInstance | GEManagedCertificate | GEManagementService | GEMapReduceCluster | GEMessagingService | GEMonitorAlert | GENamespace | GENat | GENetworkAddress | GENetworkAppliance | GENetworkInterface | GENetworkRoutingRule | GENetworkSecurityRule | GEPackage | GEPeering | GEPod | GEPortRange | GEPredefinedGroup | GEPrivateEndpoint | GEPrivateLink | GEProject | GEProductKubernetesCluster | GEProductOrganization | GEProxy | GEProxyRule | GERawAccessPolicy | GERegion | GERegisteredDomain | GEReplicaSet | GERepository | GERepositoryBranch | GERepositoryTag | GEResourceGroup | GERouteTable | GESearchIndex | GESecret | GESecretContainer | GESecretData | GESecretInstance | GESecurityEventFinding | GESecurityToolFinding | GESecurityToolFindingType | GESecurityToolScan | GEServerless | GEServerlessPackage | GEServiceAccount | GEServiceConfiguration | GEServiceUsageTechnology | GESnapshot | GEStatefulSet | GEStorageAccount | GESubnet | GESubscription | GESwitch | GETechnology | GEUserAccount | GEVirtualDesktop | GEVirtualMachine | GEVirtualMachineImage | GEVirtualNetwork | GEVolume | GEVulnerability | GEWeakness | GEWebService

type GEAPIGateway {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wafEnabled: Boolean
  wizMockResource: Boolean
  zone: String
}

type GEApplication {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deploymentType: GEDeploymentType
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEAttachedVolume {
  devicePath: String
  name: String
  vertexId: ID!
}

enum GEAttackComplexity {
  LOW
  MEDIUM
  HIGH
}

enum GEAttackVector {
  ADJACENT_NETWORK
  LOCAL
  NETWORK
  PHYSICAL
}

type GEAuthenticationConfiguration {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  algorithm: String
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  clientTimeout: Int
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  keyHash: String
  maxPasswordAge: Int
  minPasswordAge: Int
  minPasswordLength: Int
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  owner: String
  passwordAuthentication: Boolean
  passwordComplexityEnabled: Boolean
  passwordHistoryLength: Int
  permitEmptyPasswords: Boolean
  permitRootLogin: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  reversiblePasswordEncryptionEnabled: Boolean
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  type: GEAuthenticationType
  username: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEAuthenticationPolicy {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
}

enum GEAuthenticationType {
  SSH
  SSH_PUBLIC_KEY
  ACCOUNT_CONFIG
}

type GEAWSElasticBlockStoreVolumeSource {
  fsType: String
  partition: Int
  readOnly: Boolean
  vertexId: ID!
  volumeID: String
}

type GEAzureDiskVolumeSource {
  cachingMode: String
  diskName: String
  diskURI: String
  fsType: String
  kind: String
  readOnly: Boolean
  vertexId: ID!
}

type GEAzureFilePersistentVolumeSource {
  readOnly: Boolean
  secretName: String
  secretNamespace: String
  shareName: String
  vertexId: ID!
}

type GEAzureFileShare {
  vertexId: ID!
}

type GEAzureFileVolumeSource {
  readOnly: Boolean
  secretName: String
  shareName: String
  vertexId: ID!
}

type GEBackendBucket {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEBackupService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  atRestEncryption: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEBranchPackage {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  path: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  repositoryBranchExternalId: String
  repositoryExternalId: String
  screenshotError: String
  vertexId: ID!
}

type GEBucket {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  alternativeRegions: [String!]
  azurePublicAccess: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  encrypted: Boolean
  encryptionInTransit: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPublic: Boolean
  loggingEnabled: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicExposure: GEPublicExposure
  publicIPRangesWithAccess: [String!]
  publicPermissions: [GEBucketAccessRole!]
  region: String
  regionType: GEBucketRegionType
  resourceGroupExternalId: String
  retentionPeriod: Int
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  uniformACL: Boolean
  updateDate: DateTime
  versioningEnabled: Boolean
  vertexId: ID!
  webHostingEnabled: Boolean
  webHostingHosts: [String!]
  wizMockResource: Boolean
  zone: String
}

enum GEBucketAccessRole {
  READ
  WRITE
  OWNER
}

enum GEBucketRegionType {
  SINGLE_REGION
  DUAL_REGION
  MULTI_REGION
}

enum GEBusinessImpact {
  LBI
  MBI
  HBI
}

type GECallCenterService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GECapabilities {
  add: [String!]
  drop: [String!]
  vertexId: ID!
}

type GECdn {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowedClientSslProtocols: [GESslProtocolVersion!]
  allowedOriginSslProtocols: [GESslProtocolVersion!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  allowsNonEncryptedClients: Boolean
  allowsNonEncryptedOrigins: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasEdgeFunctions: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  loggingEnabled: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  requiresClientAuthorization: Boolean
  requiresOriginAuthorization: Boolean
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wafEnabled: Boolean
  wizMockResource: Boolean
  zone: String
}

type GECephFSPersistentVolumeSource {
  monitors: [String!]
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: GESecretReference
  user: String
  vertexId: ID!
}

type GECephFSVolumeSource {
  monitors: [String!]
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: GELocalObjectReference
  user: String
  vertexId: ID!
}

type GECertificate {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  domainName: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  rotation: Boolean
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GECertificateType {
  IMPORTED
  ISSUED
  PRIVATE
}

type GECICDService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GECinderPersistentVolumeSource {
  fsType: String
  readOnly: Boolean
  secretRef: GESecretReference
  vertexId: ID!
  volumeID: String
}

type GECinderVolumeSource {
  fsType: String
  readOnly: Boolean
  secretRef: GELocalObjectReference
  vertexId: ID!
  volumeID: String
}

type GEClientIPConfig {
  timeoutSeconds: Int
  vertexId: ID!
}

enum GECloudEventOrigin {
  WIZ_SENSOR
  WIZ_ADMISSION_CONTROLLER
  WIZ_FILE_INTEGRITY_MONITORING
  AWS_GUARD_DUTY
  AWS_CLOUDTRAIL
  AZURE_DEFENDER_FOR_CLOUD
  AZURE_ACTIVITY_LOGS
  GCP_SECURITY_COMMAND_CENTER
  GCP_AUDIT_LOGS
  WIZ_AGENTLESS_FILE_INTEGRITY_MONITORING
}

enum GECloudKeyType {
  AWS_SECRET_ACCESS_KEY
  AWS_API_KEY
  GCP_SERVICE_ACCOUNT_KEY
  GCP_ACCESS_TOKEN
  GCP_API_KEY
  AZURE_CLIENT_SECRET
  GCP_REFRESH_TOKEN
  AZURE_ACCESS_TOKEN
  AZURE_REFRESH_TOKEN
  GCP_ID_TOKEN
  AWS_OIDC_TOKEN
  AWS_COGNITO_REFRESH_TOKEN
  AZURE_STORAGE_ACCOUNT_KEY
  AZURE_MESSAGING_SERVICE_KEY
}

type GECloudLogConfiguration {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  accessLogForTarget: Boolean
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  organizationScope: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  publicTarget: Boolean
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GECloudOrganization {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  governancePolicyAssignments: GEGovernancePolicyAssignments
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  path: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEComputeInstanceGroup {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  ecs: GEComputeInstanceGroupECSExtraData
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  matchedTags: JSON
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  replicaCount: Int
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEComputeInstanceGroupECSExtraData {
  clusterExternalId: String
  clusterName: String
  vertexId: ID!
}

enum GEConfidence {
  LOW
  MEDIUM
  HIGH
}

type GEConfigMap {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  binaryData: JSON
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  data: JSON
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  immutable: Boolean
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEConfigMapEnvSource {
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GEConfigMapKeySelector {
  key: String
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GEConfigMapNodeConfigSource {
  kubeletConfigKey: String
  name: String
  namespace: String
  resourceVersion: String
  uid: String
  vertexId: ID!
}

type GEConfigMapProjection {
  items: [GEKeyToPath!]
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GEConfigMapVolumeSource {
  defaultMode: Int
  items: [GEKeyToPath!]
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GEConfigurationFinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  auditSteps: String
  cloudPlatform: String
  configLink: String
  configPath: String
  configurationRuleName: String
  configurationRuleShortName: String
  containsContainerHosts: Boolean
  currentConfig: String
  customFindingDescription: String
  danglingDomain: Boolean
  detailed: GEConfigurationFindingDataExtraInfo
  expectedConfig: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasRemediationInstructions: Boolean
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  resolutionRecommendation: String
  resourceGroupExternalId: String
  screenshotError: String
  severity: GEConfigurationSeverity
  source: GESource
  status: GEConfigurationStatus
  vertexId: ID!
}

type GEConfigurationFindingDataExtraInfo {
  source: String
  statusCause: String
  type: String
  vertexId: ID!
}

type GEConfigurationRule {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  configLink: String
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  description: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  resolutionRecommendation: String
  screenshotError: String
  severity: GEConfigurationSeverity
  shortName: String
  source: GESource
  vertexId: ID!
}

type GEConfigurationScan {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  analysisDate: DateTime
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  source: GESource
  vertexId: ID!
}

type GEConfigurationScanInformation {
  assessmentErrorCount: Int
  complianceScore: Int
  date: DateTime
  failCount: Int
  notAssessedCount: Int
  passCount: Int
  totalCount: Int
  vertexId: ID!
}

enum GEConfigurationSeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum GEConfigurationStatus {
  FAIL
  PASS
  ASSESSMENT_ERROR
  NOT_ASSESSED
}

enum GEConnectorType {
  DISK_SCAN_INFO_CONNECTOR_TYPE_WIZ_OUTPOST
}

type GEContainer {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  args: [String!]
  boundPorts: [GEPort!]
  cloudPlatform: String
  cloudProviderURL: String
  command: [String!]
  containerClusterConnected: Boolean
  containerHostScanned: Boolean
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  ecs: GEContainerECSExtraData
  env: JSON
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  image: String
  imagePullPolicy: String
  isDefaultSecurityContext: Boolean
  kubernetes: GEKubernetesContainerExtraData
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resources: GEResourceRequirements
  screenshotError: String
  securityContext: GESecurityContext
  serverlessContainer: Boolean
  serviceAccountName: String
  status: String
  stdin: Boolean
  stdinOnce: Boolean
  subscriptionExternalId: String
  tags: JSON
  tty: Boolean
  vertexId: ID!
  wizMockResource: Boolean
  workingDir: String
  zone: String
}

type GEContainerECSExtraData {
  clusterExternalId: String
  clusterName: String
  envFileStorageExternalIds: [String!]
  vertexId: ID!
}

type GEContainerGroup {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  ecs: GEContainerGroupECSExtraData
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isDefaultSecurityContext: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  securityContext: GESecurityContext
  serviceAccountName: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEContainerGroupECSExtraData {
  clusterExternalId: String
  clusterName: String
  hostedOnFargate: Boolean
  vertexId: ID!
}

type GEContainerImage {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  builds: [GEContainerImageBuildInfo!]
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  digest: String
  encrypted: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  imageTags: [String!]
  kubernetes: GEContainerImageKubernetesExtraData
  lastUpdated: DateTime
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEContainerImageBuildInfo {
  authoredDate: DateTime
  buildAgent: String
  buildInfoUrl: String
  buildStartDate: DateTime
  buildUrl: String
  commit: String
  committedDate: DateTime
  pushedDate: DateTime
  vertexId: ID!
}

type GEContainerImageKubernetesExtraData {
  vertexId: ID!
}

type GEContainerPort {
  containerPort: Int
  hostIP: String
  hostPort: Int
  name: String
  protocol: String
  vertexId: ID!
}

type GEContainerRegistry {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isManaged: Boolean
  isPaaS: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEContainerRepository {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEContainerService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  ecs: GEContainerServiceECSExtraData
  edition: String
  encryptsSecrets: Boolean
  extendedSupport: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isLatestVersion: Boolean
  isManaged: Boolean
  isPaaS: Boolean
  isVersionEndOfLife: Boolean
  kind: String
  kubernetes: GEKubernetesContainerServiceExtraData
  latestVersion: String
  latestVersionReleaseDate: DateTime
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  release: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  version: String
  versionEndOfLifeDate: DateTime
  versionReleaseDate: DateTime
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEContainerServiceECSExtraData {
  vertexId: ID!
}

type GEControllerRevision {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  revision: Int
  screenshotError: String
  selfLink: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GECredential {
  active: Boolean
  credentialId: String
  credentialType: GECredentialType
  everUsed: Boolean
  lastUsedAt: DateTime
  rotatedAt: DateTime
  vertexId: ID!
}

enum GECredentialType {
  ACCESS_KEY
  PASSWORD
  CERTIFICATE
}

enum GECSESeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type GECSIPersistentVolumeSource {
  controllerExpandSecretRef: GESecretReference
  controllerPublishSecretRef: GESecretReference
  driver: String
  fsType: String
  nodePublishSecretRef: GESecretReference
  nodeStageSecretRef: GESecretReference
  readOnly: Boolean
  vertexId: ID!
  volumeAttributes: JSON
  volumeHandle: String
}

type GECSIVolumeSource {
  driver: String
  fsType: String
  nodePublishSecretRef: GELocalObjectReference
  readOnly: Boolean
  vertexId: ID!
  volumeAttributes: JSON
}

enum GECustomFileDetectionSeverityLevel {
  CUSTOM_FILE_DETECTION_SEVERITY_NO_THREAT
  CUSTOM_FILE_DETECTION_SEVERITY_INFO
  CUSTOM_FILE_DETECTION_SEVERITY_LOW
  CUSTOM_FILE_DETECTION_SEVERITY_MEDIUM
  CUSTOM_FILE_DETECTION_SEVERITY_HIGH
  CUSTOM_FILE_DETECTION_SEVERITY_CRITICAL
}

enum GECustomFileDetectionType {
  ADWARE
  BACKDOOR
  BROWSER
  DIALER
  DOWNLOADER
  EXPLOIT
  HACKTOOL
  INFOSTEALER
  KEYLOGGER
  MALWARE
  NETWORK
  PUA
  PACKED
  RANSOMWARE
  ROGUE
  ROOTKIT
  SPYWARE
  TROJAN
  VIRUS
  WORM
  CLEAN
}

type GECVE {
  isCandidate: Boolean
  number: Int
  vertexId: ID!
  year: Int
}

type GEDaemonEndpoint {
  Port: Int
  vertexId: ID!
}

type GEDaemonSet {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEDaemonSetSpec
  status: GEDaemonSetStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDaemonSetSpec {
  minReadySeconds: Int
  revisionHistoryLimit: Int
  selector: GELabelSelector
  template: GEPodTemplateSpec
  updateStrategy: GEDaemonSetUpdateStrategy
  vertexId: ID!
}

type GEDaemonSetStatus {
  collisionCount: Int
  currentNumberScheduled: Int
  desiredNumberScheduled: Int
  numberAvailable: Int
  numberMisscheduled: Int
  numberReady: Int
  numberUnavailable: Int
  observedGeneration: Int
  updatedNumberScheduled: Int
  vertexId: ID!
}

type GEDaemonSetUpdateStrategy {
  rollingUpdate: GERollingUpdateDaemonSet
  type: String
  vertexId: ID!
}

type GEDatabase {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEDataCategory {
  PII
  PHI
  FINANCIAL
  DIGITAL_IDENTITY
  OTHER
}

type GEDataFinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  dataCategory: GEDataCategory
  dataClassifierId: String
  dataFindingExamples: [GEDataFindingDataFindingExample!]
  dataPaths: [String!]
  exampleMatches: [String!]
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  percentWithContext: Int
  percentWithValidator: Int
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  totalMatchCount: Int
  uniqueMatchCount: Int
  vertexId: ID!
  withContext: Boolean
  withValidator: Boolean
}

type GEDataFindingDataFindingExample {
  key: String
  path: String
  row: Int
  rowNumber: Int
  value: String
  vertexId: ID!
}

type GEDataInventory {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  entries: [GEDataInventoryEntry!]
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPartial: Boolean
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  vertexId: ID!
}

type GEDataInventoryEntry {
  bytes: Int
  contentType: String
  items: Int
  vertexId: ID!
}

enum GEDataSampleProviderKind {
  DISK
  BUCKET
  SQL
  APPLICATION_ENDPOINT
  NO_SQL
}

type GEDataSchema {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  fieldNames: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  vertexId: ID!
}

type GEDataStore {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  approxItems: Int
  approxSizeBytes: Int
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  examplePaths: [String!]
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isStructured: Boolean
  kind: GEDataStoreKind
  lastModified: DateTime
  lastSampleDurationSec: Int
  lastSampleTime: DateTime
  lastScanDurationMs: Int
  lastScanStatusDetails: String
  lastScanTime: DateTime
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerKind: GEDataSampleProviderKind
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  sampledBytes: Int
  sampledContentTypes: [String!]
  sampledItems: Int
  sampledRows: Int
  scanStatus: GEDataStoreScanStatus
  schemaExternalIDs: [String!]
  screenshotError: String
  storePath: String
  totalBytes: Int
  totalItems: Int
  vertexId: ID!
}

enum GEDataStoreKind {
  FOLDER
  MY_SQL
  POSTGRES
  MSSQL
  BUCKET
}

enum GEDataStoreScanStatus {
  SUCCESS
  FAILED
}

enum GEDataType {
  SECRET_TYPE_PRIVATE_KEY
  SECRET_TYPE_PUBLIC_KEY
  SECRET_TYPE_PASSWORD
  SECRET_TYPE_CERTIFICATE
  SECRET_TYPE_CLOUD_KEY
  SECRET_TYPE_SSH_AUTHORIZED_KEY
  SECRET_TYPE_DB_CONNECTION_STRING
  SECRET_TYPE_GIT_CREDENTIAL
  SECRET_TYPE_PRESIGNED_URL
  SECRET_TYPE_SAAS_API_KEY
}

type GEDataWorkflow {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  encrypted: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDataWorkload {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  atRestEncryption: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inTransitEncryption: Boolean
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDBServer {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  atRestEncryption: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasBackups: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isManaged: Boolean
  isPaaS: Boolean
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  requiresAuth: Boolean
  requiresSSL: Boolean
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  version: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDeployment {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEDeploymentSpec
  status: GEDeploymentStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDeploymentSpec {
  minReadySeconds: Int
  paused: Boolean
  progressDeadlineSeconds: Int
  replicas: Int
  revisionHistoryLimit: Int
  selector: GELabelSelector
  strategy: GEDeploymentStrategy
  template: GEPodTemplateSpec
  vertexId: ID!
}

type GEDeploymentStatus {
  availableReplicas: Int
  collisionCount: Int
  observedGeneration: Int
  readyReplicas: Int
  replicas: Int
  unavailableReplicas: Int
  updatedReplicas: Int
  vertexId: ID!
}

type GEDeploymentStrategy {
  rollingUpdate: GERollingUpdateDeployment
  type: String
  vertexId: ID!
}

enum GEDeploymentType {
  CLONED_REPOSITORY
  CONTAINER_APPLICATION
  INSTALLED_ON_DISK
}

enum GEDetectionMethod {
  PACKAGE
  DEFAULT_PACKAGE
  LIBRARY
  CONFIG_FILE
  OPEN_PORT
  STARTUP_SERVICE
  CONFIGURATION
  CLONED_REPOSITORY
  OS
  ARTIFACTS_ON_DISK
  WINDOWS_REGISTRY
  INSTALLED_PROGRAM
  FILE_PATH
  WINDOWS_SERVICE
  INSTALLED_PROGRAM_BY_SERVICE
  HOSTED_DATABASE_SCAN
}

type GEDNSRecord {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  ttlSeconds: Int
  type: GEDNSRecordType
  values: [String!]
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEDNSRecordType {
  A
  AAAA
  CAA
  CNAME
  DNSKEY
  DS
  IPSECKEY
  MX
  NAPTR
  NS
  PTR
  SPF
  SRV
  SSHFP
  TLSA
  TXT
  ALIAS
  SOA
}

type GEDNSZone {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  dnsName: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPublic: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDomain {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEDownwardAPIProjection {
  items: [GEDownwardAPIVolumeFile!]
  vertexId: ID!
}

type GEDownwardAPIVolumeFile {
  fieldRef: GEObjectFieldSelector
  mode: Int
  path: String
  resourceFieldRef: GEResourceFieldSelector
  vertexId: ID!
}

type GEDownwardAPIVolumeSource {
  defaultMode: Int
  items: [GEDownwardAPIVolumeFile!]
  vertexId: ID!
}

type GEEmailService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEEmptyDirVolumeSource {
  medium: String
  sizeLimit: GEQuantity
  vertexId: ID!
}

type GEEncryptionKey {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  aliases: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  managementType: GEManagementType
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  pendingDeletion: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  rotation: Boolean
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEEndpoint {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  allPorts: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  dynamicScannerExtractedText: String
  dynamicScannerResponse: String
  dynamicScannerScreenshotUrl: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  host: String
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  path: String
  port: Int
  portEnd: Int
  portRange: Boolean
  portStart: Int
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  protocol: String
  protocols: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEEnvFromSource {
  configMapRef: GEConfigMapEnvSource
  prefix: String
  secretRef: GESecretEnvSource
  vertexId: ID!
}

enum GEEnvironment {
  DEVELOPMENT
  TESTING
  STAGING
  PRODUCTION
}

type GEEnvVar {
  name: String
  value: String
  valueFrom: GEEnvVarSource
  vertexId: ID!
}

type GEEnvVarSource {
  configMapKeyRef: GEConfigMapKeySelector
  fieldRef: GEObjectFieldSelector
  resourceFieldRef: GEResourceFieldSelector
  secretKeyRef: GESecretKeySelector
  vertexId: ID!
}

type GEEphemeralContainer {
  ephemeralContainerCommon: GEEphemeralContainerCommon
  targetContainerName: String
  vertexId: ID!
}

type GEEphemeralContainerCommon {
  args: [String!]
  command: [String!]
  env: [GEEnvVar!]
  envFrom: [GEEnvFromSource!]
  image: String
  imagePullPolicy: String
  lifecycle: GELifecycle
  livenessProbe: GEProbe
  name: String
  ports: [GEContainerPort!]
  readinessProbe: GEProbe
  resources: GEKubernetesResourceRequirements
  securityContext: GEKubernetesSecurityContext
  startupProbe: GEProbe
  stdin: Boolean
  stdinOnce: Boolean
  terminationMessagePath: String
  terminationMessagePolicy: String
  tty: Boolean
  vertexId: ID!
  volumeDevices: [GEVolumeDevice!]
  volumeMounts: [GEVolumeMount!]
  workingDir: String
}

type GEEphemeralVolumeSource {
  readOnly: Boolean
  vertexId: ID!
  volumeClaimTemplate: GEPersistentVolumeClaimTemplate
}

enum GEError {
  ACCESS_DENIED
  MESSAGE
}

type GEExcessiveAccessFinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  currentConfig: String! @deprecated(reason: "use currentPolicyConfiguration field instead")
  currentConfiguration: GEExcessiveAccessFindingConfigurationInformation
  currentPolicyConfiguration: ExcessiveAccessFindingConfigurationInformation
  danglingDomain: Boolean
  description: String
  documentation: String
  excessiveServices: [String!]
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  remediation: String
  remediationType: GEExcessiveAccessFindingRemediationType
  removedAdminPermissions: Boolean
  removedDataPermissions: Boolean
  removedHighPermissions: Boolean
  screenshotError: String
  severity: GEExcessiveAccessFindingSeverity
  source: GEExcessiveAccessFindingSource
  suggestedConfig: String! @deprecated(reason: "use suggestedPolicyConfiguration field instead")
  suggestedConfiguration: GEExcessiveAccessFindingConfigurationInformation
  suggestedPolicyConfiguration: ExcessiveAccessFindingConfigurationInformation
  suggestedPolicyConfigurationDiff: String
  unusedAdminPermissions: Boolean
  unusedDataPermissions: Boolean
  unusedHighPermissions: Boolean
  vertexId: ID!
}

type GEExcessiveAccessFindingConfigurationInformation {
  policyName: String
  vertexId: ID!
}

enum GEExcessiveAccessFindingRemediationType {
  DELETE_PRINCIPAL
  DETACH_POLICY
  REPLACE_POLICY
  RESTRICT_EXTERNAL_EXPOSURE
}

enum GEExcessiveAccessFindingSeverity {
  SEVERITY_LOW
  SEVERITY_MEDIUM
  SEVERITY_HIGH
  SEVERITY_CRITICAL
}

enum GEExcessiveAccessFindingSource {
  CLOUD_EVENTS
  GCP_RECOMMENDER
  AWS_ACCESS_ADVISOR
  WIZ_INSIGHT
}

type GEExecAction {
  command: [String!]
  vertexId: ID!
}

type GEFCVolumeSource {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String!]
  vertexId: ID!
  wwids: [String!]
}

type GEFileDescriptor {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  findingType: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  severity: GEThreatSeverityLevel
  severityLevel: GECustomFileDetectionSeverityLevel
  sha1: String
  source: String
  type: GECustomFileDetectionType
  vertexId: ID!
}

type GEFileDescriptorFinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  displayPath: String
  externalId: String
  externalOwners: [String!]
  findingType: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  modificationTime: DateTime
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  path: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  severity: GEThreatSeverityLevel
  severityLevel: GECustomFileDetectionSeverityLevel
  sha1: String
  size: Int
  source: String
  type: GECustomFileDetectionType
  vertexId: ID!
}

enum GEFileReputationStatus {
  UNKNOWN
  KNOWN
  SUSPICIOUS
  MALICIOUS
}

type GEFileSystemService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  atRestEncryption: Boolean
  azureFileShare: GEAzureFileShare
  capacityInGB: Int
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  fileShareName: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inTransitEncryption: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEFirewall {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasDeployedInstances: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isDefault: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  type: GEFirewallType
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEFirewallType {
  AZURE_NETWORK_SECURITY_GROUP
  AWS_SECURITY_GROUP
  AWS_NETWORK_ACL
  GCP_FIREWALL_RULE
  AWS_SHIELD
  AWS_WEB_ACL
  AZURE_APPLICATION_GATEWAY_WAF
  AZURE_FRONT_DOOR_WAF
  AZURE_CDN_WAF
  OCI_SECURITY_LIST
  OCI_NETWORK_SECURITY_GROUP
  GCP_CLOUD_ARMOR_WAF
  ALIBABA_SECURITY_GROUP
  GCP_CLOUD_ARMOR_EDGE_WAF
}

type GEFlexPersistentVolumeSource {
  driver: String
  fsType: String
  options: JSON
  readOnly: Boolean
  secretRef: GESecretReference
  vertexId: ID!
}

type GEFlexVolumeSource {
  driver: String
  fsType: String
  options: JSON
  readOnly: Boolean
  secretRef: GELocalObjectReference
  vertexId: ID!
}

type GEFlockerVolumeSource {
  datasetName: String
  datasetUUID: String
  vertexId: ID!
}

type GEFSGroupStrategyOptions {
  ranges: [GEIDRange!]
  rule: String
  vertexId: ID!
}

type GEGateway {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  connectedToOnPrem: Boolean
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  gatewayType: GENetworkRoutingGatewayType
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasRouteTable: Boolean
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEGCEPersistentDiskVolumeSource {
  fsType: String
  partition: Int
  pdName: String
  readOnly: Boolean
  vertexId: ID!
}

type GEGCPAccessRoleCondition {
  conditionDescription: String
  conditionExpression: String
  conditionTitle: String
  vertexId: ID!
}

type GEGlusterfsPersistentVolumeSource {
  endpoints: String
  endpointsNamespace: String
  path: String
  readOnly: Boolean
  vertexId: ID!
}

type GEGlusterfsVolumeSource {
  endpoints: String
  path: String
  readOnly: Boolean
  vertexId: ID!
}

type GEGovernancePolicy {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEGovernancePolicyAssignments {
  vertexId: ID!
}

type GEGovernancePolicyGroup {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEGroup {
  aadOnPremisesDomainName: String
  aadOnPremisesSamAccountName: String
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  partialMemberVisibility: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  userDirectory: String
  vertexId: ID!
  wizMockResource: Boolean
}

type GEHandler {
  exec: GEExecAction
  httpGet: GEHTTPGetAction
  tcpSocket: GETCPSocketAction
  vertexId: ID!
}

type GEHostAlias {
  hostnames: [String!]
  ip: String
  vertexId: ID!
}

type GEHostConfigurationFinding {
  assessmentError: GEError
  assessmentErrorMessage: String
  description: String
  externalId: String
  name: String
  ruleName: String
  ruleShortName: String
  securityFrameworkSubCategoryIds: [String!]
  severity: GESeverity
  status: GEStatus
  targetObjectCloudPlatform: String
  targetObjectName: String
  targetObjectNativeType: String
  targetObjectRegion: String
  targetObjectStatus: String
  vertexId: ID!
}

type GEHostConfigurationRule {
  description: String
  externalId: String
  name: String
  severity: GESeverity
  shortName: String
  vertexId: ID!
}

type GEHostedApplication {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deployment: GEHostedApplicationApplicationFiles
  detectionMethod: GEDetectionMethod
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  path: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  repo: GEHostedApplicationClonedRepo
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  version: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEHostedApplicationApplicationFiles {
  builds: [GEHostedApplicationBuildInfo!]
  commit: String
  files: [String!]
  vertexId: ID!
}

type GEHostedApplicationBuildInfo {
  authoredDate: DateTime
  buildAgent: String
  buildInfoUrl: String
  buildStartDate: DateTime
  buildUrl: String
  commit: String
  committedDate: DateTime
  pushedDate: DateTime
  vertexId: ID!
}

type GEHostedApplicationClonedRepo {
  branchName: String
  commit: String
  remoteUrl: String
  vertexId: ID!
}

type GEHostedTechnology {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  configScan: GEConfigurationScanInformation
  containsContainerHosts: Boolean
  cpe: String
  creationDate: DateTime
  danglingDomain: Boolean
  detectedByClonedRepositories: [String!]
  detectedByConfigFilePaths: [String!]
  detectedByDefaultPackageNames: [String!]
  detectedByFilePaths: [String!]
  detectedByHostedDatabaseScan: [String!]
  detectedByInstalledProgramNames: [String!]
  detectedByLibraryNames: [String!]
  detectedByOpenPortNumbers: [Int!]
  detectedByPackageNames: [String!]
  detectedByStartupServiceNames: [String!]
  detectedByWindowsServiceNames: [String!]
  detectionMethods: [GEDetectionMethod!]
  domainDetails: GEHostedTechnologyDomainDetails
  edition: String
  extendedSupport: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  hostname: String
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  installedPackages: [String!]
  installedPrograms: [String!]
  isAppliance: Boolean
  isEtcPasswd644: Boolean
  isLatestVersion: Boolean
  isVersionEndOfLife: Boolean
  lastBootTime: DateTime
  latestVersion: String
  latestVersionReleaseDate: DateTime
  listeningPortsDetails: GEHostedTechnologyListeningPortsDetails
  name: String
  nativeType: String
  needsRestart: Boolean
  needsRestartDetails: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  release: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  techId: String
  techName: String
  version: String
  versionEndOfLifeDate: DateTime
  versionReleaseDate: DateTime
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEHostedTechnologyDomainDetails {
  domainName: String
  isDomainJoined: Boolean
  vertexId: ID!
}

type GEHostedTechnologyListeningPortsDetails {
  isListeningOnPort: Boolean
  listeningPorts: [String!]
  vertexId: ID!
}

type GEHostPathVolumeSource {
  path: String
  type: String
  vertexId: ID!
}

type GEHostPortRange {
  max: Int
  min: Int
  vertexId: ID!
}

type GEHTTPGetAction {
  host: String
  httpHeaders: [GEHTTPHeader!]
  path: String
  port: GEIntOrString
  scheme: String
  vertexId: ID!
}

type GEHTTPHeader {
  name: String
  value: String
  vertexId: ID!
}

type GEHTTPIngressPath {
  backend: GEIngressBackend
  path: String
  pathType: String
  vertexId: ID!
}

type GEHTTPIngressRuleValue {
  paths: [GEHTTPIngressPath!]
  vertexId: ID!
}

type GEIACDeclarationInstance {
  cloudPlatform: String
  cloudProviderURL: String
  externalId: String
  location: String
  modificationDate: DateTime
  name: String
  nativeType: String
  providerUniqueId: String
  region: String
  source: String
  subscriptionExternalId: String
  tags: JSON
  type: String
  vertexId: ID!
}

type GEIACResourceDeclaration {
  externalId: String
  location: String
  modificationDate: DateTime
  name: String
  nativeType: String
  subscriptionExternalId: String
  tags: JSON
  type: String
  vertexId: ID!
}

type GEIACStateInstance {
  externalId: String
  location: String
  modificationDate: DateTime
  name: String
  nativeType: String
  source: String
  subscriptionExternalId: String
  tags: JSON
  type: String
  vertexId: ID!
}

type GEIAMBinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  accessTypes: [GEAccessType!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isCrossSubscriptionAccess: Boolean
  isOutsideOrganizationAccess: Boolean
  isPublicAccess: Boolean
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
}

type GEIdentityProvider {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  kubernetes: GEKubernetesIAMExtraData
  lastModified: DateTime
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  url: String
  userDirectory: String
  validUntil: DateTime
  vertexId: ID!
  wizMockResource: Boolean
}

type GEIDRange {
  max: Int
  min: Int
  vertexId: ID!
}

enum GEImpact {
  NONE
  LOW
  MEDIUM
  HIGH
  PARTIAL
  COMPLETE
}

type GEIngressBackend {
  resource: GETypedLocalObjectReference
  serviceName: String
  servicePort: GEIntOrString
  vertexId: ID!
}

type GEIngressRule {
  host: String
  http: GEHTTPIngressRuleValue
  vertexId: ID!
}

type GEIngressTLS {
  hosts: [String!]
  secretName: String
  vertexId: ID!
}

type GEIntOrString {
  intVal: Int
  strVal: String
  type: Int
  vertexId: ID!
}

type GEIPBlock {
  cidr: String
  except: [String!]
  vertexId: ID!
}

type GEIPRange {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  addressType: GEAddressType
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cidr: String
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  endAddr: String
  endInt: Int
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  startAddr: String
  startInt: Int
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEISCSIPersistentVolumeSource {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String
  iscsiInterface: String
  lun: Int
  portals: [String!]
  readOnly: Boolean
  secretRef: GESecretReference
  targetPortal: String
  vertexId: ID!
}

type GEISCSIVolumeSource {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String
  iscsiInterface: String
  lun: Int
  portals: [String!]
  readOnly: Boolean
  secretRef: GELocalObjectReference
  targetPortal: String
  vertexId: ID!
}

type GEJobSpec {
  activeDeadlineSeconds: Int
  backoffLimit: Int
  completions: Int
  manualSelector: Boolean
  parallelism: Int
  selector: GELabelSelector
  template: GEPodTemplateSpec
  ttlSecondsAfterFinished: Int
  vertexId: ID!
}

type GEJobTemplateSpec {
  metadata: GEObjectMeta
  spec: GEJobSpec
  vertexId: ID!
}

type GEKeyToPath {
  key: String
  mode: Int
  path: String
  vertexId: ID!
}

type GEKubernetesBaseExtraData {
  clusterExternalId: String
  kubernetesFlavor: String
  vertexId: ID!
}

type GEKubernetesCluster {
  AADEnableAzureRBAC: Boolean
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  apiServerEndpoint: String
  authProvider: String
  autopilot: Boolean
  certificateAuthority: GETLSConfigCertificateAuthority
  cloudPlatform: String
  cloudProviderURL: String
  containerClusterConnected: Boolean
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  edition: String
  encryptsSecrets: Boolean
  extendedSupport: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isLatestVersion: Boolean
  isManaged: Boolean
  isPaaS: Boolean
  isVersionEndOfLife: Boolean
  kubernetes: GEKubernetesBaseExtraData
  latestVersion: String
  latestVersionReleaseDate: DateTime
  LegacyAADIntegration: Boolean
  ManagedAADIntegration: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  release: String
  resourceGroupExternalId: String
  screenshotError: String
  sniServerName: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  version: String
  versionEndOfLifeDate: DateTime
  versionReleaseDate: DateTime
  vertexId: ID!
  wizMockResource: Boolean
  workloadIdentityEnabled: Boolean
  zone: String
}

type GEKubernetesContainer {
  args: [String!]
  command: [String!]
  env: [GEEnvVar!]
  envFrom: [GEEnvFromSource!]
  image: String
  imagePullPolicy: String
  lifecycle: GELifecycle
  livenessProbe: GEProbe
  name: String
  ports: [GEContainerPort!]
  readinessProbe: GEProbe
  resources: GEKubernetesResourceRequirements
  securityContext: GEKubernetesSecurityContext
  startupProbe: GEProbe
  stdin: Boolean
  stdinOnce: Boolean
  terminationMessagePath: String
  terminationMessagePolicy: String
  tty: Boolean
  vertexId: ID!
  volumeDevices: [GEVolumeDevice!]
  volumeMounts: [GEVolumeMount!]
  workingDir: String
}

type GEKubernetesContainerExtraData {
  clusterExternalId: String
  envFrom: [GEEnvFromSource!]
  ephemeralTargetContainerName: String
  kubernetesFlavor: String
  lifecycle: GELifecycle
  livenessProbe: GEProbe
  namespaceExternalId: String
  nodeExternalId: String
  podExternalId: String
  readinessProbe: GEProbe
  startupProbe: GEProbe
  terminationMessagePath: String
  terminationMessagePolicy: String
  vertexId: ID!
  volumeDevices: [GEVolumeDevice!]
  volumeMounts: [GEVolumeMount!]
}

type GEKubernetesContainerImage {
  names: [String!]
  sizeBytes: Int
  vertexId: ID!
}

type GEKubernetesContainerServiceExtraData {
  clusterExternalId: String
  kubernetesFlavor: String
  vertexId: ID!
}

type GEKubernetesCronJob {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesCronJobSpec
  status: GEKubernetesCronJobStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesCronJobSpec {
  concurrencyPolicy: String
  failedJobsHistoryLimit: Int
  jobTemplate: GEJobTemplateSpec
  schedule: String
  startingDeadlineSeconds: Int
  successfulJobsHistoryLimit: Int
  suspend: Boolean
  vertexId: ID!
}

type GEKubernetesCronJobStatus {
  active: [GEObjectReference!]
  lastScheduleTime: GETime
  vertexId: ID!
}

type GEKubernetesIAMExtraData {
  annotations: JSON
  clusterExternalId: String
  kubernetesFlavor: String
  vertexId: ID!
}

type GEKubernetesIngress {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesIngressSpec
  status: GEKubernetesIngressStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesIngressController {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesIngressSpec {
  backend: GEIngressBackend
  ingressClassName: String
  rules: [GEIngressRule!]
  tls: [GEIngressTLS!]
  vertexId: ID!
}

type GEKubernetesIngressStatus {
  loadBalancer: GELoadBalancerStatus
  vertexId: ID!
}

type GEKubernetesJob {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesJobSpec
  status: GEKubernetesJobStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesJobSpec {
  activeDeadlineSeconds: Int
  backoffLimit: Int
  completions: Int
  manualSelector: Boolean
  parallelism: Int
  selector: GELabelSelector
  template: GEPodTemplateSpec
  ttlSecondsAfterFinished: Int
  vertexId: ID!
}

type GEKubernetesJobStatus {
  active: Int
  completionTime: GETime
  failed: Int
  startTime: GETime
  succeeded: Int
  vertexId: ID!
}

type GEKubernetesNamespaceExtraData {
  annotations: JSON
  clusterExternalId: String
  kubernetesFlavor: String
  vertexId: ID!
}

type GEKubernetesNetworkPolicy {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesNetworkPolicySpec
  status: String
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesNetworkPolicySpec {
  egress: [GENetworkPolicyEgressRule!]
  ingress: [GENetworkPolicyIngressRule!]
  podSelector: GELabelSelector
  policyTypes: [String!]
  vertexId: ID!
}

type GEKubernetesNode {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  awsExtraData: GEKubernetesNodeAWSExtraData
  azureExtraData: GEKubernetesNodeAzureExtraData
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  gcpExtraDAta: GEKubernetesNodeGCPExtraData
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesNodeSpec
  status: GEKubernetesNodeStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesNodeAWSExtraData {
  hostedOnFargate: Boolean
  vertexId: ID!
}

type GEKubernetesNodeAzureExtraData {
  hostedOnACI: Boolean
  vertexId: ID!
}

type GEKubernetesNodeGCPExtraData {
  hostedOnAutopilot: Boolean
  vertexId: ID!
}

type GEKubernetesNodeSpec {
  configSource: GENodeConfigSource
  podCIDR: String
  podCIDRs: [String!]
  providerID: String
  taints: [GETaint!]
  unschedulable: Boolean
  vertexId: ID!
}

type GEKubernetesNodeStatus {
  addresses: [GENodeAddress!]
  capacity: JSON
  config: GENodeConfigStatus
  daemonEndpoints: GENodeDaemonEndpoints
  images: [GEKubernetesContainerImage!]
  nodeInfo: GENodeSystemInfo
  phase: String
  vertexId: ID!
  volumesAttached: [GEAttachedVolume!]
  volumesInUse: [String!]
}

type GEKubernetesPersistentVolume {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesPersistentVolumeSpec
  status: GEKubernetesPersistentVolumeStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesPersistentVolumeClaim {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesPersistentVolumeClaimSpec
  status: GEKubernetesPersistentVolumeClaimStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesPersistentVolumeClaimSpec {
  accessModes: [String!]
  dataSource: GETypedLocalObjectReference
  resources: GEKubernetesResourceRequirements
  selector: GELabelSelector
  storageClassName: String
  vertexId: ID!
  volumeMode: String
  volumeName: String
}

type GEKubernetesPersistentVolumeClaimStatus {
  capacity: JSON
  phase: String
  vertexId: ID!
}

type GEKubernetesPersistentVolumeSpec {
  accessModes: [String!]
  awsElasticBlockStore: GEAWSElasticBlockStoreVolumeSource
  azureDisk: GEAzureDiskVolumeSource
  azureFile: GEAzureFilePersistentVolumeSource
  capacity: JSON
  cephfs: GECephFSPersistentVolumeSource
  cinder: GECinderPersistentVolumeSource
  claimRef: GEObjectReference
  csi: GECSIPersistentVolumeSource
  fc: GEFCVolumeSource
  flexVolume: GEFlexPersistentVolumeSource
  flocker: GEFlockerVolumeSource
  gcePersistentDisk: GEGCEPersistentDiskVolumeSource
  glusterfs: GEGlusterfsPersistentVolumeSource
  hostPath: GEHostPathVolumeSource
  iscsi: GEISCSIPersistentVolumeSource
  local: GELocalVolumeSource
  mountOptions: [String!]
  nfs: GENFSVolumeSource
  nodeAffinity: GEVolumeNodeAffinity
  persistentVolumeReclaimPolicy: String
  photonPersistentDisk: GEPhotonPersistentDiskVolumeSource
  portworxVolume: GEPortworxVolumeSource
  quobyte: GEQuobyteVolumeSource
  rbd: GERBDPersistentVolumeSource
  scaleIO: GEScaleIOPersistentVolumeSource
  storageClassName: String
  storageos: GEStorageOSPersistentVolumeSource
  vertexId: ID!
  volumeMode: String
  vsphereVolume: GEVsphereVirtualDiskVolumeSource
}

type GEKubernetesPersistentVolumeStatus {
  message: String
  phase: String
  reason: String
  vertexId: ID!
}

type GEKubernetesPodSecurityPolicy {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesPodSecurityPolicySpec
  status: String
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesPodSecurityPolicySpec {
  allowedCapabilities: [String!]
  allowedCSIDrivers: [GEAllowedCSIDriver!]
  allowedFlexVolumes: [GEAllowedFlexVolume!]
  allowedHostPaths: [GEAllowedHostPath!]
  allowedProcMountTypes: [String!]
  allowedUnsafeSysctls: [String!]
  allowPrivilegeEscalation: Boolean
  defaultAddCapabilities: [String!]
  defaultAllowPrivilegeEscalation: Boolean
  forbiddenSysctls: [String!]
  fsGroup: GEFSGroupStrategyOptions
  hostIPC: Boolean
  hostNetwork: Boolean
  hostPID: Boolean
  hostPorts: [GEHostPortRange!]
  privileged: Boolean
  readOnlyRootFilesystem: Boolean
  requiredDropCapabilities: [String!]
  runAsGroup: GERunAsGroupStrategyOptions
  runAsUser: GERunAsUserStrategyOptions
  runtimeClass: GERuntimeClassStrategyOptions
  seLinux: GESELinuxStrategyOptions
  supplementalGroups: GESupplementalGroupsStrategyOptions
  vertexId: ID!
  volumes: [String!]
}

type GEKubernetesPodSpec {
  activeDeadlineSeconds: Int
  affinity: GEAffinity
  automountServiceAccountToken: Boolean
  containers: [GEKubernetesContainer!]
  dnsConfig: GEPodDNSConfig
  dnsPolicy: String
  enableServiceLinks: Boolean
  ephemeralContainers: [GEEphemeralContainer!]
  hostAliases: [GEHostAlias!]
  hostIPC: Boolean
  hostname: String
  hostNetwork: Boolean
  hostPID: Boolean
  imagePullSecrets: [GELocalObjectReference!]
  initContainers: [GEKubernetesContainer!]
  nodeName: String
  nodeSelector: JSON
  overhead: JSON
  preemptionPolicy: String
  priority: Int
  priorityClassName: String
  readinessGates: [GEPodReadinessGate!]
  restartPolicy: String
  runtimeClassName: String
  schedulerName: String
  securityContext: GEPodSecurityContext
  serviceAccount: String
  serviceAccountName: String
  setHostnameAsFQDN: Boolean
  shareProcessNamespace: Boolean
  subdomain: String
  terminationGracePeriodSeconds: Int
  tolerations: [GEToleration!]
  topologySpreadConstraints: [GETopologySpreadConstraint!]
  vertexId: ID!
  volumes: [GEKubernetesVolumeSpec!]
}

type GEKubernetesPortExtraData {
  hostIP: String
  hostPort: Int
  vertexId: ID!
}

type GEKubernetesResourceRequirements {
  limits: JSON
  requests: JSON
  vertexId: ID!
}

type GEKubernetesSecretDetails {
  annotations: JSON
  apiVersion: String
  clusterName: String
  deletionGracePeriodSeconds: Int
  finalizers: [String!]
  generateName: String
  generation: Int
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  namespace: String
  resourceVersion: String
  selfLink: String
  uid: String
  vertexId: ID!
}

type GEKubernetesSecurityContext {
  allowPrivilegeEscalation: Boolean
  capabilities: GECapabilities
  privileged: Boolean
  procMount: String
  readOnlyRootFilesystem: Boolean
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seccompProfile: GESeccompProfile
  seLinuxOptions: GESELinuxOptions
  vertexId: ID!
  windowsOptions: GEWindowsSecurityContextOptions
}

type GEKubernetesSecurityContextExtraData {
  allowPrivilegeEscalation: Boolean
  procMount: String
  readOnlyRootFilesystem: Boolean
  runAsNonRoot: Boolean
  seccompProfile: GESeccompProfile
  seLinuxOptions: GESELinuxOptions
  vertexId: ID!
  windowsOptions: GEWindowsSecurityContextOptions
}

type GEKubernetesService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalHostnames: [String!]
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasPublicAddress: Boolean
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEKubernetesServiceSpec
  status: GEKubernetesServiceStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesServiceSpec {
  allocateLoadBalancerNodePorts: Boolean
  clusterIP: String
  clusterIPs: [String!]
  externalIPs: [String!]
  externalName: String
  externalTrafficPolicy: String
  healthCheckNodePort: Int
  ipFamilies: [String!]
  ipFamilyPolicy: String
  loadBalancerIP: String
  loadBalancerSourceRanges: [String!]
  ports: [GEServicePort!]
  publishNotReadyAddresses: Boolean
  selector: JSON
  sessionAffinity: String
  sessionAffinityConfig: GESessionAffinityConfig
  topologyKeys: [String!]
  type: String
  vertexId: ID!
}

type GEKubernetesServiceStatus {
  loadBalancer: GELoadBalancerStatus
  vertexId: ID!
}

type GEKubernetesStorageClass {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowedTopologies: [GETopologySelectorTerm!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  allowVolumeExpansion: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  mountOptions: [String!]
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  parameters: JSON
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  provisioner: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  reclaimPolicy: String
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  volumeBindingMode: String
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesVolume {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kinds: [String!]
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  source: GEKubernetesVolumeKubernetesVolumeSource
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEKubernetesVolumeKubernetesVolumeSource {
  cachingMode: String
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  claimName: String
  datasetName: String
  datasetUUID: String
  defaultMode: Int
  diskName: String
  diskURI: String
  driver: String
  endpoints: String
  fsType: String
  gateway: String
  group: String
  image: String
  initiatorName: String
  iqn: String
  iscsiInterface: String
  items: [GEKeyToPath!]
  keyring: String
  kind: String
  localObjectReference: GELocalObjectReference
  lun: Int
  medium: String
  monitors: [String!]
  nodePublishSecretRef: GELocalObjectReference
  optional: Boolean
  options: JSON
  partition: Int
  path: String
  pdID: String
  pdName: String
  pool: String
  portals: [String!]
  protectionDomain: String
  readOnly: Boolean
  registry: String
  secretFile: String
  secretName: String
  secretRef: GELocalObjectReference
  server: String
  shareName: String
  sizeLimit: GEQuantity
  sources: [GEVolumeProjection!]
  sslEnabled: Boolean
  storageMode: String
  storagePolicyID: String
  storagePolicyName: String
  storagePool: String
  system: String
  targetPortal: String
  targetWWNs: [String!]
  tenant: String
  type: String
  user: String
  vertexId: ID!
  volume: String
  volumeAttributes: JSON
  volumeClaimTemplate: GEPersistentVolumeClaimTemplate
  volumeID: String
  volumeName: String
  volumeNamespace: String
  volumePath: String
  wwids: [String!]
}

type GEKubernetesVolumeSpec {
  awsElasticBlockStore: GEAWSElasticBlockStoreVolumeSource
  azureDisk: GEAzureDiskVolumeSource
  azureFile: GEAzureFileVolumeSource
  cephfs: GECephFSVolumeSource
  cinder: GECinderVolumeSource
  configMap: GEConfigMapVolumeSource
  csi: GECSIVolumeSource
  downwardAPI: GEDownwardAPIVolumeSource
  emptyDir: GEEmptyDirVolumeSource
  ephemeral: GEEphemeralVolumeSource
  fc: GEFCVolumeSource
  flexVolume: GEFlexVolumeSource
  flocker: GEFlockerVolumeSource
  gcePersistentDisk: GEGCEPersistentDiskVolumeSource
  glusterfs: GEGlusterfsVolumeSource
  hostPath: GEHostPathVolumeSource
  iscsi: GEISCSIVolumeSource
  name: String
  nfs: GENFSVolumeSource
  persistentVolumeClaim: GEPersistentVolumeClaimVolumeSource
  photonPersistentDisk: GEPhotonPersistentDiskVolumeSource
  portworxVolume: GEPortworxVolumeSource
  projected: GEProjectedVolumeSource
  quobyte: GEQuobyteVolumeSource
  rbd: GERBDVolumeSource
  scaleIO: GEScaleIOVolumeSource
  secret: GESecretVolumeSource
  storageos: GEStorageOSVolumeSource
  vertexId: ID!
  volumeSource: GEVolumeSource
  vsphereVolume: GEVsphereVirtualDiskVolumeSource
}

type GELabelSelector {
  matchExpressions: [GELabelSelectorRequirement!]
  matchLabels: JSON
  vertexId: ID!
}

type GELabelSelectorRequirement {
  key: String
  operator: String
  values: [String!]
  vertexId: ID!
}

type GELastLogin {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  ipAddress: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  time: DateTime
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GELateralMovementFinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  description: String
  exploitExample: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isCrossCloud: Boolean
  isCrossOrganization: Boolean
  isCrossSubscription: Boolean
  isFromExternalOrganization: Boolean
  isFromPublicAccess: Boolean
  isFromPubliclyExposedComputeResource: Boolean
  isPathTarget: Boolean
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  permissionCombination: [String!]
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  severity: GELateralMovementFindingSeverity
  type: GELateralMovementFindingType
  vertexId: ID!
}

enum GELateralMovementFindingSeverity {
  SEVERITY_LOW
  SEVERITY_MEDIUM
  SEVERITY_HIGH
  SEVERITY_CRITICAL
}

enum GELateralMovementFindingType {
  RISKY_PERMISSION_COMBINATION
  ESCALATION_TO_ADMIN
  ACCESS_TO_SENSITIVE_DATA
  ESCALATION_TO_KUBERNETES_ADMIN
}

type GELifecycle {
  postStart: GEHandler
  preStop: GEHandler
  vertexId: ID!
}

type GELoadBalancer {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  requiresAuth: Boolean
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wafEnabled: Boolean
  wizMockResource: Boolean
  zone: String
}

type GELoadBalancerIngress {
  hostname: String
  ip: String
  ports: [GEPortStatus!]
  vertexId: ID!
}

type GELoadBalancerStatus {
  ingress: [GELoadBalancerIngress!]
  vertexId: ID!
}

type GELocalObjectReference {
  name: String
  vertexId: ID!
}

type GELocalUser {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  danglingDomain: Boolean
  description: String
  enabled: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasRemoteAccess: Boolean
  hasSensitiveData: Boolean
  hasShell: Boolean
  homeDirectory: String
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  isPasswordEmpty: Boolean
  kubernetes: GEKubernetesIAMExtraData
  lastPasswordChange: DateTime
  loginExpiration: DateTime
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  passwordEnabled: Boolean
  passwordLocked: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  shellPath: String
  subscriptionExternalId: String
  tags: JSON
  userDirectory: String
  vertexId: ID!
  wizMockResource: Boolean
}

type GELocalVolumeSource {
  fsType: String
  path: String
  vertexId: ID!
}

type GEMalware {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  cveDetails: GECVE
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  familyName: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isGeneric: Boolean
  md5: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  platform: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  sampleFirstSeen: DateTime
  sampleLastSeen: DateTime
  scannerCount: Int
  scannerMatch: Int
  scannerPercent: Float
  screenshotError: String
  severityLevel: GEThreatSeverityLevel
  sha1: String
  sha256: String
  status: GEFileReputationStatus
  subPlatform: String
  trustFactor: Int
  type: String
  vertexId: ID!
}

type GEMalwareInstance {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  cveDetails: GECVE
  danglingDomain: Boolean
  displayPath: String
  externalId: String
  externalOwners: [String!]
  familyName: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isGeneric: Boolean
  md5: String
  modificationTime: DateTime
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  path: String
  platform: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  sampleFirstSeen: DateTime
  sampleLastSeen: DateTime
  scannerCount: Int
  scannerMatch: Int
  scannerPercent: Float
  screenshotError: String
  severityLevel: GEThreatSeverityLevel
  sha1: String
  sha256: String
  size: Int
  status: GEFileReputationStatus
  subPlatform: String
  trustFactor: Int
  type: String
  vertexId: ID!
}

type GEManagedCertificate {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  caId: String
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  domainName: String
  expiration: DateTime
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  issuer: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  type: GECertificateType
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEManagementService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  atRestEncryption: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasIssues: Boolean
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEManagementType {
  CLOUD
  CUSTOMER
}

type GEMapReduceCluster {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  atRestEncryption: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inTransitEncryption: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEMessagingService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  destinationBucketExternalIds: [String!]
  encrypted: Boolean
  encryptionInTransit: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isManaged: Boolean
  isPaaS: Boolean
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  requiresAuth: Boolean
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEMonitorAlert {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GENamespace {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kubernetes: GEKubernetesNamespaceExtraData
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GENat {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

input GenerateWizContainerRegistryTokenInput {
  _stub: String
}

type GenerateWizContainerRegistryTokenPayload {
  expiresOn: DateTime!
  password: String!
  registry: String!
  user: String!
}

type GENetworkAddress {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  address: String
  addressType: GENetworkAddressType
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isDynamic: Boolean
  isPublic: Boolean
  isSecondary: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GENetworkAddressType {
  IPV4
  IPV6
  DNS
  URL
}

type GENetworkAppliance {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GENetworkInterface {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  directlyInternetFacing: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  macAddress: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GENetworkPolicyEgressRule {
  ports: [GENetworkPolicyPort!]
  to: [GENetworkPolicyPeer!]
  vertexId: ID!
}

type GENetworkPolicyIngressRule {
  from: [GENetworkPolicyPeer!]
  ports: [GENetworkPolicyPort!]
  vertexId: ID!
}

type GENetworkPolicyPeer {
  ipBlock: GEIPBlock
  namespaceSelector: GELabelSelector
  podSelector: GELabelSelector
  vertexId: ID!
}

type GENetworkPolicyPort {
  port: GEIntOrString
  protocol: String
  vertexId: ID!
}

enum GENetworkRoutingGatewayType {
  LOCAL_GATEWAY
  PEERED_VIRTUAL_NETWORK
  INTERNET_GATEWAY
  NETWORK_INTERFACE_GATEWAY
  VPN_GATEWAY
  NAT_GATEWAY
  TRANSIT_GATEWAY
  OUTPOST_LOCAL_GATEWAY
  IPV6_INTERNET_EGRESS_ONLY
  BLACK_HOLE
  DIRECT_CONNECT_GATEWAY
  CUSTOMER_GATEWAY
  VIRTUAL_PRIVATE_GATEWAY
  INTERNET_NAT_GATEWAY
}

type GENetworkRoutingRule {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  dstAddress: String
  dstAddressType: GENetworkRuleAddressType
  externalId: String
  externalOwners: [String!]
  gateway: String
  gatewayType: GENetworkRoutingGatewayType
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  srcObjects: [String!]
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GENetworkRuleAddressType {
  IPV4_CIDR
  IPV6_CIDR
  SERVICE_TAG
  IPV4_ADDRESS_RANGE
}

type GENetworkSecurityRule {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  actionAllow: Boolean
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  dstServiceTags: [String!]
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inbound: Boolean
  name: String
  nativeType: String
  networkProtocols: [String!]
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  priority: Int
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  srcServiceTags: [String!]
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GENFSVolumeSource {
  path: String
  readOnly: Boolean
  server: String
  vertexId: ID!
}

type GENodeAddress {
  address: String
  type: String
  vertexId: ID!
}

type GENodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [GEPreferredSchedulingTerm!]
  requiredDuringSchedulingIgnoredDuringExecution: GENodeSelector
  vertexId: ID!
}

type GENodeConfigSource {
  configMap: GEConfigMapNodeConfigSource
  vertexId: ID!
}

type GENodeConfigStatus {
  active: GENodeConfigSource
  assigned: GENodeConfigSource
  error: String
  lastKnownGood: GENodeConfigSource
  vertexId: ID!
}

type GENodeDaemonEndpoints {
  kubeletEndpoint: GEDaemonEndpoint
  vertexId: ID!
}

type GENodeSelector {
  nodeSelectorTerms: [GENodeSelectorTerm!]
  vertexId: ID!
}

type GENodeSelectorRequirement {
  key: String
  operator: String
  values: [String!]
  vertexId: ID!
}

type GENodeSelectorTerm {
  matchExpressions: [GENodeSelectorRequirement!]
  matchFields: [GENodeSelectorRequirement!]
  vertexId: ID!
}

type GENodeSystemInfo {
  architecture: String
  bootID: String
  containerRuntimeVersion: String
  kernelVersion: String
  kubeletVersion: String
  kubeProxyVersion: String
  machineID: String
  operatingSystem: String
  osImage: String
  systemUUID: String
  vertexId: ID!
}

type GEObjectFieldSelector {
  apiVersion: String
  fieldPath: String
  vertexId: ID!
}

type GEObjectMeta {
  annotations: JSON
  clusterName: String
  creationTimestamp: GETime
  deletionGracePeriodSeconds: Int
  deletionTimestamp: GETime
  finalizers: [String!]
  generateName: String
  generation: Int
  labels: JSON
  name: String
  namespace: String
  ownerReferences: [GEOwnerReference!]
  resourceVersion: String
  selfLink: String
  uid: String
  vertexId: ID!
}

type GEObjectReference {
  apiVersion: String
  fieldPath: String
  kind: String
  name: String
  namespace: String
  resourceVersion: String
  uid: String
  vertexId: ID!
}

type GEOwnerReference {
  apiVersion: String
  blockOwnerDeletion: Boolean
  controller: Boolean
  kind: String
  name: String
  uid: String
  vertexId: ID!
}

type GEPackage {
  language: String
  languageVersion: String
  name: String
  version: String
  vertexId: ID!
}

type GEPeering {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  crossAccountPeering: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEPersistentVolumeClaim {
  metadata: GEObjectMeta
  spec: GEPersistentVolumeClaimSpec
  status: GEPersistentVolumeClaimStatus
  vertexId: ID!
}

type GEPersistentVolumeClaimCondition {
  lastProbeTime: GETime
  lastTransitionTime: GETime
  message: String
  reason: String
  status: String
  type: String
  vertexId: ID!
}

type GEPersistentVolumeClaimSpec {
  accessModes: [String!]
  dataSource: GETypedLocalObjectReference
  resources: GEKubernetesResourceRequirements
  selector: GELabelSelector
  storageClassName: String
  vertexId: ID!
  volumeMode: String
  volumeName: String
}

type GEPersistentVolumeClaimStatus {
  accessModes: [String!]
  capacity: JSON
  conditions: [GEPersistentVolumeClaimCondition!]
  phase: String
  vertexId: ID!
}

type GEPersistentVolumeClaimTemplate {
  metadata: GEObjectMeta
  spec: GEPersistentVolumeClaimSpec
  vertexId: ID!
}

type GEPersistentVolumeClaimVolumeSource {
  claimName: String
  readOnly: Boolean
  vertexId: ID!
}

type GEPhotonPersistentDiskVolumeSource {
  fsType: String
  pdID: String
  vertexId: ID!
}

enum GEPKIAlgorithmType {
  RSA
  DSA
  ECDSA
  ED25519
  X25519
}

type GEPod {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isDefaultSecurityContext: Boolean
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEPodSpec
  status: GEPodStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEPodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [GEWeightedPodAffinityTerm!]
  requiredDuringSchedulingIgnoredDuringExecution: [GEPodAffinityTerm!]
  vertexId: ID!
}

type GEPodAffinityTerm {
  labelSelector: GELabelSelector
  namespaces: [String!]
  topologyKey: String
  vertexId: ID!
}

type GEPodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [GEWeightedPodAffinityTerm!]
  requiredDuringSchedulingIgnoredDuringExecution: [GEPodAffinityTerm!]
  vertexId: ID!
}

type GEPodDNSConfig {
  nameservers: [String!]
  options: [GEPodDNSConfigOption!]
  searches: [String!]
  vertexId: ID!
}

type GEPodDNSConfigOption {
  name: String
  value: String
  vertexId: ID!
}

type GEPodIP {
  ip: String
  vertexId: ID!
}

type GEPodReadinessGate {
  conditionType: String
  vertexId: ID!
}

type GEPodSecurityContext {
  fsGroup: Int
  fsGroupChangePolicy: String
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seccompProfile: GESeccompProfile
  seLinuxOptions: GESELinuxOptions
  supplementalGroups: [Int!]
  sysctls: [GESysctl!]
  vertexId: ID!
  windowsOptions: GEWindowsSecurityContextOptions
}

type GEPodSpec {
  activeDeadlineSeconds: Int
  affinity: GEAffinity
  automountServiceAccountToken: Boolean
  containers: [GEKubernetesContainer!]
  dnsConfig: GEPodDNSConfig
  dnsPolicy: String
  enableServiceLinks: Boolean
  ephemeralContainers: [GEEphemeralContainer!]
  hostAliases: [GEHostAlias!]
  hostIPC: Boolean
  hostname: String
  hostNetwork: Boolean
  hostPID: Boolean
  imagePullSecrets: [String!]
  initContainers: [GEKubernetesContainer!]
  nodeName: String
  nodeSelector: JSON
  overhead: JSON
  preemptionPolicy: String
  priority: Int
  priorityClassName: String
  readinessGates: [GEPodReadinessGate!]
  restartPolicy: String
  runtimeClassName: String
  schedulerName: String
  securityContext: GEPodSecurityContext
  serviceAccount: String
  serviceAccountName: String
  setHostnameAsFQDN: Boolean
  shareProcessNamespace: Boolean
  subdomain: String
  terminationGracePeriodSeconds: Int
  tolerations: [GEToleration!]
  topologySpreadConstraints: [GETopologySpreadConstraint!]
  vertexId: ID!
  volumes: [GEKubernetesVolumeSpec!]
}

type GEPodStatus {
  hostIP: String
  message: String
  nominatedNodeName: String
  phase: String
  podIPs: [String!]
  qosClass: String
  reason: String
  startTime: GETime
  vertexId: ID!
}

type GEPodTemplateSpec {
  metadata: GEObjectMeta
  spec: GEKubernetesPodSpec
  vertexId: ID!
}

type GEPort {
  appProtocol: String
  id: String
  kubernetes: GEKubernetesPortExtraData
  name: String
  networkProtocol: String
  number: Int
  vertexId: ID!
}

type GEPortRange {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  endPort: Int
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  startPort: Int
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEPortStatus {
  error: String
  port: Int
  protocol: String
  vertexId: ID!
}

enum GEPortValidationResult {
  NOT_APPLICABLE
  CLOSED
  OPEN
  SCANNER_DISABLED
  EXCLUDED_FROM_SCAN
  UNSUPPORTED_PORT
}

type GEPortworxVolumeSource {
  fsType: String
  readOnly: Boolean
  vertexId: ID!
  volumeID: String
}

type GEPredefinedGroup {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  groupType: GEPredefinedGroupType
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  subscriptionExternalId: String
  tags: JSON
  userDirectory: String
  vertexId: ID!
  wizMockResource: Boolean
}

enum GEPredefinedGroupType {
  ALL_USERS
  ALL_AUTHENTICATED_USERS
  DOMAIN_ENTITY
  ALL_SUBSCRIPTION_USERS
  ALL_TENANT_USERS
}

type GEPreferredSchedulingTerm {
  preference: GENodeSelectorTerm
  vertexId: ID!
  weight: Int
}

enum GEPresignedURLType {
  AZURE_SAS_TOKEN
}

type GEPrivateEndpoint {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  serviceName: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEPrivateLink {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEPrivilegesRequired {
  NONE
  LOW
  HIGH
  SINGLE
  MULTIPLE
}

type GEProbe {
  exec: GEExecAction
  failureThreshold: Int
  handler: GEHandler
  httpGet: GEHTTPGetAction
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  tcpSocket: GETCPSocketAction
  timeoutSeconds: Int
  vertexId: ID!
}

enum GEProductCategory {
  ONLINE_SERVICE
  CLIENT_APPLICATION
  SERVER_APPLICATION
  CODE_LIBRARY
}

enum GEProductDataType {
  CLASSIFIED
  HEALTH
  PII
  PCI
  FINANCIAL
  CUSTOMER
}

type GEProductKubernetesCluster {
  clusterExternalId: String
  clusterId: String
  environments: [GEEnvironment!]
  namespacesExternalIds: [String!]
  sharedCluster: Boolean
  vertexId: ID!
}

type GEProductOrganization {
  environments: [GEEnvironment!]
  organizationExternalId: String
  organizationId: String
  parentOrganizations: [String!]
  sharedOrganization: Boolean
  sharedResourceGroups: [String!]
  sharedTags: JSON
  subOrganizations: [String!]
  subscriptions: [String!]
  vertexId: ID!
}

enum GEProductResourceStatus {
  MANUALLY_REVIEWED
  AUTO_SUGGESTED
}

type GEProductResourceTags {
  environments: [GEEnvironment!]
  tags: JSON
  vertexId: ID!
}

enum GEProductSubCategory {
  PUBLIC_CLOUD
  PRIVATE_CLOUD
  ON_PREMISE_DATACENTER
  DESKTOP_APPLICATION
  MOBILE_APPLICATION
  SERVER_APPLICATION
}

type GEProject {
  archived: Boolean
  businessImpact: GEBusinessImpact
  businessUnit: String
  description: String
  externalId: String
  hasAuthentication: Boolean
  hasExposedAPI: Boolean
  hasUserInterface: Boolean
  id: String
  identifiers: [String!]
  isActivelyDeveloped: Boolean
  isCustomerFacing: Boolean
  isInternetFacing: Boolean
  isRegulated: Boolean
  kubernetesClusters: [GEProductKubernetesCluster!]
  lastReview: DateTime
  name: String
  note: String
  organizations: [GEProductOrganization!]
  ownerIds: [String!]
  productCategory: GEProductCategory
  productSubCategory: GEProductSubCategory
  regulatoryStandards: [GERegulatoryStandards!]
  repositories: [GEProjectRepository!]
  resourceTags: [GEProductResourceTags!]
  securityChampIds: [String!]
  sensitiveDataTypes: [GEProductDataType!]
  slug: String
  storesData: Boolean
  subscriptions: [GEProjectSubscription!]
  vertexId: ID!
}

type GEProjectedVolumeSource {
  defaultMode: Int
  sources: [GEVolumeProjection!]
  vertexId: ID!
}

type GEProjectRepository {
  repoExternalId: String
  repoId: String
  status: GEProductResourceStatus
  vertexId: ID!
}

type GEProjectSubscription {
  environments: [GEEnvironment!]
  parentOrganizations: [String!]
  sharedAccount: Boolean
  sharedResourceGroups: [String!]
  sharedTags: JSON
  status: GEProductResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  vertexId: ID!
}

type GEProxy {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kinds: [String!]
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEProxyRule {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  allPorts: Boolean
  backendAddresses: [String!]
  backendAppProtocol: String
  backendNetworkInterfaceIds: [String!]
  backendNetworkProtocol: String
  backendPort: Int
  backendWebServiceExternalId: String
  certificateIds: [String!]
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  directServerReturn: Boolean
  domainIds: [String!]
  externalId: String
  externalOwners: [String!]
  firewallExternalIds: [String!]
  frontendAddresses: [String!]
  frontendAppProtocol: String
  frontendNetworkInterfaceId: String
  frontendNetworkProtocol: String
  frontendPort: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  hostConditions: [String!]
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpMethodMatchType: String
  httpMethodTypes: [String!]
  httpTitleSnippet: String
  isSourceNAT: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  pathConditions: [String!]
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  type: GEProxyRuleType
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEProxyRuleType {
  NAT_RULE
  FORWARDING_RULE
}

enum GEPublicExposure {
  PRIVATE
  OBJECTS_MAY_BE_PUBLIC
  PUBLIC
}

type GEQuantity {
  quantity: String
  vertexId: ID!
}

type GEQuobyteVolumeSource {
  group: String
  readOnly: Boolean
  registry: String
  tenant: String
  user: String
  vertexId: ID!
  volume: String
}

type GERawAccessPolicy {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudPlatform: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  screenshotError: String
  statements: [GERawAccessPolicyPolicyStatement!]
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
}

enum GERawAccessPolicyEffect {
  ALLOW
  DENY
}

type GERawAccessPolicyPolicyElements {
  elements: [String!]
  isExceptionList: Boolean
  vertexId: ID!
}

type GERawAccessPolicyPolicyStatement {
  actions: GERawAccessPolicyPolicyElements
  alibabaConditions: String
  awsCondition: String
  effect: GERawAccessPolicyEffect
  id: String
  principals: GERawAccessPolicyPolicyElements
  resources: GERawAccessPolicyPolicyElements
  vertexId: ID!
}

type GERBDPersistentVolumeSource {
  fsType: String
  image: String
  keyring: String
  monitors: [String!]
  pool: String
  readOnly: Boolean
  secretRef: GESecretReference
  user: String
  vertexId: ID!
}

type GERBDVolumeSource {
  fsType: String
  image: String
  keyring: String
  monitors: [String!]
  pool: String
  readOnly: Boolean
  secretRef: GELocalObjectReference
  user: String
  vertexId: ID!
}

type GERegion {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GERegisteredDomain {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  autoRenew: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  expiry: DateTime
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  transferLock: Boolean
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GERegulatoryStandards {
  ISO_20000_1_2011
  ISO_22301
  ISO_27001
  ISO_27017
  ISO_27018
  ISO_27701
  ISO_9001
  SOC
  FEDRAMP
  NIST_800_171
  NIST_CSF
  HIPPA_HITECH
  HITRUST
  PCI_DSS
  SEC_17_A_4
  SEC_REGULATION_SCI
  SOX
  GDPR
  HIPAA_HITECH
}

type GEReplicaSet {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEReplicaSetSpec
  status: GEReplicaSetStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEReplicaSetSpec {
  minReadySeconds: Int
  replicas: Int
  selector: GELabelSelector
  template: GEPodTemplateSpec
  vertexId: ID!
}

type GEReplicaSetStatus {
  availableReplicas: Int
  fullyLabeledReplicas: Int
  observedGeneration: Int
  readyReplicas: Int
  replicas: Int
  vertexId: ID!
}

type GERepository {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  labels: [String!]
  languages: [String!]
  lastPushedAt: DateTime
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  private: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  repositoryExternalId: String
  screenshotError: String
  url: String
  vertexId: ID!
}

type GERepositoryBranch {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  headCommit: String
  headCommitTimestamp: DateTime
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  repositoryExternalId: String
  screenshotError: String
  vertexId: ID!
}

type GERepositoryTag {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  commit: String
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  repositoryExternalId: String
  screenshotError: String
  vertexId: ID!
}

type GEResourceFieldSelector {
  containerName: String
  divisor: GEQuantity
  resource: String
  vertexId: ID!
}

type GEResourceGroup {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  governancePolicyAssignments: GEGovernancePolicyAssignments
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEResourceRequirements {
  limits: JSON
  requests: JSON
  vertexId: ID!
}

enum GERisk {
  LOW
  MEDIUM
  HIGH
}

type GERollingUpdateDaemonSet {
  maxSurge: GEIntOrString
  maxUnavailable: GEIntOrString
  vertexId: ID!
}

type GERollingUpdateDeployment {
  maxSurge: GEIntOrString
  maxUnavailable: GEIntOrString
  vertexId: ID!
}

type GERollingUpdateStatefulSetStrategy {
  partition: Int
  vertexId: ID!
}

type GERouteTable {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GERunAsGroupStrategyOptions {
  ranges: [GEIDRange!]
  rule: String
  vertexId: ID!
}

type GERunAsUserStrategyOptions {
  ranges: [GEIDRange!]
  rule: String
  vertexId: ID!
}

type GERuntimeClassStrategyOptions {
  allowedRuntimeClassNames: [String!]
  defaultRuntimeClassName: String
  vertexId: ID!
}

type GEScaleIOPersistentVolumeSource {
  fsType: String
  gateway: String
  protectionDomain: String
  readOnly: Boolean
  secretRef: GESecretReference
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String
  vertexId: ID!
  volumeName: String
}

type GEScaleIOVolumeSource {
  fsType: String
  gateway: String
  protectionDomain: String
  readOnly: Boolean
  secretRef: GELocalObjectReference
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String
  vertexId: ID!
  volumeName: String
}

enum GEScanStatus {
  PROCESSING
  SUCCESS
  ERROR
  SKIPPED
  NOT_APPLICABLE
}

type GEScopeToBool {
  customIPRanges: Boolean
  internet: Boolean
  otherSubscriptions: Boolean
  otherVnets: Boolean
  vertexId: ID!
  VPN: Boolean
}

type GEScopeToInt {
  CustomIPRanges: Int
  Internet: Int
  OtherSubscriptions: Int
  OtherVnets: Int
  vertexId: ID!
  VPN: Int
}

type GESearchIndex {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESeccompProfile {
  localhostProfile: String
  type: String
  vertexId: ID!
}

type GESecret {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  checksum: String
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  description: String
  externalId: String
  externalOwners: [String!]
  file: GESecretSecretInFileDetails
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kubernetes: GEKubernetesSecretDetails
  labels: [String!]
  managed: GESecretManagedSecretDetails
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  risk: GERisk
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  type: GESecretType
  usage: GEUsage
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESecretContainer {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESecretData {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  certificate: GESecretDataCertificateDetails
  cloudKey: GESecretDataCloudKeyDetails
  containsContainerHosts: Boolean
  crackedPassword: GESecretDataCrackedPasswordDetails
  danglingDomain: Boolean
  dbConnectionString: GESecretDataDBConnectionStringDetails
  externalId: String
  externalOwners: [String!]
  gitCredential: GESecretDataGitCredentialDetails
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isEncrypted: Boolean
  isManaged: Boolean
  isPrivate: Boolean
  managedDetails: GESecretDataManagedSecretDetails
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  password: GESecretDataPasswordDetails
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  presignedURL: GESecretDataPresignedURLDetails
  privateIPRangesWithAccess: [String!]
  privateKey: GESecretDataPKIKeyDetails
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  publicKey: GESecretDataPKIKeyDetails
  saasApiKey: GESecretDataSaasAPIKeyDetails
  screenshotError: String
  sha256: String
  sshAuthorizedKey: GESecretDataSSHAuthorizedKeyDetails
  type: GEDataType
  vertexId: ID!
}

type GESecretDataCertificateDetails {
  expiration: DateTime
  isCA: Boolean
  isCodeSigning: Boolean
  isSelfSigned: Boolean
  isServer: Boolean
  issuer: String
  isWildcard: Boolean
  subjects: String
  thumbprint: String
  vertexId: ID!
}

type GESecretDataCloudKeyDetails {
  isLongTerm: Boolean
  keyType: GECloudKeyType
  providerUniqueId: String
  vertexId: ID!
}

type GESecretDataCrackedPasswordDetails {
  isWeak: Boolean
  vertexId: ID!
}

type GESecretDataDBConnectionStringDetails {
  connString: String
  database: String
  user: String
  vertexId: ID!
}

type GESecretDataGitCredentialDetails {
  url: String
  user: String
  vertexId: ID!
}

type GESecretDataManagedSecretDetails {
  isAutoRotated: Boolean
  vertexId: ID!
}

type GESecretDataPasswordDetails {
  entropyBits: Int
  isComplex: Boolean
  numChars: Int
  vertexId: ID!
}

type GESecretDataPKIKeyDetails {
  algorithm: GEPKIAlgorithmType
  bits: Int
  vertexId: ID!
}

type GESecretDataPresignedURLDetails {
  accessTypes: [GEAccessType!]
  expiration: DateTime
  type: GEPresignedURLType
  url: String
  vertexId: ID!
}

type GESecretDataSaasAPIKeyDetails {
  serviceName: String
  vertexId: ID!
}

type GESecretDataSSHAuthorizedKeyDetails {
  algo: String
  comment: String
  options: [String!]
  user: String
  vertexId: ID!
}

type GESecretEnvSource {
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GESecretInstance {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  confidence: GEConfidence
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  endOffset: Int
  externalId: String
  externalOwners: [String!]
  finderData: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  lastModified: DateTime
  lineNumber: Int
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  packageName: String
  path: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  snippet: String
  startOffset: Int
  vertexId: ID!
}

type GESecretKeySelector {
  key: String
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GESecretManagedSecretDetails {
  encryptionKeyExternalID: String
  rotation: Boolean
  vertexId: ID!
}

type GESecretProjection {
  items: [GEKeyToPath!]
  localObjectReference: GELocalObjectReference
  optional: Boolean
  vertexId: ID!
}

type GESecretReference {
  name: String
  namespace: String
  vertexId: ID!
}

type GESecretSecretInFileDetails {
  lineNumber: Int
  matchedLine: String
  nextLine: String
  path: String
  previousLine: String
  vertexId: ID!
}

enum GESecretType {
  SECRET_IN_FILE
  MANAGED_SECRET
  KUBERNETES_SECRET
  SSH_KEY_PAIR
}

type GESecretVolumeSource {
  defaultMode: Int
  items: [GEKeyToPath!]
  optional: Boolean
  secretName: String
  vertexId: ID!
}

type GESecurityContext {
  addedCapabilities: [String!]
  droppedCapabilities: [String!]
  gid: String
  kubernetes: GEKubernetesSecurityContextExtraData
  privileged: Boolean
  runsAsRoot: Boolean
  sysctls: JSON
  uid: String
  vertexId: ID!
}

type GESecurityEventFinding {
  delegateEventId: String
  delegateEventTimestamp: DateTime
  description: String
  externalId: String
  name: String
  origin: GECloudEventOrigin
  ruleBuiltinId: String
  ruleId: String
  ruleVersion: Int
  securityFrameworkSubCategoryIds: [String!]
  severity: GECSESeverity
  source: GESecurityEventFindingSource
  vertexId: ID!
}

enum GESecurityEventFindingSource {
  WIZ
  GUARD_DUTY
  SCC
  DEFENDER_FOR_CLOUD
}

type GESecurityToolFinding {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  dataSourceLink: String
  dataSourceName: String
  description: String
  detailed: GESecurityToolFindingExtraInfo
  detectedByDefaultPackageName: String
  detectedByFilePath: String
  detectedByInstalledProgramName: String
  detectedByKB: String
  detectedByLibraryName: String
  detectedByPackageName: String
  detectedByWindowsService: String
  detectionMethod: GEDetectionMethod
  exploitLink: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isBaseLayer: Boolean
  isPotentiallyHidden: Boolean
  layerDetails: String
  layerId: String
  layerIndex: Int
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  remediation: String
  resolutionRecommendation: String
  screenshotError: String
  severity: GEVulnerabilitySeverity
  type: GEVulnerabilityType
  validatedInRuntime: Boolean
  vertexId: ID!
}

type GESecurityToolFindingExtraInfo {
  arch: String
  assetUUID: String
  attackerNode: String
  bundleName: String
  cloudAccountID: String
  cloudAccountName: String
  complianceSection: String
  entityID: String
  entityName: String
  entityType: String
  epoch: Int
  fileDisplayPath: String
  fileName: String
  filePath: String
  fixedVersion: String
  fqdn: String
  host: String
  id: String
  language: String
  libraryName: String
  libraryVersion: String
  mitreATTCKTactics: String
  mitreATTCKTechniques: String
  modularityLabel: String
  moduleName: String
  name: String
  packageManager: String
  packageName: String
  path: String
  pluginOutput: String
  port: String
  protocol: String
  release: String
  repository: String
  result: String
  sinkMethod: String
  slug: String
  sourceMethod: String
  srcEpoch: Int
  srcName: String
  srcRelease: String
  srcVersion: String
  status: String
  type: String
  uri: String
  version: String
  vertexId: ID!
}

type GESecurityToolFindingType {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  containsContainerHosts: Boolean
  danglingDomain: Boolean
  dataSourceLink: String
  description: String
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  resolutionRecommendation: String
  screenshotError: String
  severity: GEVulnerabilitySeverity
  vertexId: ID!
}

type GESecurityToolScan {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  analysisDate: DateTime
  containsContainerHosts: Boolean
  createdByConnector: String
  createdByUser: String
  danglingDomain: Boolean
  dataSource: GESecurityToolScanDataSourceInfo
  dataSourceId: String
  dataSourceLink: String
  description: String
  diskScanInfo: GESecurityToolScanDiskScanInfo
  externalId: String
  externalOwners: [String!]
  fileUploadId: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  hostInfo: GESecurityToolScanHostInfo
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  lastSuccess: DateTime
  name: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  originalId: String
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  registryLastScan: DateTime
  screenshotError: String
  status: GEScanStatus
  statusDetails: String
  vertexId: ID!
  workloadAnalysisInfo: GESecurityToolScanWorkloadAnalysisInfo
  workloadLastScan: DateTime
}

type GESecurityToolScanDataSourceInfo {
  category: String
  name: String
  vertexId: ID!
}

type GESecurityToolScanDiskScanInfo {
  connectorType: GEConnectorType
  scanDuration: Int
  snapshotLifetime: Int
  snapshotSizeMB: Int
  vertexId: ID!
  volumeSizeGB: Int
}

type GESecurityToolScanHostInfo {
  objectType: String
  vertexId: ID!
}

type GESecurityToolScanWorkloadAnalysisInfo {
  hasCriticalSeverityVulns: Boolean
  hasHighCriticalKernelVulns: Boolean
  hasHighCriticalNetworkExploitableVulns: Boolean
  hasHighSeverityVulns: Boolean
  vertexId: ID!
}

type GESELinuxOptions {
  level: String
  role: String
  type: String
  user: String
  vertexId: ID!
}

type GESELinuxStrategyOptions {
  rule: String
  seLinuxOptions: GESELinuxOptions
  vertexId: ID!
}

type GEServerless {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsLambda: GEServerlessAWSLambdaExtraData
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  requiresAuth: Boolean
  resourceGroupExternalId: String
  runtime: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEServerlessAWSLambdaExtraData {
  urlConfigs: [GEServerlessAWSLambdaExtraDataFunctionUrlConfig!]
  vertexId: ID!
}

type GEServerlessAWSLambdaExtraDataFunctionUrlConfig {
  authType: String
  functionUrl: String
  vertexId: ID!
}

type GEServerlessPackage {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEServiceAccount {
  aad: GEAADServicePrincipalMetadata
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  clientId: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  danglingDomain: Boolean
  description: String
  displayName: String
  email: String
  enabled: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  kubernetes: GEKubernetesIAMExtraData
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  servicePermissions: [PrincipalServicePermissions!] @deprecated(reason: "Deprecated property")
  subscriptionExternalId: String
  tags: JSON
  userDirectory: String
  vertexId: ID!
  wizMockResource: Boolean
}

type GEServiceAccountTokenProjection {
  audience: String
  expirationSeconds: Int
  path: String
  vertexId: ID!
}

type GEServiceConfiguration {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEServicePort {
  appProtocol: String
  name: String
  nodePort: Int
  port: Int
  protocol: String
  targetPort: GEIntOrString
  vertexId: ID!
}

type GEServiceUsageTechnology {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceCount: Int
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESessionAffinityConfig {
  clientIP: GEClientIPConfig
  vertexId: ID!
}

enum GESeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type GESnapshot {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPublic: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GESource {
  WIZ_CSPM
  ASC
  INSPECTOR
}

enum GESslProtocolVersion {
  TL_SV1_0
  TL_SV1_1
  TL_SV1_2
  TL_SV1_3
}

type GEStatefulSet {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  annotations: JSON
  apiVersion: String
  cloudPlatform: String
  cloudProviderURL: String
  clusterName: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  deletionGracePeriodSeconds: Int
  externalId: String
  externalOwners: [String!]
  finalizers: [String!]
  generateName: String
  generation: Int
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  kind: String
  kubernetes: GEKubernetesBaseExtraData
  labels: JSON
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  resourceVersion: String
  screenshotError: String
  selfLink: String
  spec: GEStatefulSetSpec
  status: GEStatefulSetStatus
  subscriptionExternalId: String
  tags: JSON
  uid: String
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEStatefulSetSpec {
  podManagementPolicy: String
  replicas: Int
  revisionHistoryLimit: Int
  selector: GELabelSelector
  serviceName: String
  template: GEPodTemplateSpec
  updateStrategy: GEStatefulSetUpdateStrategy
  vertexId: ID!
  volumeClaimTemplates: [GEPersistentVolumeClaim!]
}

type GEStatefulSetStatus {
  collisionCount: Int
  currentReplicas: Int
  currentRevision: String
  observedGeneration: Int
  readyReplicas: Int
  replicas: Int
  updatedReplicas: Int
  updateRevision: String
  vertexId: ID!
}

type GEStatefulSetUpdateStrategy {
  rollingUpdate: GERollingUpdateStatefulSetStrategy
  type: String
  vertexId: ID!
}

enum GEStatus {
  FAIL
  PASS
  ASSESSMENT_ERROR
  NOT_ASSESSED
}

type GEStorageAccount {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  encryptionInTransit: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEStorageOSPersistentVolumeSource {
  fsType: String
  readOnly: Boolean
  secretRef: GEObjectReference
  vertexId: ID!
  volumeName: String
  volumeNamespace: String
}

type GEStorageOSVolumeSource {
  fsType: String
  readOnly: Boolean
  secretRef: GELocalObjectReference
  vertexId: ID!
  volumeName: String
  volumeNamespace: String
}

type GESubnet {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  addressRanges: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESubscription {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  governancePolicyAssignments: GEGovernancePolicyAssignments
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  subscriptionId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESupplementalGroupsStrategyOptions {
  ranges: [GEIDRange!]
  rule: String
  vertexId: ID!
}

type GESwitch {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GESysctl {
  name: String
  value: String
  vertexId: ID!
}

type GETaint {
  effect: String
  key: String
  timeAdded: GETime
  value: String
  vertexId: ID!
}

type GETCPSocketAction {
  host: String
  port: GEIntOrString
  vertexId: ID!
}

type GETechnology {
  categories: [String!]
  createdAt: DateTime
  id: String
  name: String
  stackLayer: String
  status: GETechStatus
  threatImpact: GEThreatImpact
  vertexId: ID!
}

enum GETechStatus {
  UNREVIEWED
  SANCTIONED
  UNSANCTIONED
  REQUIRED
}

enum GEThreatImpact {
  LOW
  MEDIUM
  HIGH
}

enum GEThreatSeverityLevel {
  THREAT_SEVERITY_NO_THREAT
  THREAT_SEVERITY_INFO
  THREAT_SEVERITY_LOW
  THREAT_SEVERITY_MEDIUM
  THREAT_SEVERITY_HIGH
  THREAT_SEVERITY_CRITICAL
}

type GETime {
  UTC: String
  vertexId: ID!
}

type GETLSConfigCertificateAuthority {
  data: String
  vertexId: ID!
}

type GEToleration {
  effect: String
  key: String
  operator: String
  tolerationSeconds: Int
  value: String
  vertexId: ID!
}

type GETopologySelectorLabelRequirement {
  key: String
  values: [String!]
  vertexId: ID!
}

type GETopologySelectorTerm {
  matchLabelExpressions: [GETopologySelectorLabelRequirement!]
  vertexId: ID!
}

type GETopologySpreadConstraint {
  labelSelector: GELabelSelector
  maxSkew: Int
  topologyKey: String
  vertexId: ID!
  whenUnsatisfiable: String
}

input GetReportAvailableColumnsInput {
  type: String!
}

type GetReportAvailableColumnsPayload {
  columns: [String!]
}

enum GEType {
  STATIC
  SESSION_CONTEXT
  SESSION_PARAMETER
  IGNORED
}

type GETypedLocalObjectReference {
  apiGroup: String
  kind: String
  name: String
  vertexId: ID!
}

enum GEUsage {
  PASSWORD
  TOKEN
  KEY
  CERTIFICATE
  AWS_TOKEN
  SSH_KEY
}

type GEUserAccount {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  accountEnabled: Boolean
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  awsUniqueIdentifier: String
  cloudProviderURL: String
  company: String
  containsContainerHosts: Boolean
  createdAt: DateTime
  credentials: [GECredential!]
  danglingDomain: Boolean
  department: String
  description: String
  directoryLastSyncTime: DateTime
  displayName: String
  externalId: String
  externalOwners: [String!]
  givenName: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasMfa: Boolean
  hasSensitiveData: Boolean
  hasShell: Boolean
  homeDirectory: String
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  inactiveInLast90Days: Boolean
  jobTitle: String
  kubernetes: GEKubernetesIAMExtraData
  lastPasswordChange: DateTime
  lastPasswordUse: DateTime
  location: String
  loginExpiration: DateTime
  mail: String
  mailNickname: String
  name: String
  namespace: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  otherMails: [String!]
  passwordEnabled: Boolean
  passwordLocked: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  premisesDistinguishedName: String
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  proxyAddresses: [String!]
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  screenshotError: String
  servicePermissions: [PrincipalServicePermissions!] @deprecated(reason: "Deprecated property")
  shellPath: String
  subscriptionExternalId: String
  surname: String
  tags: JSON
  userDirectory: String
  userPrincipalName: String
  vertexId: ID!
  wizMockResource: Boolean
}

type GEVirtualDesktop {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  rootVolumeAtRestEncryption: Boolean
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  userVolumeAtRestEncryption: Boolean
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEVirtualMachine {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isContainerHost: Boolean
  isEphemeral: Boolean
  isFromAWSMarketplace: Boolean
  isManaged: Boolean
  kubernetesExtraData: GEVirtualMachineKubernetesExtraData
  memoryGB: Float
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  operatingSystem: String
  passwordAuthDisabled: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  scopes: [String!]
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vCPUs: Int
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEVirtualMachineImage {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  extraData: GEVirtualMachineImageExtraData
  family: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isPublic: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  sourceType: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEVirtualMachineImageExtraData {
  azure: GEVirtualMachineImageExtraDataAzureExtraData
  vertexId: ID!
}

type GEVirtualMachineImageExtraDataAzureExtraData {
  osType: GEVMOperatingSystem
  sourceBlobUri: String
  sourceDiskId: String
  sourceGalleryImageVersionId: String
  sourceImageId: String
  sourceSnapshotId: String
  sourceStorageAccountId: String
  vertexId: ID!
}

type GEVirtualMachineKubernetesExtraData {
  isKubernetesNode: Boolean
  vertexId: ID!
}

type GEVirtualNetwork {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  addressRanges: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  flowLogsEnabled: Boolean
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasDeployedInstances: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isDefault: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  resourceGroupExternalId: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

enum GEVMOperatingSystem {
  LINUX
  WINDOWS
  UNKNOWN
}

type GEVolume {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  encrypted: Boolean
  externalId: String
  externalOwners: [String!]
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasRecentSnapshot: Boolean
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isManaged: Boolean
  isOs: Boolean
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  partitionsEncryptionSecretVersion: [String!]
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  replica: Boolean
  resourceGroupExternalId: String
  screenshotError: String
  sizeGb: Int
  sourceImage: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  volumeType: String
  wizMockResource: Boolean
  zone: String
}

type GEVolumeDevice {
  devicePath: String
  name: String
  vertexId: ID!
}

type GEVolumeMount {
  mountPath: String
  mountPropagation: String
  name: String
  readOnly: Boolean
  subPath: String
  subPathExpr: String
  vertexId: ID!
}

type GEVolumeNodeAffinity {
  required: GENodeSelector
  vertexId: ID!
}

type GEVolumeProjection {
  configMap: GEConfigMapProjection
  downwardAPI: GEDownwardAPIProjection
  secret: GESecretProjection
  serviceAccountToken: GEServiceAccountTokenProjection
  vertexId: ID!
}

type GEVolumeSource {
  awsElasticBlockStore: GEAWSElasticBlockStoreVolumeSource
  azureDisk: GEAzureDiskVolumeSource
  azureFile: GEAzureFileVolumeSource
  cephfs: GECephFSVolumeSource
  cinder: GECinderVolumeSource
  configMap: GEConfigMapVolumeSource
  csi: GECSIVolumeSource
  downwardAPI: GEDownwardAPIVolumeSource
  emptyDir: GEEmptyDirVolumeSource
  ephemeral: GEEphemeralVolumeSource
  fc: GEFCVolumeSource
  flexVolume: GEFlexVolumeSource
  flocker: GEFlockerVolumeSource
  gcePersistentDisk: GEGCEPersistentDiskVolumeSource
  glusterfs: GEGlusterfsVolumeSource
  hostPath: GEHostPathVolumeSource
  iscsi: GEISCSIVolumeSource
  nfs: GENFSVolumeSource
  persistentVolumeClaim: GEPersistentVolumeClaimVolumeSource
  photonPersistentDisk: GEPhotonPersistentDiskVolumeSource
  portworxVolume: GEPortworxVolumeSource
  projected: GEProjectedVolumeSource
  quobyte: GEQuobyteVolumeSource
  rbd: GERBDVolumeSource
  scaleIO: GEScaleIOVolumeSource
  secret: GESecretVolumeSource
  storageos: GEStorageOSVolumeSource
  vertexId: ID!
  vsphereVolume: GEVsphereVirtualDiskVolumeSource
}

type GEVsphereVirtualDiskVolumeSource {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  vertexId: ID!
  volumePath: String
}

type GEVulnerability {
  cisaKevDueDate: DateTime
  cisaKevReleaseDate: DateTime
  cvssV2AttackComplexity: GEAttackComplexity
  cvssV2AttackVector: GEAttackVector
  cvssV2ConfidentialityImpact: GEImpact
  cvssV2IntegrityImpact: GEImpact
  cvssV2PrivilegesRequired: GEPrivilegesRequired
  cvssV2UserInteractionRequired: Boolean
  cvssV3AttackComplexity: GEAttackComplexity
  cvssV3AttackVector: GEAttackVector
  cvssV3ConfidentialityImpact: GEImpact
  cvssV3IntegrityImpact: GEImpact
  cvssV3PrivilegesRequired: GEPrivilegesRequired
  cvssV3UserInteractionRequired: Boolean
  description: String
  effectiveAttackVector: GEAttackVector
  exploitabilityScore: Float
  externalId: String
  hasCisaKevExploit: Boolean
  hasExploit: Boolean
  impactScore: Float
  link: String
  name: String
  publishedDate: DateTime
  references: [String!]
  score: Float
  severity: GEVulnerabilitySeverity
  vertexId: ID!
}

enum GEVulnerabilitySeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum GEVulnerabilityType {
  VULNERABILITY
  EOL
}

type GEWeakness {
  commonConsequences: [String!]
  description: String
  externalId: String
  link: String
  name: String
  vertexId: ID!
}

type GEWebService {
  accessibleFrom: GEScopeToBool
  accessibleFromScopes: [String!]
  allowsExternalRead: Boolean
  allowsExternalWrite: Boolean
  cloudPlatform: String
  cloudProviderURL: String
  containsContainerHosts: Boolean
  creationDate: DateTime
  danglingDomain: Boolean
  externalId: String
  externalOwners: [String!]
  fqdn: String
  hasAdminKubernetesPrivileges: Boolean
  hasAdminPrivileges: Boolean
  hasHighKubernetesPrivileges: Boolean
  hasHighPrivileges: Boolean
  hasIAMAccessFromExternalSubscription: [GEAccessType!]
  hasIAMAccessFromOutsideOrganization: [GEAccessType!]
  hasIAMAccessToExternalSubscription: [GEAccessType!]
  hasIAMAccessToOutsideOrganization: [GEAccessType!]
  hasSensitiveData: Boolean
  httpContentType: String
  httpGETStatus: String
  httpGETStatusCode: Int
  httpTitleSnippet: String
  isManaged: Boolean
  kind: String
  name: String
  nativeType: String
  numAddressesOpenForHTTP: Int
  numAddressesOpenForHTTPS: Int
  numAddressesOpenForNonStandardPorts: Int
  numAddressesOpenForRDP: Int
  numAddressesOpenForSSH: Int
  numAddressesOpenForWINRM: Int
  numAddressesOpenTo: GEScopeToInt
  numPortsOpenTo: GEScopeToInt
  openPorts: [Int!]
  openToAllInternet: Boolean
  openToEntireInternet: Boolean
  portValidationResult: GEPortValidationResult
  potentialSubdomainTakeover: Boolean
  privateIPRangesWithAccess: [String!]
  providerUniqueId: String
  publicAccessTypes: [GEAccessType!]
  publicIPRangesWithAccess: [String!]
  region: String
  requiresAuth: Boolean
  resourceGroupExternalId: String
  runtime: String
  screenshotError: String
  status: String
  subscriptionExternalId: String
  tags: JSON
  vertexId: ID!
  wizMockResource: Boolean
  zone: String
}

type GEWeightedPodAffinityTerm {
  podAffinityTerm: GEPodAffinityTerm
  vertexId: ID!
  weight: Int
}

type GEWindowsSecurityContextOptions {
  gmsaCredentialSpec: String
  gmsaCredentialSpecName: String
  runAsUserName: String
  vertexId: ID!
}

type GoogleChatActionTemplateParams {
  note: String
}

input GoogleChatActionTemplateParamsInput {
  note: String
}

type GoogleChatMessageAutomationActionParams {
  note: String
  url: String!
}

enum GooglePubSubAutomationActionAccessMethodType {
  CONNECTOR_CREDENTIALS
  SERVICE_ACCOUNT_KEY
}

type GooglePubSubAutomationActionParams {
  accessMethod: GooglePubSubAutomationActionAccessMethodType!
  body: String!
  connectorForAccess: Connector
  projectId: String!
  serviceAccountKey: JSON
  topicId: String!
}

input GooglePubSubIntegrationAccessMethodInput {
  type: GcpPubSubIntegrationAccessMethodType!
  accessConnectorId: ID
  serviceAccountKey: JSON
}

type GraphDirectedRelationshipType {
  reverse: Boolean
  type: GraphRelationshipType!
}

input GraphDirectedRelationshipTypeInput {
  type: GraphRelationshipType!
  reverse: Boolean
}

type GraphEntity implements Node {
  customIPRangeExposures(after: String, first: Int!): NetworkExposureConnection!
  firstSeen: DateTime
  hasOriginalObject: Boolean!
  id: ID!
  issues(after: String, filterBy: IssueFilters, first: Int, orderBy: IssueOrder): IssueConnection!
  kubernetesPaths(after: String, first: Int!): KubernetesPathConnection!
  lastSeen: DateTime
  lateralMovementPaths(after: String, first: Int!): LateralMovementPathConnection!
  name: String
  originalObject: JSON
  otherSubscriptionExposures(after: String, first: Int!): NetworkExposureConnection!
  otherVnetExposures(after: String, first: Int!): NetworkExposureConnection!
  peripheralData: JSON
  projects: [Project!]
  properties: JSON!
  providerData: JSON
  publicExposures(after: String, first: Int!): NetworkExposureConnection!
  sensorName: String
  systemActivities(after: String, filterBy: SystemActivityFilters, first: Int): SystemActivityConnection!
  technologies: [Technology!]
  type: GraphEntityTypeValue!
  typedProperties: GEAny
  userMetadata: GraphEntityMetadata
  userTags: JSON
  vpnExposures(after: String, first: Int!): NetworkExposureConnection!
}

type GraphEntityMetadata {
  isIgnored: Boolean
  isInWatchlist: Boolean
  note: String
}

type GraphEntityQuery {
  aggregate: Boolean
  aggregateConstraint: GraphPropertyPredicate
  as: String
  blockExpanded: Boolean
  blockName: String
  relationships: [GraphRelationshipQuery!]
  select: Boolean
  type: [GraphEntityType!]!
  where: GraphPropertyPredicate
}

input GraphEntityQueryInput {
  type: [GraphEntityType!]!
  as: String
  relationships: [GraphRelationshipQueryInput!]
  where: GraphPropertyPredicate
  select: Boolean
  aggregate: Boolean
  aggregateConstraint: GraphPropertyPredicate
  blockName: String
  blockExpanded: Boolean
}

scalar GraphEntityQueryValue

enum GraphEntityType {
  ANY
  ACCESS_KEY
  ACCESS_ROLE
  ACCESS_ROLE_BINDING
  ACCESS_ROLE_PERMISSION
  API_GATEWAY
  APPLICATION
  AUTHENTICATION_CONFIGURATION
  AUTHENTICATION_POLICY
  BACKEND_BUCKET
  BACKUP_SERVICE
  BRANCH_PACKAGE
  BUCKET
  CALL_CENTER_SERVICE
  CDN
  CERTIFICATE
  CICD_SERVICE
  CLOUD_LOG_CONFIGURATION
  CLOUD_ORGANIZATION
  CLOUD_RESOURCE
  COMPUTE_INSTANCE_GROUP
  CONFIGURATION_FINDING
  CONFIGURATION_RULE
  CONFIGURATION_SCAN
  CONFIG_MAP
  CONTAINER
  CONTAINER_GROUP
  CONTAINER_IMAGE
  CONTAINER_INSTANCE_GROUP
  CONTAINER_REGISTRY
  CONTAINER_REPOSITORY
  CONTAINER_SERVICE
  CONTROLLER_REVISION
  DAEMON_SET
  DATABASE
  DATA_FINDING
  DATA_INVENTORY
  DATA_RESOURCE
  DATA_SCHEMA
  DATA_STORE
  DATA_WORKFLOW
  DATA_WORKLOAD
  DB_SERVER
  DEPLOYMENT
  DNS_RECORD
  DNS_ZONE
  DOMAIN
  EMAIL_SERVICE
  ENCRYPTION_KEY
  ENDPOINT
  EXCESSIVE_ACCESS_FINDING
  FILE_DESCRIPTOR
  FILE_DESCRIPTOR_FINDING
  FILE_SYSTEM_SERVICE
  FIREWALL
  GATEWAY
  GOVERNANCE_POLICY
  GOVERNANCE_POLICY_GROUP
  GROUP
  HOSTED_APPLICATION
  HOSTED_TECHNOLOGY
  HOST_CONFIGURATION_FINDING
  HOST_CONFIGURATION_RULE
  IAC_DECLARATION_INSTANCE
  IAC_RESOURCE_DECLARATION
  IAC_STATE_INSTANCE
  IAM_BINDING
  IDENTITY_PROVIDER
  IP_RANGE
  KUBERNETES_CLUSTER
  KUBERNETES_CRON_JOB
  KUBERNETES_INGRESS
  KUBERNETES_INGRESS_CONTROLLER
  KUBERNETES_JOB
  KUBERNETES_NETWORK_POLICY
  KUBERNETES_NODE
  KUBERNETES_PERSISTENT_VOLUME
  KUBERNETES_PERSISTENT_VOLUME_CLAIM
  KUBERNETES_POD_SECURITY_POLICY
  KUBERNETES_SERVICE
  KUBERNETES_STORAGE_CLASS
  KUBERNETES_VOLUME
  LAST_LOGIN
  LATERAL_MOVEMENT_FINDING
  LOAD_BALANCER
  LOCAL_USER
  MALWARE
  MALWARE_INSTANCE
  MANAGED_CERTIFICATE
  MANAGEMENT_SERVICE
  MAP_REDUCE_CLUSTER
  MESSAGING_SERVICE
  MONITOR_ALERT
  NAMESPACE
  NAT
  NETWORK_ADDRESS
  NETWORK_APPLIANCE
  NETWORK_INTERFACE
  NETWORK_ROUTING_RULE
  NETWORK_SECURITY_RULE
  PACKAGE
  PEERING
  POD
  PORT_RANGE
  PREDEFINED_GROUP
  PRINCIPAL
  PRIVATE_ENDPOINT
  PRIVATE_LINK
  PROJECT
  PROXY
  PROXY_RULE
  RAW_ACCESS_POLICY
  REGION
  REGISTERED_DOMAIN
  REPLICA_SET
  REPOSITORY
  REPOSITORY_BRANCH
  REPOSITORY_TAG
  RESOURCE_GROUP
  ROUTE_TABLE
  SEARCH_INDEX
  SECRET
  SECRET_CONTAINER
  SECRET_DATA
  SECRET_INSTANCE
  SECURITY_EVENT_FINDING
  SECURITY_TOOL_FINDING
  SECURITY_TOOL_FINDING_TYPE
  SECURITY_TOOL_SCAN
  SERVERLESS
  SERVERLESS_PACKAGE
  SERVICE_ACCOUNT
  SERVICE_CONFIGURATION
  SERVICE_USAGE_TECHNOLOGY
  SNAPSHOT
  STATEFUL_SET
  STORAGE_ACCOUNT
  SUBNET
  SUBSCRIPTION
  SWITCH
  TECHNOLOGY
  USER_ACCOUNT
  VIRTUAL_DESKTOP
  VIRTUAL_MACHINE
  VIRTUAL_MACHINE_IMAGE
  VIRTUAL_NETWORK
  VOLUME
  VULNERABILITY
  WEAKNESS
  WEB_SERVICE
}

scalar GraphEntityTypeValue

scalar GraphPropertyPredicate

enum GraphPropertyPredicateOperator {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  GREATER_THAN_OR_EQUALS
  LESS_THAN
  LESS_THAN_OR_EQUALS
  STARTS_WITH
  CONTAINS
  ENDS_WITH
  DOES_NOT_START_WITH
  DOES_NOT_END_WITH
  DOES_NOT_CONTAIN
  IS_SET
  IN_THE_LAST
  IN_THE_NEXT
  BEFORE_THE_LAST
  AFTER_THE_NEXT
  ALL_EQUALS
  ANY_NOT_EQUALS
  ALL_CONTAINS
  ALL_STARTS_WITH
  ALL_ENDS_WITH
  ANY_DOES_NOT_START_WITH
  ANY_DOES_NOT_END_WITH
  ANY_DOES_NOT_CONTAIN
  TAG_CONTAINS_ALL
  TAG_CONTAINS_ANY
  TAG_DOES_NOT_CONTAIN_ALL
  TAG_DOES_NOT_CONTAIN_ANY
  LIST_CONTAINS_ALL
  LIST_CONTAINS_ALL_SUBSTRING
  LIST_CONTAINS_ANY
  LIST_CONTAINS_ANY_SUBSTRING
  LIST_DOES_NOT_CONTAIN_ALL
  LIST_DOES_NOT_CONTAIN_ALL_SUBSTRING
  LIST_DOES_NOT_CONTAIN_ANY
  LIST_DOES_NOT_CONTAIN_ANY_SUBSTRING
  DATE_BEFORE
  DATE_AFTER
  DATE_BETWEEN
  CIDR_CONTAINS
  CIDR_DOES_NOT_CONTAIN
  PORT_RANGE_CONTAINS
  PORT_RANGE_DOES_NOT_CONTAIN
}

type GraphRelationship {
  from: GraphEntity!
  id: ID!
  to: GraphEntity!
  type: GraphRelationshipType!
}

type GraphRelationshipQuery {
  negate: Boolean
  optional: Boolean
  type: [GraphDirectedRelationshipType!]!
  with: GraphEntityQuery!
}

input GraphRelationshipQueryInput {
  type: [GraphDirectedRelationshipTypeInput!]!
  with: GraphEntityQueryInput!
  negate: Boolean
  optional: Boolean
}

enum GraphRelationshipType {
  ANY
  ANY_OUTGOING
  ACTING_AS
  ADMINISTRATE
  ALERTED_ON
  ALLOWS
  ALLOWS_ACCESS_TO
  APPLIES_TO
  ASSIGNED_TO
  ATTACHED_TO
  BEHIND
  BOOTS
  BUILT_FROM
  CAUSES
  COLLABORATES
  CONNECTED_TO
  CONTAINS
  CONTAINS_DST_IP_RANGE
  CONTAINS_DST_PORT_RANGE
  CONTAINS_SRC_IP_RANGE
  CONTAINS_SRC_PORT_RANGE
  DENIES
  DEPENDS_ON
  DEPLOYED_TO
  ENCRYPTS
  ENCRYPTS_PARTITION
  ENTITLES
  EXCLUDES
  EXPOSES
  GOVERNS
  HAS
  HAS_BOUNDARY_POLICY
  HAS_DATA_FINDING
  HAS_DATA_INVENTORY
  HAS_DATA_SCHEMA
  HAS_DATA_STORE
  HAS_ORGANIZATION_POLICY
  HAS_PRINCIPAL_POLICY
  HAS_RESOURCE_POLICY
  HAS_SNAPSHOT
  HAS_SOURCE
  HAS_STANDARD_WEB_ACCESS_FROM
  HAS_TECH
  HOSTS
  IGNORES
  IMPLEMENTS
  INCLUDES
  INFECTS
  INSIDE
  INSTANCE_OF
  INVOKES
  LOGS_DATA_FOR
  MANAGES
  MOUNTS
  OWNS
  PART_OF
  PEERED_TO
  PERFORMED
  PERFORMED_IMPERSONATED
  PERMITS
  POINTS_TO
  PROTECTS
  READS_DATA_FROM
  REFERENCED_BY
  REPLICA_OF
  ROUTES_TRAFFIC_FROM
  ROUTES_TRAFFIC_TO
  RUNS
  SCANNED
  SEND_MESSAGES_TO
  SERVES
  STORES_DATA_IN
  TRANSIT_PEERED_TO
  USES
  VALIDATES
}

input GraphSearchExportEntityOptions {
  entityType: GraphEntityTypeValue!
  propertyOptions: [GraphSearchExportPropertyOptions!]!
}

input GraphSearchExportPropertyOptions {
  key: String!
}

enum GraphSearchExportType {
  NORMAL_LIMITED
  NORMAL
  EMBEDDED_JSON
  FINDINGS
}

type GraphSearchResult {
  aggregateCount: Int
  entities: [GraphEntity]!
}

type GraphSearchResultConnection {
  edges: [GraphSearchResultEdge!]
  exportUrl(entityOptions: [GraphSearchExportEntityOptions!], format: ExportFormats = CSV, limit: Int = 1000, type: GraphSearchExportType = NORMAL_LIMITED): String
  maxCountReached: Boolean!
  nodes: [GraphSearchResult!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type GraphSearchResultEdge {
  cursor: String!
  node: GraphSearchResult!
}

type HostConfigurationRule implements Node {
  analytics: HostConfigurationRuleAnalytics!
  builtin: Boolean!
  description: String
  directOVAL: String
  enabled: Boolean!
  externalId: String
  id: ID!
  name: String!
  projects: [Project]
  remediationInstructions: String
  ruleTargetPlatforms: [HostConfigurationRuleTargetPlatform!]! @deprecated(reason: "use targetOperatingSystems/targetTechnologies instead")
  securitySubCategories: [SecuritySubCategory!]
  severity: Severity!
  shortName: String!
  targetOperatingSystems: [HostConfigurationRuleTargetPlatform!]
  targetPlatforms: [Technology!]! @deprecated(reason: "use targetOperatingSystems/targetTechnologies instead")
  targetTechnologies: [HostConfigurationRuleTargetPlatform!]
}

type HostConfigurationRuleAnalytics {
  errorCount: Int!
  failCount: Int!
  notAssessedCount: Int!
  passCount: Int!
  totalCount: Int!
}

type HostConfigurationRuleAssessment implements Node {
  hasGraphObject: Boolean!
  id: ID!
  ignoreRules: [IgnoreRule]
  note: HostConfigurationRuleAssessmentNote
  resolutionReason: FindingResolutionReason
  resource: HostConfigurationRuleAssessmentResource!
  result: HostConfigurationRuleAssessmentResult!
  rule: HostConfigurationRule!
  status: FindingCommonStatus!
  updatedAt: DateTime!
}

type HostConfigurationRuleAssessmentConnection {
  edges: [HostConfigurationRuleAssessmentEdge!]
  maxCountReached: Boolean!
  nodes: [HostConfigurationRuleAssessment!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type HostConfigurationRuleAssessmentEdge {
  cursor: String!
  node: HostConfigurationRuleAssessment!
}

enum HostConfigurationRuleAssessmentField {
  ID
  ANALYZED_AT
  FIRST_SEEN_AT
}

input HostConfigurationRuleAssessmentFilters {
  rule: [String!]
  resource: HostConfigurationRuleAssessmentResourceFilters
  result: [HostConfigurationRuleAssessmentResult!]
  frameworkCategory: [String!]
  severity: [Severity!]
  status: [FindingCommonStatus!]
}

type HostConfigurationRuleAssessmentNote implements Node {
  createdAt: DateTime!
  id: ID!
  serviceAccount: ServiceAccount
  text: String!
  updatedAt: DateTime!
  user: User
}

input HostConfigurationRuleAssessmentOrder {
  direction: OrderDirection!
  field: HostConfigurationRuleAssessmentField!
}

type HostConfigurationRuleAssessmentResource implements Node {
  cloudPlatform: String!
  id: ID!
  name: String!
  nativeType: String!
  status: HostConfigurationRuleAssessmentResourceStatus!
  subscription: CloudAccount
  type: GraphEntityTypeValue!
}

input HostConfigurationRuleAssessmentResourceFilters {
  id: [String!]
  type: [GraphEntityTypeValue!]
  projectId: [String!]
  status: [HostConfigurationRuleAssessmentResourceStatus!]
  subscriptionId: [String!]
  cloudPlatform: [String!]
  nativeType: [String!]
}

enum HostConfigurationRuleAssessmentResourceStatus {
  Active
  Inactive
  Error
}

enum HostConfigurationRuleAssessmentResult {
  PASS
  FAIL
  ERROR
  NOT_ASSESSED
}

type HostConfigurationRuleConnection {
  edges: [HostConfigurationRuleEdge!]
  nodes: [HostConfigurationRule!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum HostConfigurationRuleCreatorType {
  USER
  BUILT_IN
}

type HostConfigurationRuleEdge {
  cursor: String!
  node: HostConfigurationRule!
}

input HostConfigurationRuleFilters {
  search: String
  shortName: [String!]
  enabled: Boolean
  frameworkCategory: [String!]
  targetPlatforms: [String!]
  hasTargetOperatingSystems: Boolean
  targetOperatingSystems: [String!]
  hasTargetTechnologies: Boolean
  targetTechnologies: [String!]
  severity: [Severity!]
  createdBy: [HostConfigurationRuleCreatorType!]
  riskEqualsAny: [String!]
  riskEqualsAll: [String!]
  id: [String!]
}

input HostConfigurationRuleOrder {
  direction: OrderDirection!
  field: HostConfigurationRuleOrderField!
}

enum HostConfigurationRuleOrderField {
  FAILED_CHECK_COUNT
  NAME
}

type HostConfigurationRuleTargetPlatform implements Node {
  displayName: String!
  id: ID!
  technology: Technology!
  version: String
}

input HostConfigurationRuleTargetPlatformFilters {
  category: [HostConfigurationTargetPlatformCategory!]
  search: String
}

enum HostConfigurationTargetPlatformCategory {
  OPERATING_SYSTEM
  TECHNOLOGY
}

type HostConfigurationTargetPlatformConnection {
  edges: [HostConfigurationTargetPlatformEdge!]
  nodes: [HostConfigurationRuleTargetPlatform!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type HostConfigurationTargetPlatformEdge {
  cursor: String!
  node: HostConfigurationRuleTargetPlatform!
}

input HostConfigurationTargetPlatformsFilters {
  customRuleSupported: Boolean
}

type IaCFileConversionResult {
  resourceJSONs: [JSON!]!
}

type IACScanMatch {
  expected: String!
  failedPolicies: [CICDScanPolicyMatch!]!
  fileName: String!
  found: String!
  lineNumber: Int!
  matchContent: String!
  resourceName: String!
}

type IACScanRuleResult {
  failedPolicyMatches: [CICDScanPolicyMatch!]!
  failedResourceCount: Int!
  matches: [IACScanMatch!]
  rule: CloudConfigurationRule
  severity: IACScanSeverity!
}

enum IACScanSeverity {
  INFORMATIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type IACScanStatistics {
  criticalMatches: Int!
  filesFound: Int!
  filesParsed: Int!
  highMatches: Int!
  infoMatches: Int!
  lowMatches: Int!
  mediumMatches: Int!
  queriesExecuted: Int!
  queriesExecutionFailed: Int!
  queriesLoaded: Int!
}

type IgnoreRule implements Node {
  cloudConfigurationRules: [CloudConfigurationRule!]
  conditions: IgnoreRuleConditions!
  createdAt: DateTime!
  createdBy: User
  description: String!
  disabledOnCloudScanning: Boolean!
  enabled: Boolean!
  expiredAt: DateTime
  findingIgnoreReason: FindingResolutionReason!
  findingType: IgnoreRuleFindingType!
  hostConfigurationRules: [HostConfigurationRule!]
  id: ID!
  name: String!
  project: Project
  vulnerabilities: [Vulnerability!]
}

type IgnoreRuleCloudConfigurationFindingConditions {
  frameworkCategory: [String!]
  severity: [FindingSeverity!]
}

input IgnoreRuleCloudConfigurationFindingConditionsInput {
  frameworkCategory: [String!]
  severity: [FindingSeverity!]
}

type IgnoreRuleConditions {
  cloudConfigurationFinding: IgnoreRuleCloudConfigurationFindingConditions
  hostConfigurationFinding: IgnoreRuleHostConfigurationFindingConditions
  resource: IgnoreRuleResourceConditions
  vulnerabilityFinding: IgnoreRuleVulnerabilityFindingConditions
}

type IgnoreRuleConnection {
  edges: [IgnoreRuleEdge!]
  nodes: [IgnoreRule!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IgnoreRuleEdge {
  cursor: String!
  node: IgnoreRule!
}

input IgnoreRuleFilters {
  id: [String!]
  search: String
  findingType: [IgnoreRuleFindingType!]
  disabledOnCloudScanning: Boolean
  expiredAt: DateTime
  createdAt: CommonDateFilter
  updatedAt: CommonDateFilter
  enabled: Boolean
}

enum IgnoreRuleFindingType {
  ANY
  CLOUD_CONFIGURATION
  HOST_CONFIGURATION
  VULNERABILITY
}

type IgnoreRuleHostConfigurationFindingConditions {
  frameworkCategory: [String!]
  severity: [FindingSeverity!]
}

input IgnoreRuleHostConfigurationFindingConditionsInput {
  frameworkCategory: [String!]
  severity: [FindingSeverity!]
}

type IgnoreRuleResourceConditions {
  cloudAccount: [CloudAccount]
  id: [GraphEntity]
  name: [String!]
  namespace: [String!]
  region: [String!]
  tag: [IgnoreRuleResourceTagsType!]
}

input IgnoreRuleResourceConditionsInput {
  id: [String!]
  name: [String!]
  cloudAccount: [String!]
  region: [String!]
  tag: [IgnoreRuleResourceTagsInputType!]
  namespace: [String!]
}

input IgnoreRuleResourceTagsInputType {
  key: String!
  value: String
}

type IgnoreRuleResourceTagsType {
  key: String!
  value: String
}

type IgnoreRuleVulnerabilityFindingConditions {
  detectionMethod: [VulnerabilityDetectionMethod!]
  fixedVersion: [String!]
  hasCisaKevExploit: Boolean
  hasExploit: Boolean
  hasFix: Boolean
  path: [String!]
  severity: [VulnerabilitySeverity!]
}

input IgnoreRuleVulnerabilityFindingConditionsInput {
  hasExploit: Boolean
  hasCisaKevExploit: Boolean
  fixedVersion: [String!]
  hasFix: Boolean
  severity: [VulnerabilitySeverity!]
  detectionMethod: [VulnerabilityDetectionMethod!]
  path: [String!]
}

input InitiateDiskScanContainerImageInput {
  requestID: String
  name: String!
  projectID: ID
}

type InitiateDiskScanContainerImagePayload {
  token: String!
  uploadURL: String!
}

input InitiateDiskScanVirtualMachineImageInput {
  region: String!
  subscriptionID: ID!
  connectorName: String
  resourceID: ID!
  projectID: ID
}

type InitiateDiskScanVirtualMachineImagePayload {
  token: String!
}

input InitiateDiskScanVirtualMachineInput {
  resourceID: String!
  projectID: ID
}

type InitiateDiskScanVirtualMachinePayload {
  token: String!
}

input initiateIACScanInput {
  requestID: String!
  name: String!
  types: [CloudConfigurationRuleMatcherType!]
  projectID: ID
}

type initiateIACScanPayload {
  token: String!
  uploadURL: String!
}

type Integration implements Node {
  createdAt: DateTime!
  id: ID!
  isAccessibleToAllProjects: Boolean
  name: String!
  params: IntegrationParams!
  project: Project
  type: IntegrationType!
  updatedAt: DateTime!
  usedByRules: [AutomationRule!]!
}

type IntegrationActionTestResult {
  reason: String
  success: Boolean!
}

type IntegrationConnection {
  edges: [IntegrationEdge!]
  nodes: [Integration!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IntegrationEdge {
  cursor: String!
  node: Integration!
}

input IntegrationFilters {
  search: String
  type: [IntegrationType!]
  projectId: String
}

union IntegrationParams = AwsSNSIntegrationParams | AzureServiceBusIntegrationParams | GcpPubSubIntegrationParams | JiraIntegrationParams | PagerDutyIntegrationParams | ServiceNowIntegrationParams | WebhookIntegrationParams | SlackIntegrationParams | SlackBotIntegrationParams | OpsgenieIntegrationParams | ClickUpIntegrationParams

input IntegrationTLSConfigInput {
  allowInsecureTLS: Boolean
  serverCA: String
  clientCertificateAndPrivateKey: String
}

enum IntegrationType {
  AWS_SECURITY_HUB
  AWS_SNS
  AZURE_DEVOPS
  AZURE_LOGIC_APPS
  AZURE_SENTINEL
  AZURE_SERVICE_BUS
  CISCO_WEBEX
  CORTEX_XSOAR
  CYWARE
  EMAIL
  AWS_EVENT_BRIDGE
  GOOGLE_CHAT
  GCP_PUB_SUB
  JIRA
  MICROSOFT_TEAMS
  PAGER_DUTY
  SERVICE_NOW
  SLACK
  SLACK_BOT
  SPLUNK
  SUMO_LOGIC
  TORQ
  WEBHOOK
  FRESHSERVICE
  OPSGENIE
  TINES
  HUNTERS
  CLICK_UP
}

scalar IntegrationTypeValue

type IPRestrictions {
  allowedIPs: [String!]!
}

type Issue implements Node {
  connector: Connector
  control: Control!
  createdAt: DateTime!
  description: String!
  dueAt: DateTime
  entity: GraphEntity
  entitySnapshot: IssueEntitySnapshot!
  evidenceQuery: GraphEntityQueryValue!
  id: ID!
  note: String @deprecated(reason: "Deprecated property, use notes")
  notes: [IssueNote!]
  project: Project @deprecated(reason: "Deprecated property")
  projects: [Project]
  rejectionExpiredAt: DateTime
  resolutionReason: IssueResolutionReason
  resolvedAt: DateTime
  serviceTicket: ServiceTicket @deprecated(reason: "Deprecated property, use serviceTickets")
  serviceTickets: [ServiceTicket!]
  severity: Severity!
  status: IssueStatus!
  statusChangedAt: DateTime
  updatedAt: DateTime!
}

type IssueAnalytics {
  criticalSeverityCount: Int!
  highSeverityCount: Int!
  informationalSeverityCount: Int!
  issueCount: Int!
  lowSeverityCount: Int!
  mediumSeverityCount: Int!
  scopeSize: Int!
}

type IssueConnection {
  criticalSeverityCount: Int!
  edges: [IssueEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 5000): String
  highSeverityCount: Int!
  informationalSeverityCount: Int!
  lowSeverityCount: Int!
  mediumSeverityCount: Int!
  nodes: [Issue!]
  pageInfo: PageInfo!
  totalCount: Int!
  uniqueEntityCount: Int!
}

input IssueDateFilter {
  before: DateTime
  after: DateTime
  inLast: DurationFilter
  beforeLast: DurationFilter
}

type IssueEdge {
  cursor: String!
  node: Issue!
}

input IssueEntityFilters {
  id: String
  ids: [String!]
  type: [GraphEntityTypeValue!]
  status: [CloudResourceStatus!]
  region: [String!]
  subscriptionId: [String!]
  resourceGroupId: [String!]
  nativeType: [String!]
  cloudPlatform: [CloudPlatform!]
  tag: IssueEntityTagFilter
}

type IssueEntitySnapshot {
  cloudPlatform: CloudPlatform
  cloudProviderURL: String
  externalId: String
  id: String!
  name: String!
  nativeType: String
  providerId: String
  region: String
  resourceGroupExternalId: String
  resourceGroupId: String
  status: CloudResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  subscriptionName: String
  subscriptionTags: JSON
  tags: JSON
  type: GraphEntityTypeValue!
}

input IssueEntityTag {
  key: String!
  value: String
}

input IssueEntityTagFilter {
  containsAll: [IssueEntityTag!]
  containsAny: [IssueEntityTag!]
  doesNotContainAll: [IssueEntityTag!]
  doesNotContainAny: [IssueEntityTag!]
}

type IssueEvidenceMeta {
  moreResultsOutOfScope(project: ID!): Boolean!
}

input IssueFilters {
  id: [String!]
  search: String
  securityFramework: [String!]
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
  stackLayer: [TechnologyStackLayer!]
  project: [String!]
  severity: [Severity!]
  status: [IssueStatus!]
  relatedEntity: IssueEntityFilters
  sourceSecurityScan: String
  sourceControl: [String!]
  createdAt: IssueDateFilter
  resolvedAt: IssueDateFilter
  resolutionReason: [IssueResolutionReason!]
  dueAt: IssueDateFilter
  hasServiceTicket: Boolean
  hasNote: Boolean
  hasRemediation: Boolean
  hasAutoRemediation: Boolean
  sourceControlType: [ControlType!]
  statusChangedAt: IssueDateFilter
  riskEqualsAny: [String!]
  riskEqualsAll: [String!]
  hasDueDate: Boolean
  hasUserNote: Boolean
  noteContains: String
}

type IssueNote implements Node {
  createdAt: DateTime!
  id: ID!
  serviceAccount: ServiceAccount
  text: String!
  updatedAt: DateTime!
  user: User
}

input IssueOrder {
  direction: OrderDirection!
  field: IssueOrderField!
}

enum IssueOrderField {
  ID
  SEVERITY
  CREATED_AT
  RESOLVED_AT
  STATUS_CHANGED_AT
}

enum IssueReportType {
  STANDARD
  DETAILED
}

enum IssueResolutionReason {
  OBJECT_DELETED
  ISSUE_FIXED
  CONTROL_CHANGED
  CONTROL_DISABLED
  CONTROL_DELETED
  FALSE_POSITIVE
  EXCEPTION
  WONT_FIX
}

type IssueSettings {
  daysToResolution: [IssueSettingsDaysToResolutionConfig!]!
  requireNoteOnRejection: Boolean!
}

type IssueSettingsDaysToResolutionConfig {
  criteria: IssueSettingsDaysToResolutionIssueCriteria!
  days: Int!
}

input IssueSettingsDaysToResolutionConfigInput {
  criteria: IssueSettingsDaysToResolutionIssueCriteriaInput!
  days: Int!
}

type IssueSettingsDaysToResolutionIssueCriteria {
  projectBusinessImpact: BusinessImpact
  severity: Severity
}

input IssueSettingsDaysToResolutionIssueCriteriaInput {
  projectBusinessImpact: BusinessImpact
  severity: Severity
}

type IssuesGroupedByCloudAccount implements Node {
  cloudAccount: CloudAccount!
  id: ID!
  issues(after: String, filterBy: IssueFilters, first: Int, orderBy: IssueOrder): IssueConnection!
}

type IssuesGroupedByCloudAccountConnection {
  edges: [IssuesGroupedByCloudAccountEdge!]
  nodes: [IssuesGroupedByCloudAccount!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IssuesGroupedByCloudAccountEdge {
  cursor: String!
  node: IssuesGroupedByCloudAccount!
}

input IssuesGroupedByCloudAccountFilters {
  search: String
  project: [String!]
  issueFilters: IssueFilters
}

input IssuesGroupedByCloudAccountOrder {
  direction: OrderDirection!
  field: IssuesGroupedByCloudAccountOrderField!
}

enum IssuesGroupedByCloudAccountOrderField {
  ISSUE_COUNT
}

type IssuesGroupedByEntity implements Node {
  entity: GraphEntity
  id: ID!
  issues(after: String, filterBy: IssueFilters, first: Int, orderBy: IssueOrder): IssueConnection!
}

type IssuesGroupedByEntityConnection {
  edges: [IssuesGroupedByEntityEdge!]
  nodes: [IssuesGroupedByEntity!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IssuesGroupedByEntityEdge {
  cursor: String!
  node: IssuesGroupedByEntity!
}

input IssuesGroupedByEntityFilters {
  search: String
  project: [String!]
  entityType: [GraphEntityTypeValue!]
  issueFilters: IssueFilters
}

input IssuesGroupedByEntityOrder {
  direction: OrderDirection!
  field: IssuesGroupedByEntityOrderField!
}

enum IssuesGroupedByEntityOrderField {
  ISSUE_COUNT
  SEVERITY
}

enum IssuesIntegrationRunStatus {
  IN_PROGRESS
  COMPLETED
}

enum IssueStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  REJECTED
}

type IssuesTrendDataPoint {
  count: Int!
  time: DateTime!
}

type IssuesTrendDataSeries {
  dataPoints: [IssuesTrendDataPoint!]!
  total: Int!
  type: IssueTrendSeriesType!
}

enum IssueTrendSeriesType {
  OPEN
  CREATED
  RESOLVED
}

enum IssueTrendType {
  OPEN
  CREATED_VS_RESOLVED
}

type JiraActionAddCommentTemplateParams {
  addIssuesReport: Boolean!
  comment: String!
  projectKey: String
}

input JiraActionAddCommentTemplateParamsInput {
  projectKey: String
  comment: String!
  addIssuesReport: Boolean!
}

type JiraActionCreateTicketTemplateParams {
  fields: JiraTicketFields!
}

input JiraActionCreateTicketTemplateParamsInput {
  fields: CreateJiraTicketFieldsInput!
}

type JiraActionTransitionTicketTemplateParams {
  advancedFields: JSON
  attachEvidenceCSV: Boolean
  comment: String
  commentOnTransition: Boolean
  project: String!
  transitionId: String!
}

input JiraActionTransitionTicketTemplateParamsInput {
  project: String!
  transitionId: String!
  advancedFields: JSON
  comment: String
  commentOnTransition: Boolean
  attachEvidenceCSV: Boolean
}

union JiraAutomationActionAuthentication = JiraAutomationActionAuthenticationBasic | JiraAutomationActionAuthenticationTokenBearer

type JiraAutomationActionAuthenticationBasic {
  password: String!
  username: String!
}

type JiraAutomationActionAuthenticationTokenBearer {
  token: String!
}

type JiraAutomationActionParams {
  isOnPrem: Boolean!
  jiraAuthentication: JiraAutomationActionAuthentication!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  serverUrl: String!
  ticketFields: JiraTicketFields!
  tlsConfig: AutomationActionTLSConfig
  token: String @deprecated(reason: "Use authentication")
  user: String @deprecated(reason: "Use authentication")
}

union JiraIntegrationAuthorization = JiraIntegrationBasicAuthorization | JiraIntegrationTokenBearerAuthorization

input JiraIntegrationAuthorizationInput {
  username: String
  password: String
  personalAccessToken: String
}

type JiraIntegrationBasicAuthorization {
  password: String!
  username: String!
}

type JiraIntegrationParams {
  authorization: JiraIntegrationAuthorization!
  onPremConfig: OnPremIntegrationConfig
  serverType: JiraServerType!
  tlsConfig: AutomationActionTLSConfig
  url: String!
}

type JiraIntegrationTokenBearerAuthorization {
  token: String!
}

enum JiraServerType {
  CLOUD
  SELF_HOSTED
}

type JiraTicketFields {
  alternativeDescriptionField: String
  assignee: String
  attachEvidenceCSV: Boolean
  components: [String!]
  customFields: JSON
  description: String!
  fixVersion: [String!]
  issueType: String!
  labels: [String!]
  priority: String
  project: String!
  summary: String!
}

type JiraTransitionAutomationActionParams {
  comment: String
  commentOnTransition: Boolean
  fields: JSON
  isOnPrem: Boolean!
  jiraAuthentication: JiraAutomationActionAuthentication!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  project: String!
  serverUrl: String!
  tlsConfig: AutomationActionTLSConfig
  token: String @deprecated(reason: "Use authentication")
  transitionId: String!
  user: String @deprecated(reason: "Use authentication")
}

scalar JSON

union KnownErrors = ErrorBadUserInput | ErrorUnauthorizedAction

type KubernetesCluster implements Node {
  admissionController: AdmissionController
  cloudAccount: CloudAccount
  connectors: [Connector!]
  containerCount: Int
  containerImageCount: Int
  externalId: String!
  id: ID!
  isConnectedUsingBroker: Boolean
  isPrivate: Boolean!
  kind: KubernetesClusterKind!
  lastScannedAt: DateTime
  name: String!
  nodeCount: Int
  projects: [Project!]
  status: KubernetesClusterStatus!
}

type KubernetesClusterConnection {
  edges: [KubernetesClusterEdge!]
  nodes: [KubernetesCluster!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum KubernetesClusterConnectionType {
  AUTOMATIC
  STANDALONE
}

type KubernetesClusterEdge {
  cursor: String!
  node: KubernetesCluster!
}

input KubernetesClusterFilters {
  search: String
  kind: [KubernetesClusterKind!]
  status: [KubernetesClusterStatus!]
  projectId: String
  assignedToProject: Boolean
  cloudAccount: [String!]
  connectorId: [String!]
  connectionType: [KubernetesClusterConnectionType!]
  usingBroker: Boolean
  usingAdmissionController: Boolean
}

enum KubernetesClusterKind {
  EKS
  GKE
  AKS
  OKE
  OPEN_SHIFT
  SELF_HOSTED
}

enum KubernetesClusterStatus {
  CONNECTED
  ERROR
  DISABLED
  INITIAL_SCANNING
  PARTIALLY_CONNECTED
  DISCONNECTED
}

enum KubernetesFlavor {
  AKS
  EKS
  GKE
  OKE
  OPEN_SHIFT
  SELF_HOSTED
}

type KubernetesPath implements Node {
  id: ID!
  path: [GraphEntity]!
}

type KubernetesPathConnection {
  edges: [KubernetesPathEdge!]
  maxCountReached: Boolean!
  nodes: [KubernetesPath!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type KubernetesPathEdge {
  cursor: String!
  node: KubernetesPath!
}

type LateralMovementPath implements Node {
  cloudPlatforms: [CloudPlatform!]!
  id: ID!
  isCrossCloud: Boolean!
  isCrossOrganization: Boolean!
  isCrossSubscription: Boolean!
  isFromExternalOrganization: Boolean!
  isFromPublicAccess: Boolean!
  isFromPubliclyExposedComputeResource: Boolean!
  partialPath: Boolean!
  path: [GraphEntity]! @deprecated(reason: "Use pathEntities property instead")
  pathEntities: [LateralMovementPathStep!]!
  severity: LateralMovementSeverity!
  sourceParent: GraphEntity
  targetParent: GraphEntity
  type: LateralMovementPathType!
}

type LateralMovementPathConnection {
  edges: [LateralMovementPathEdge!]
  maxCountReached: Boolean!
  nodes: [LateralMovementPath!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type LateralMovementPathEdge {
  cursor: String!
  node: LateralMovementPath!
}

input LateralMovementPathEntityFilter {
  id: [String!]
  type: [GraphEntityTypeValue!]
  nativeType: [String!]
  subscriptionId: [String!]
  negate: Boolean
}

input LateralMovementPathFilters {
  projectId: [String!]
  type: [LateralMovementPathType!]
  severity: [LateralMovementSeverity!]
  isFromPublicAccess: Boolean
  isFromExternalOrganization: Boolean
  isFromPubliclyExposedComputeResource: Boolean
  isCrossCloud: Boolean
  isCrossOrganization: Boolean
  isCrossSubscription: Boolean
  cloudPlatform: [CloudPlatform!]
  source: LateralMovementPathEntityFilter
  target: LateralMovementPathEntityFilter
}

type LateralMovementPathStep {
  description: String
  entity: GraphEntity
  remediation: String
  type: LateralMovementStepType
}

enum LateralMovementPathType {
  ESCALATION_TO_ADMIN
  ESCALATION_TO_KUBERNETES_ADMIN
  ACCESS_TO_SENSITIVE_DATA
}

enum LateralMovementSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum LateralMovementStepType {
  IMPERSONATE_PRINCIPAL
  COMPUTE_RESOURCE_ACTING_AS_PRINCIPAL
  LOGIN_USING_CLOUD_KEY
  CONTAINS_CLOUD_KEY
  DATA_ACCESS
}

type LayerMetadata {
  details: String
  id: ID!
  isBaseLayer: Boolean!
}

enum License {
  GNU_AGPLV3
  GNU_GPLV2
  GNU_GPLV3
  GNU_LGPLV21
  GNU_LGPLV3
  APACHE_LICENSE_2
  MOZILLA_PUBLIC_LICENSE_2
  MIT_LICENSE
  THE_UNLICENSE
  ZLIB_LICENSE
  ZERO_CLAUSE_BSD
  FREEBSD_LICENSE
  NEW_BSD_LICENSE
  BSD_LICENSE
  MS_PL
}

type LoginInfo {
  clientId: String!
  defaultConnectionName: String
}

type LoginSettings {
  approvedUserDomains: [String!]!
}

type MalwareExclusion {
  createdBy: User!
  fileExtensions: [String!]
  fileNames: [String!]
  id: ID!
  name: String
  paths: [String!]
  resources: [GraphEntity!]
}

type MalwareExclusionConnection {
  edges: [MalwareExclusionEdge!]
  nodes: [MalwareExclusion!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type MalwareExclusionEdge {
  cursor: String!
  node: MalwareExclusion!
}

enum ManualIntegrationRunStatus {
  IN_PROGRESS
  COMPLETED
}

input ManualNetworkOutpostClusterAWSConfigInput {
  vpcId: String!
  subnetIds: [String!]!
  securityGroupIds: [String!]!
}

input ManualNetworkOutpostClusterAzureConfigInput {
  resourceGroupName: String!
  vnetId: String!
  subnetId: String!
  dnsServiceIp: String
  serviceCIDR: String
  serviceAuthorizedIPRanges: [String!]
}

input ManualNetworkOutpostClusterInput {
  perCloudConfig: PerCloudManualNetworkOutpostClusterConfigInput!
}

type MigrateUsersPayload {
  success: Boolean!
}

type Mutation {
  addSecurityScan(input: AddSecurityScanInput!): AddSecurityScanPayload!
  associateServiceTicket(input: AssociateServiceTicketInput!): AssociateServiceTicketPayload!
  clearUIUserPreferences(input: ClearUIUserPreferencesInput!): ClearUIUserPreferencesPayload!
  completeAuthMigration: CompleteAuthMigrationStatusPayload!
  createActionTemplate(input: CreateActionTemplateInput!): CreateActionTemplatePayload
  createAutomationRule(input: CreateAutomationRuleInput!): CreateAutomationRulePayload!
  createCICDScanPolicy(input: CreateCICDScanPolicyInput!): CreateCICDScanPolicyPayload!
  createCloudConfigurationRule(input: CreateCloudConfigurationRuleInput!): CreateCloudConfigurationRulePayload!
  createCloudEventRule(input: CreateCloudEventRuleInput!): CreateCloudEventRulePayload!
  createComputeGroupTagsSet(input: CreateComputeGroupTagsSetInput!): CreateComputeGroupTagsSetPayload!
  createConnector(input: CreateConnectorInput!): CreateConnectorPayload!
  createControl(input: CreateControlInput!): CreateControlPayload!
  createCustomIPRange(input: CreateCustomIPRangeInput!): CreateCustomIPRangePayload!
  createDataClassifier(input: CreateDataClassifierInput!): CreateDataClassifierPayload!
  createFileIntegrityMonitoringExclusion(input: CreateFileIntegrityMonitoringExclusionInput!): CreateFileIntegrityMonitoringExclusionPayload!
  createHostConfigurationRule(input: CreateHostConfigurationRuleInput!): CreateHostConfigurationRulePayload!
  createIgnoreRule(input: CreateIgnoreRuleInput!): CreateIgnoreRulePayload!
  createIntegration(input: CreateIntegrationInput!): CreateIntegrationPayload!
  createIssueNote(input: CreateIssueNoteInput!): CreateIssueNotePayload!
  createMalwareExclusion(input: CreateMalwareExclusionInput!): CreateMalwareExclusionPayload!
  createOutpost(input: CreateOutpostInput!): CreateOutpostPayload!
  createOutpostCluster(input: CreateOutpostClusterInput!): CreateOutpostClusterPayload!
  createProject(input: CreateProjectInput!): CreateProjectPayload!
  createReport(input: CreateReportInput!): CreateReportPayload!
  createSAMLIdentityProvider(input: CreateSAMLIdentityProviderInput!): CreateSAMLIdentityProviderPayload!
  createSAMLUser(input: CreateSAMLUserInput!): CreateSAMLUserPayload!
  createSavedCloudEventFilter(input: CreateSavedCloudEventFilterInput!): CreateSavedCloudEventFilterPayload!
  createSavedGraphQuery(input: CreateSavedGraphQueryInput!): CreateSavedGraphQueryPayload!
  createScannerAPIRateLimit(input: CreateScannerAPIRateLimitInput!): CreateScannerAPIRateLimitPayload!
  createSecurityFramework(input: CreateSecurityFrameworkInput!): CreateSecurityFrameworkPayload!
  createServiceAccount(input: CreateServiceAccountInput!): CreateServiceAccountPayload!
  createSupportTicket(input: CreateSupportTicketInput!): CreateSupportTicketPayload!
  createUser(input: CreateUserInput!): CreateUserPayload!
  deleteActionTemplate(input: DeleteActionTemplateInput!): DeleteActionTemplatePayload
  deleteAutomationRule(input: DeleteAutomationRuleInput!): DeleteAutomationRulePayload!
  deleteCICDScan(input: DeleteCICDScanInput!): DeleteCICDScanPayload!
  deleteCICDScanPolicy(input: DeleteCICDScanPolicyInput!): DeleteCICDScanPolicyPayload!
  deleteCloudConfigurationRule(input: DeleteCloudConfigurationRuleInput!): DeleteCloudConfigurationRulePayload!
  deleteCloudEventRule(input: DeleteCloudEventRuleInput!): DeleteCloudEventRulePayload!
  deleteComputeGroupTagsSet(input: DeleteComputeGroupTagsSetInput): DeleteComputeGroupTagsSetPayload!
  deleteConnector(input: DeleteConnectorInput!): DeleteConnectorPayload!
  deleteControl(input: DeleteControlInput!): DeleteControlPayload!
  deleteCustomIPRange(input: DeleteCustomIPRangeInput!): DeleteCustomIPRangePayload!
  deleteDataClassifier(input: DeleteDataClassifierInput!): DeleteDataClassifierPayload!
  deleteFileIntegrityMonitoringExclusion(input: DeleteFileIntegrityMonitoringExclusionInput!): DeleteFileIntegrityMonitoringExclusionPayload!
  deleteHostConfigurationRule(input: DeleteHostConfigurationRuleInput!): DeleteHostConfigurationRulePayload!
  deleteIgnoreRule(input: DeleteIgnoreRuleInput!): DeleteIgnoreRulePayload!
  deleteIntegration(input: DeleteIntegrationInput!): DeleteIntegrationPayload!
  deleteIssueNote(input: DeleteIssueNoteInput!): DeleteIssueNotePayload!
  deleteMalwareExclusion(input: DeleteMalwareExclusionInput!): DeleteMalwareExclusionPayload!
  deleteOutpost(input: DeleteOutpostInput!): DeleteOutpostPayload!
  deleteOutpostCluster(input: DeleteOutpostClusterInput!): DeleteOutpostClusterPayload!
  deleteReport(input: DeleteReportInput!): DeleteReportPayload!
  deleteSAMLIdentityProvider(input: DeleteSAMLIdentityProviderInput!): DeleteSAMLIdentityProviderPayload!
  deleteSavedCloudEventFilter(input: DeleteSavedCloudEventFilterInput!): DeleteSavedCloudEventFilterPayload!
  deleteSavedGraphQuery(input: DeleteSavedGraphQueryInput!): DeleteSavedGraphQueryPayload!
  deleteScannerAPIRateLimit(id: ID!): DeleteScannerAPIRateLimitPayload!
  deleteSecurityFramework(input: DeleteSecurityFrameworkInput!): DeleteSecurityFrameworkPayload!
  deleteSecurityScan(input: DeleteSecurityScanInput!): DeleteSecurityScanPayload!
  deleteServiceAccount(input: DeleteServiceAccountInput!): DeleteServiceAccountPayload!
  deleteUser(input: DeleteUserInput!): DeleteUserPayload!
  disassociateServiceTicket(serviceTicketId: ID!): DisassociateServiceTicketPayload!
  duplicateHostConfigurationRule(input: DuplicateHostConfigurationRuleInput!): DuplicateHostConfigurationRulePayload!
  duplicateSecurityFramework(input: DuplicateSecurityFrameworkInput!): DuplicateSecurityFrameworkPayload!
  finalizeCICDScan(input: FinalizeCICDScanInput!): CICDScan!
  generateWizContainerRegistryToken(input: GenerateWizContainerRegistryTokenInput): GenerateWizContainerRegistryTokenPayload!
  initiateDiskScanContainerImage(input: InitiateDiskScanContainerImageInput!): InitiateDiskScanContainerImagePayload!
  initiateDiskScanVirtualMachine(input: InitiateDiskScanVirtualMachineInput!): InitiateDiskScanVirtualMachinePayload!
  initiateDiskScanVirtualMachineImage(input: InitiateDiskScanVirtualMachineImageInput!): InitiateDiskScanVirtualMachineImagePayload!
  initiateIACScan(input: initiateIACScanInput!): initiateIACScanPayload!
  migrateUsers: MigrateUsersPayload!
  reassessIssue(input: ReassessIssueInput!): ReassessIssuePayload!
  RegisterAgent(input: RegisterAgentInput!): RegisterAgentPayload!
  requestConnectorEntityScan(input: RequestConnectorEntityScanInput!): RequestScanPayload
  requestConnectorScan(input: RequestConnectorScanInput!): RequestScanPayload
  rerunReport(input: RerunReportInput!): RerunReportPayload!
  resetUserPassword(input: ResetUserPasswordInput!): ResetUserPasswordPayload!
  rotateServiceAccountSecret(ID: String!): RotateServiceAccountSecretPayload!
  runAllControls: RunAllControlsPayload!
  runCloudConfigurationRule(input: RunCloudConfigurationRuleInput!): RunCloudConfigurationRulePayload!
  runControl(input: RunControlInput!): RunControlPayload!
  runControlsIntegrationAction(input: RunControlsIntegrationInput!): RunControlsIntegrationPayload!
  runIssueAutomationAction(input: RunIssueAutomationActionInput!): RunIssueAutomationActionPayload!
  runIssuesAutomationAction(input: RunIssuesAutomationActionInput!): RunIssuesAutomationActionPayload!
  runIssuesIntegrationAction(input: RunIssuesIntegrationInput!): RunIssuesIntegrationPayload!
  sendUserEmailInvite(input: SendUserEmailInviteInput!): SendUserEmailInvitePayload!
  uninstallOutpost(input: UninstallOutpostInput!): UninstallOutpostPayload!
  updateAutomationRule(input: UpdateAutomationRuleInput!): UpdateAutomationRulePayload!
  updateBasicAuthSettings(input: UpdateBasicAuthSettingsInput!): UpdateBasicAuthSettingsPayload!
  updateCICDScanPolicy(input: UpdateCICDScanPolicyInput): UpdateCICDScanPolicyPayload!
  updateCloudConfigurationFinding(input: UpdateFindingInput!): UpdateCloudConfigurationFindingPayload!
  updateCloudConfigurationRule(input: UpdateCloudConfigurationRuleInput!): UpdateCloudConfigurationRulePayload!
  updateCloudConfigurationRules(input: UpdateCloudConfigurationRulesInput!): UpdateCloudConfigurationRulesPayload!
  updateCloudEventRule(input: UpdateCloudEventRuleInput!): UpdateCloudEventRulePayload!
  updateComputeGroupTagsSet(input: UpdateComputeGroupTagsSetInput!): UpdateComputeGroupTagsSetPayload!
  updateConnector(input: UpdateConnectorInput!): UpdateConnectorPayload!
  updateControl(input: UpdateControlInput!): UpdateControlPayload!
  updateControls(input: UpdateControlsInput!): UpdateControlsPayload!
  updateCustomIPRange(input: UpdateCustomIPRangeInput!): UpdateCustomIPRangePayload!
  updateDataClassifier(input: UpdateDataClassifierInput!): UpdateDataClassifierPayload!
  updateDataScannerSettings(input: UpdateDataScannerSettingsInput!): UpdateDataScannerSettingsPayload!
  updateDigitalTrustDashboardSettings(input: UpdateDigitalTrustDashboardSettingsInput!): UpdateDigitalTrustDashboardSettingsPayload!
  updateExternalExposureScannerSettings(input: UpdateExternalExposureScannerSettingsInput!): UpdateExternalExposureScannerSettingsPayload!
  updateFileIntegrityMonitoringExclusion(input: UpdateFileIntegrityMonitoringExclusionInput!): UpdateFileIntegrityMonitoringExclusionPayload!
  updateFileIntegrityMonitoringSettings(input: UpdateFileIntegrityMonitoringSettingsInput!): UpdateFileIntegrityMonitoringSettingsPayload!
  updateGraphEntity(input: UpdateGraphEntityInput!): UpdateGraphEntityPayload!
  updateHostConfigurationRule(input: UpdateHostConfigurationRuleInput!): UpdateHostConfigurationRulePayload!
  updateHostConfigurationRuleAssessment(input: UpdateFindingInput!): UpdateHostConfigurationRuleAssessmentPayload!
  updateHostConfigurationRules(input: UpdateHostConfigurationRulesInput!): UpdateHostConfigurationRulesPayload!
  updateIgnoreRule(input: UpdateIgnoreRuleInput!): UpdateIgnoreRulePayload!
  updateIntegration(input: UpdateIntegrationInput!): UpdateIntegrationPayload!
  updateIPRestrictions(input: UpdateIPRestrictionsInput!): UpdateIPRestrictionsPayload!
  updateIssue(input: UpdateIssueInput!): UpdateIssuePayload!
  updateIssueNote(input: UpdateIssueNoteInput!): UpdateIssueNotePayload!
  updateIssues(input: UpdateIssuesInput!): UpdateIssuesPayload!
  updateIssueSettings(input: UpdateIssueSettingsInput!): UpdateIssueSettingsPayload!
  updateLoginSettings(input: UpdateLoginSettingsInput!): UpdateLoginSettingsPayload!
  updateMalwareExclusion(input: UpdateMalwareExclusionInput!): UpdateMalwareExclusionPayload!
  updateNonOSDiskScanningSettings(input: UpdateNonOSDiskScanningSettingsInput!): UpdateNonOSDiskScanningSettingsPayload!
  updateOutpost(input: UpdateOutpostInput!): UpdateOutpostPayload!
  updatePortalInactivityTimeoutSettings(input: UpdatePortalInactivityTimeoutSettingsInput!): UpdatePortalInactivityTimeoutSettingsPayload!
  updateProject(input: UpdateProjectInput!): UpdateProjectPayload!
  updateReport(input: UpdateReportInput!): UpdateReportPayload!
  updateReportSettings(input: UpdateReportSettingsInput!): UpdateReportSettingsPayload!
  updateSAMLIdentityProvider(input: UpdateSAMLIdentityProviderInput!): UpdateSAMLIdentityProviderPayload!
  updateSavedCloudEventFilter(input: UpdateSavedCloudEventFilterInput!): UpdateSavedCloudEventFilterPayload!
  updateSavedGraphQuery(input: UpdateSavedGraphQueryInput!): UpdateSavedGraphQueryPayload!
  updateScannerAPIRateLimit(input: UpdateScannerAPIRateLimitInput!): UpdateScannerAPIRateLimitPayload!
  updateScannerExclusionSizeLimits(patch: UpdateScannerExclusionSizeLimitsPatch!): UpdateScannerExclusionSizeLimitsPayload!
  updateScannerExclusionTags(patch: UpdateScannerExclusionTagsPatch!): UpdateScannerExclusionTagPayload!
  updateScannerResourceTags(input: UpdateScannerResourceTagsInput!): UpdateScannerResourceTagPayload!
  updateScannerSettings(input: UpdateScannerSettingsInput!): UpdateScannerSettingsPayload!
  updateSecurityFramework(input: UpdateSecurityFrameworkInput!): UpdateSecurityFrameworkPayload!
  updateSecurityScan(input: UpdateSecurityScanInput!): UpdateSecurityScanPayload!
  updateSessionLifetimeSettings(input: UpdateSessionLifetimeSettingsInput!): UpdateSessionLifetimeSettingsPayload!
  updateSystemHealthIssue(input: UpdateSystemHealthIssueInput!): UpdateSystemHealthIssuePayload!
  updateTechnology(input: UpdateTechnologyInput!): UpdateTechnologyPayload!
  updateUIUserPreferences(input: UpdateUIUserPreferencesInput!): UpdateUIUserPreferencesPayload!
  updateUser(input: UpdateUserInput!): UpdateUserPayload!
  updateViewerPreferences(input: UpdateViewerPreferencesInput!): UpdateViewerPreferencesPayload!
  updateVulnerability(input: UpdateVulnerabilityInput!): UpdateVulnerabilityPayload!
  updateVulnerabilityFinding(input: UpdateFindingInput!): UpdateVulnerabilityFindingPayload!
  uploadSmoochSupportChatFile(input: SmoochFileUploadInput!): SmoochFileUploadPayload! @deprecated(reason: "Smooch is no longer used")
  UpsertAgentTelemetry(input: UpsertAgentTelemetryInput!): UpsertAgentTelemetryPayload!
}

type NetworkExposure implements Node {
  accessibleFrom: GraphEntity
  applicationEndpoints: [GraphEntity]
  appProtocols: [String!]!
  customIPRanges: [CustomIPRange]
  destinationIpRange: String!
  exposedEntity: GraphEntity
  firstSeenAt: DateTime
  id: ID!
  networkProtocols: [String!]!
  path: [GraphEntity]!
  portRange: String!
  sourceIpRange: String!
  type: NetworkExposureType!
}

type NetworkExposureConnection {
  edges: [NetworkExposureEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 5000): String
  maxCountReached: Boolean!
  nodes: [NetworkExposure!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type NetworkExposureEdge {
  cursor: String!
  node: NetworkExposure!
}

input NetworkExposureFilters {
  projectId: String
  exposedEntity: NetworkExposureGraphEntityFilter
  sourceIpRange: [String!]
  accessibleFromEntity: NetworkExposureGraphEntityFilter
  destinationIpRange: [String!]
  portRange: [String!]
  customIpRange: [String!]
  entityInPath: NetworkExposureGraphEntityFilter
  cloudAccount: [String!]
  firstSeenAt: NetworkExposureFirstSeenFilter
  type: [NetworkExposureType!]
  publicInternetExposureFilters: PublicInternetNetworkExposureFilters
}

input NetworkExposureFirstSeenFilter {
  before: DateTime
  after: DateTime
}

input NetworkExposureGraphEntityFilter {
  id: [String!]
  type: [GraphEntityTypeValue!]
  nativeType: [String!]
  negate: Boolean
}

enum NetworkExposureType {
  PUBLIC_INTERNET
  CROSS_CLOUD_ACCOUNT
  IN_CLOUD_ACCOUNT
  CUSTOM_IP_RANGE
  VPN
}

interface Node {
  id: ID!
}

type NonOsDiskScanningResourceTag {
  key: String!
  value: String
}

type NonOSDiskScanningSettings {
  daysInterval: Int!
  enabled: Boolean!
  excludedTags: [NonOsDiskScanningResourceTag!]!
  includedTags: [NonOsDiskScanningResourceTag!]!
}

type OCIUserCredentials {
  fingerprint: String!
  privateKey: String!
  tenancyOCID: String!
  userOCID: String!
}

input OCIUserCredentialsInput {
  tenancyOCID: String!
  userOCID: String!
  fingerprint: String!
  privateKey: String!
}

type OnPremIntegrationConfig {
  isOnPrem: Boolean!
  tunnelDomain: String
  tunnelToken: String
}

type OpsgenieCloseAlertTemplateParams {
  body: String!
}

input OpsgenieCloseAlertTemplateParamsInput {
  body: String!
}

type OpsgenieCreateAlertTemplateParams {
  body: String!
}

input OpsgenieCreateAlertTemplateParamsInput {
  body: String!
}

type OpsgenieIntegrationParams {
  key: String!
}

enum OrderDirection {
  ASC
  DESC
}

type OSBenchmark implements Node {
  analyzedAt: DateTime!
  createdAt: DateTime!
  id: ID!
  resource: OSBenchmarkResource!
  result: OSBenchmarkResult!
  rule: OSBenchmarkRule!
}

input OSBenchmarkDateFilters {
  before: DateTime
  after: DateTime
}

type OSBenchmarkEdge {
  cursor: String!
  node: OSBenchmark!
}

input OSBenchmarkFilters {
  rule: OSBenchmarkRuleFilters
  resource: OSBenchmarkResourceFilters
  analyzedAt: OSBenchmarkDateFilters
  result: [OSBenchmarkResult!]
}

enum OSBenchmarkOrderField {
  ANALYZED_AT
}

type OSBenchmarkResource implements Node {
  cloudPlatform: String
  connectors: [Connector]
  id: ID!
  name: String
  nativeType: String
  projects: [Project]
  region: String
  resourceGroupId: String
  status: OSBenchmarkResourceStatus
  subscription: CloudAccount
  tags: [OSBenchmarkResourceTag!]
  type: GraphEntityTypeValue!
}

input OSBenchmarkResourceFilters {
  id: [String!]
  type: [GraphEntityTypeValue!]
  projectId: [String!]
  name: [String!]
  status: [OSBenchmarkResourceStatus!]
  subscriptionId: [String!]
  cloudPlatform: [String!]
  nativeType: [String!]
  tags: [String!]
}

enum OSBenchmarkResourceStatus {
  Active
  Inactive
  Error
}

type OSBenchmarkResourceTag {
  key: String
  value: String
}

enum OSBenchmarkResult {
  PASS
  FAIL
  ERROR
  NOT_ASSESSED
}

type OSBenchmarkRule implements Node {
  description: String!
  id: ID!
  name: String!
  subCategory: SecuritySubCategory!
}

input OSBenchmarkRuleFilters {
  id: String
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
  names: [String!]
  description: [String!]
}

type OSBenchmarksConnection {
  edges: [OSBenchmarkEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 1000): String
  maxCountReached: Boolean!
  nodes: [OSBenchmark!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input OSBenchmarksOrder {
  direction: OrderDirection!
  field: OSBenchmarkOrderField!
}

type Outpost implements Node {
  addedBy: User
  clusterNamespacePrefix: String
  clusters: [OutpostCluster!]
  config: OutpostConfig!
  createdAt: DateTime!
  customConfig: OutpostCustomConfig @deprecated(reason: "All customConfig fields were moved to the outpost itself")
  enabled: Boolean!
  errorCode: OutpostErrorCode
  externalInternetAccess: OutpostExternalInternetAccess!
  id: ID!
  managedConfig: OutpostManagedConfig
  name: String!
  podAnnotations: [OutpostCustomTag!]
  selfManaged: Boolean! @deprecated(reason: "When an outpost is self managed it'll have a selfManagedConfig, if not, selfManagedConfig will be empty")
  selfManagedConfig: OutpostSelfManagedConfig
  serviceType: OutpostServiceType!
  status: OutpostStatus!
  statusLog: JSON!
  uninstalledAt: DateTime
}

type OutpostAlibabaConfig {
  outpostCredentials: AlibabaOutpostCredentials
  settingsRegion: String!
  stateBucketName: String
  workerResourcesGroupID: String!
}

input OutpostAlibabaConfigInput {
  outpostCredentials: AlibabaOutpostCredentialsInput
  workerResourcesGroupID: String!
  stateBucketName: String!
  settingsRegion: String!
}

type OutpostAssets {
  url: String!
}

type OutpostAWSConfig {
  accessKey: String!
  disableNatGateway: Boolean
  externalID: String!
  resultsBucketName: String
  roleARN: String!
  secretKey: String!
  settingsRegion: String
  stateBucketName: String
}

input OutpostAWSConfigInput {
  roleARN: String!
  externalID: String
  accessKey: String
  secretKey: String
  stateBucketName: String
  settingsRegion: String
  resultsBucketName: String
  disableNatGateway: Boolean
}

type OutpostAzureConfig {
  applicationKeyVaultName: String
  environment: String
  globalResourceGroupName: String
  keyVaultName: String!
  keyVaultPrimaryScannerAppSecretName: String
  orchestratorClientCertificatePem: String
  orchestratorClientID: String!
  orchestratorClientPrivateKeyPem: String
  orchestratorClientSecret: String!
  stateStorageAccountName: String
  subscriptionID: String!
  tenantID: String!
  workerClientID: String!
  workerClientSecret: String!
}

input OutpostAzureConfigInput {
  tenantID: String!
  subscriptionID: String!
  environment: String
  orchestratorClientID: String!
  orchestratorClientSecret: String!
  orchestratorClientPrivateKeyPem: String
  orchestratorClientCertificatePem: String
  workerClientID: String
  workerClientSecret: String
  keyVaultName: String!
  applicationKeyVaultName: String
  globalResourceGroupName: String
  stateStorageAccountName: String
  keyVaultPrimaryScannerAppSecretName: String
}

enum OutpostCloudEnvironment {
  PUBLIC
  AWS_CHINA
  AWS_GOV
  AZURE_CHINA
  AZURE_GOV
}

type OutpostCluster implements Node {
  addedBy: User
  config: OutpostClusterConfig!
  createdAt: DateTime!
  httpProxyConfig: OutpostClusterHttpProxyConfig
  id: ID!
  internetAccessConfig: OutpostClusterInternetAccessConfig
  outpost: Outpost!
  region: String!
  serviceType: OutpostClusterServiceType!
}

type OutpostClusterAlibabaConfig {
  clusterName: String!
  queueName: String!
}

type OutpostClusterAWSConfig {
  clusterName: String!
  httpProxyURL: String @deprecated(reason: "Use httpProxyConfig->httpProxyURL instead")
  httpsProxyURL: String @deprecated(reason: "Use httpProxyConfig->httpsProxyURL instead")
  kubernetesServiceAccountName: String
  regionalReplicaImageRepository: String
  regionalReplicaStateBucketName: String
  securityGroupIds: [String!]!
  sqsURL: String!
  subnetIds: [String!]!
  vpcCIDR: String @deprecated(reason: "Use httpProxyConfig->vpcCIDR instead")
  vpcId: String!
}

input OutpostClusterAWSConfigInput {
  httpProxyURL: String
  httpsProxyURL: String
  vpcCIDR: String
  clusterName: String!
  sqsURL: String!
  kubernetesServiceAccountName: String
  regionalReplicaStateBucketName: String
  regionalReplicaImageRepository: String
}

type OutpostClusterAzureConfig {
  clusterName: String!
  dnsServiceIp: String!
  podIdentityName: String
  resourceGroupName: String!
  serviceAuthorizedIPRanges: [String!]
  servicebusNamespace: String!
  servicebusQueueName: String!
  serviceCIDR: String!
  storageAccountNames: [String!]!
  subnetId: String!
  subscriptionId: String!
  vnetId: String!
}

input OutpostClusterAzureConfigInput {
  clusterName: String!
  servicebusQueueName: String!
  servicebusNamespace: String!
  subscriptionId: String!
  resourceGroupName: String!
  storageAccountNames: [String!]!
  podIdentityName: String
  nodeResourceGroup: String
}

union OutpostClusterConfig = OutpostClusterAWSConfig | OutpostClusterAzureConfig | OutpostClusterGCPConfig | OutpostClusterOCIConfig | OutpostClusterAlibabaConfig

input OutpostClusterConfigInput {
  awsConfig: OutpostClusterAWSConfigInput
  azureConfig: OutpostClusterAzureConfigInput
  gcpConfig: OutpostClusterGCPConfigInput
  httpProxyConfig: OutpostClusterHttpProxyConfigInput
}

type OutpostClusterGCPConfig {
  clusterName: String!
  clusterZone: String!
  projectId: String!
  pubSubSubscription: String
  topicName: String!
}

input OutpostClusterGCPConfigInput {
  clusterName: String!
  projectId: String!
  clusterZone: String!
  topicName: String!
  pubSubSubscription: String!
}

type OutpostClusterHttpProxyConfig {
  httpProxyURL: String!
  httpsProxyURL: String!
  vpcCIDR: String
  vpcCIDRs: [String!]!
}

input OutpostClusterHttpProxyConfigInput {
  httpProxyURL: String!
  httpsProxyURL: String!
  vpcCIDRs: [String!]
  vpcCIDR: String
}

type OutpostClusterInternetAccessConfig {
  skipSslValidation: Boolean
  trustedCA: String
}

input OutpostClusterInternetAccessConfigInput {
  skipSslValidation: Boolean
  trustedCA: String
}

type OutpostClusterOCIConfig {
  clusterName: String!
  streamOCID: String!
}

enum OutpostClusterServiceType {
  AWS
  GCP
  AZURE
  OCI
  Alibaba
}

union OutpostConfig = OutpostAWSConfig | OutpostGCPConfig | OutpostAzureConfig | OutpostOCIConfig | OutpostAlibabaConfig

input OutpostConfigInput {
  awsConfig: OutpostAWSConfigInput
  gcpConfig: OutpostGCPConfigInput
  azureConfig: OutpostAzureConfigInput
  ociConfig: OutpostOCIConfigInput
  alibabaConfig: OutpostAlibabaConfigInput
}

type OutpostConnection {
  edges: [OutpostEdge!]
  nodes: [Outpost!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OutpostCustomConfig {
  namespacePrefix: String
  podAnnotations: JSON
  resourceTags: JSON
}

input OutpostCustomConfigInput {
  podAnnotations: JSON
  resourceTags: JSON
  namespacePrefix: String
}

type OutpostCustomTag {
  key: String!
  value: String
}

type OutpostEdge {
  cursor: String!
  node: Outpost!
}

enum OutpostErrorCode {
  INSUFFICIENT_QUOTA
  INSUFFICIENT_PERMISSIONS
  INITIALIZATION_FAILED
  DISWALLOWED_BY_POLICY
}

enum OutpostExternalInternetAccess {
  INTERNET
  HTTP_PROXY
}

input OutpostFilters {
  search: String
  serviceType: [OutpostServiceType!]
  enabled: Boolean
}

type OutpostGCPConfig {
  orchestratorKey: String!
  stateBucketName: String
  workerAccountEmail: String!
  workerKey: String! @deprecated
}

input OutpostGCPConfigInput {
  orchestratorKey: String!
  workerKey: String!
  workerAccountEmail: String!
  stateBucketName: String
}

type OutpostManagedConfig {
  allowedRegions: [String!]
  enableNatGateway: Boolean @deprecated(reason: "Use config.disableNatGateway instead")
  kubernetesCloudMonitoringEnabled: Boolean
  kubernetesLoggingEnabled: Boolean
  manualNetwork: Boolean
  resourceTags: [OutpostCustomTag!]
}

type OutpostOCIConfig {
  compartmentOCID: String!
  keyOCID: String!
  orchestrator: OCIUserCredentials
  settingsRegion: String!
  stateBucketName: String
  vaultOCID: String!
}

input OutpostOCIConfigInput {
  compartmentOCID: String!
  orchestrator: OCIUserCredentialsInput
  vaultOCID: String!
  keyOCID: String!
  stateBucketName: String!
  settingsRegion: String!
}

input OutpostOrder {
  direction: OrderDirection!
  field: OutpostOrderField!
}

enum OutpostOrderField {
  CREATED_AT
}

type OutpostSelfManagedConfig {
  disableAutomaticConfigurationBucketSync: Boolean
  externalInternetAccess: OutpostExternalInternetAccess!
  imagePullSecret: String
  imageRepository: String
  version: OutpostVersionManifest
}

enum OutpostServiceType {
  AWS
  GCP
  AZURE
  OCI
  Alibaba
}

enum OutpostStatus {
  INITIAL_SETUP @deprecated
  INITIALIZING
  ERROR
  CONNECTED
  DISABLED
  INITIALIZED
  UNINSTALLING
  PARTIALLY_UNINSTALLED
  UNINSTALLED
  UNINSTALLATION_FAILED
}

type OutpostSupportedRegion {
  displayName: String!
  name: String!
}

type OutpostSupportedRegions {
  regions: [OutpostSupportedRegion!]!
}

type OutpostVersionImage {
  serviceTypes: [OutpostVersionImageServiceType!]!
  url: String!
}

enum OutpostVersionImageServiceType {
  AWS
  AZURE
  GCP
}

type OutpostVersionManifest implements Node {
  id: ID!
  images: [OutpostVersionImage!]!
  publishedAt: DateTime!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}

type PagerDutyActionCreateIncidentTemplateParams {
  payload: String!
}

input PagerDutyActionCreateIncidentTemplateParamsInput {
  payload: String!
}

type PagerDutyIntegrationParams {
  integrationKey: String!
}

input PerCloudManualNetworkOutpostClusterConfigInput {
  awsConfig: ManualNetworkOutpostClusterAWSConfigInput
  azureConfig: ManualNetworkOutpostClusterAzureConfigInput
}

input PerCloudSelfManagedOutpostClusterInput {
  awsConfig: OutpostClusterAWSConfigInput
  azureConfig: OutpostClusterAzureConfigInput
  gcpConfig: OutpostClusterGCPConfigInput
}

type PolicyAssessment {
  id: ID!
  output: PolicyAssessmentOutput
  policy: PolicyAssessmentSource!
  resource: PolicyAssessmentResource!
  result: PolicyAssessmentResult!
}

type PolicyAssessmentEdge {
  cursor: String!
  node: PolicyAssessment!
}

input PolicyAssessmentFilters {
  search: String
  frameworkCategory: [String!]
  project: [String!]
  result: [PolicyAssessmentResult!]
  policy: [String!]
  cloudAccount: [String!]
}

union PolicyAssessmentOutput = Issue | ConfigurationFinding | HostConfigurationRuleAssessment

type PolicyAssessmentResource implements Node {
  id: ID!
  name: String!
  subscription: CloudAccount
  type: GraphEntityTypeValue!
}

enum PolicyAssessmentResult {
  PASS
  FAIL
  ERROR
  NOT_ASSESSED
  REJECTED
}

type PolicyAssessmentsConnection {
  edges: [PolicyAssessmentEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 1000): String
  nodes: [PolicyAssessment!]
  pageInfo: PageInfo!
  totalCount: Int!
}

union PolicyAssessmentSource = Control | CloudConfigurationRule | HostConfigurationRule

type PolicyComplianceAnalytics {
  assessedCount: Int
  cloudConfigurationRule: CloudConfigurationRule
  control: Control
  errorCount: Int!
  failCount: Int
  hostConfigurationRule: HostConfigurationRule
  noResourceToAsses: Boolean!
  notAssessedCount: Int!
  passCount: Int
  rejectedCount: Int!
}

type PortalInactivityTimeoutSettings {
  inactivityTimeoutMinutes: Int!
  isEnabled: Boolean!
}

input PortalInactivityTimeoutSettingsPatch {
  isEnabled: Boolean!
  inactivityTimeoutMinutes: Int!
}

type PrincipalServicePermissions {
  hasHighPrivileges: Boolean!
  isAdmin: Boolean!
  lastActivity: DateTime
  service: String!
}

enum ProductFeature {
  INVENTORY
  CSPM
  KSPM
  GUARDRAILS
  COMPLIANCE_ASSESSMENTS
  VULNERABILITY_MANAGEMENT
  EXTERNAL_NETWORK_EXPOSURE
  CIEM_ESSENTIAL
  WORKLOAD_SECRETS_SCANNER
  RISK_ISSUES
  THREAT_CENTER
  WORKLOAD_MALWARE_SCANNER
  BUILT_IN_AND_CUSTOM_GRAPH_CONTROLS
  BUILT_IN_AND_CUSTOM_COMPLIANCE_FRAMEWORKS
  REPORTS
  MANUAL_AND_AUTOMATED_RESPONSE
  TEAM_INTEGRATIONS
  STANDARD_SUPPORT
  HOST_CONFIGURATION_ANALYSIS
  CIEM_ADVANCED
  INTERNAL_NETWORK_EXPOSURE
  EVENT_BASED_SCAN_TRIGGERS
  THIRD_PARTY_SCANS
  CONTAINER_REGISTRY_SCANNING
  ATTACK_PATH_ANALYSIS
  CUSTOM_HOST_CONFIGURATION_RULES
  CLOUD_EVENTS_AND_DETECTION
  HOST_FORENSICS
  ACTIVE_SCANNER
  CUSTOM_FILE_DETECTION
  FILE_INTEGRITY_MONITORING
  OUTPOST
  CUSTOM_CLOUD_CONFIGURATION_RULES
  SECURE_AUTO_REMEDIATION
  ENTERPRISE_INTEGRATIONS
  ON_DEMAND_SCANS
  SOVEREIGN_CLOUD
  SCHEDULED_REPORTS
  ADVANCED_SUPPORT
  ADMISSION_CONTROLLER
  PRIVATE_BUCKET_SCANNING
  CLOUD_MANAGED_DATABASES
  SELF_HOSTED_DATABASES
  WIZ_CLI
}

type Project implements Node {
  archived: Boolean!
  businessUnit: String
  category: ProjectCategory @deprecated(reason: "Deprecated property")
  cloudAccountCount: Int!
  cloudAccountLinks: [ProjectCloudAccountLink!]!
  cloudOrganizationCount: Int!
  cloudOrganizationLinks: [ProjectCloudOrganizationLink!]!
  complianceAnalytics(selection: ProjectComplianceAnalyticsSelection): ProjectComplianceAnalytics!
  complianceAnalyticsOverview(selection: ComplianceAnalyticsOverviewSelection): ComplianceAnalyticsOverview!
  complianceTrend(endDate: DateTime!, interval: ProjectComplianceTrendTimeInterval, selection: ProjectComplianceTrendSelection, startDate: DateTime!): ProjectComplianceTrendDataSeries!
  description: String
  entityCount: Int!
  entrypoints: [ProjectEntrypoint!]! @deprecated(reason: "Deprecated property")
  id: ID!
  identifiers: [String!]!
  issueAnalytics(selection: ProjectIssueAnalyticsSelection): IssueAnalytics!
  kubernetesClusterCount: Int!
  kubernetesClustersLinks: [ProjectKubernetesClusterLink!]!
  name: String!
  note: String @deprecated(reason: "Deprecated property")
  profileCompletion: Int!
  projectOwners: [User!]!
  repositoryCount: Int!
  repositoryLinks: [ProjectRepositoryLink!]!
  resourceTagLinks: [ProjectResourceTagLink!]!
  riskProfile: ProjectRiskProfile!
  securityChampions: [User!]!
  securityScore: Int! @deprecated(reason: "Deprecated, use complianceAnalytics.score instead")
  slug: String!
  subCategory: ProjectSubCategory @deprecated(reason: "Deprecated property")
  teamMemberCount: Int!
  technologyCount: Int!
  workloadCount: Int!
}

enum ProjectCategory {
  ONLINE_SERVICE
  CLIENT_APPLICATION
  SERVER_APPLICATION
  CODE_LIBRARY
}

type ProjectCloudAccountLink {
  cloudAccount: CloudAccount
  environment: Environment!
  resourceGroups: [String!]
  resourceTags: [ResourceTag!]
  shared: Boolean!
}

input ProjectCloudAccountLinkInput {
  cloudAccount: String!
  shared: Boolean
  environment: Environment!
  resourceTags: [ResourceTagInput!]
  resourceGroups: [String!]
}

type ProjectCloudOrganizationLink {
  cloudOrganization: CloudOrganization
  environment: Environment!
  resourceGroups: [String!]
  resourceTags: [ResourceTag!]
  shared: Boolean!
}

input ProjectCloudOrganizationLinkInput {
  cloudOrganization: String!
  shared: Boolean!
  environment: Environment!
  resourceTags: [ResourceTagInput!]
  resourceGroups: [String!]
}

type ProjectComplianceAnalytics {
  averageCompliancePosture: Int
  emptyPostureReason: ComplianceEmptyPostureReason
  failSubCategoryCount: Int!
  passSubCategoryCount: Int!
}

input ProjectComplianceAnalyticsSelection {
  framework: String!
}

type ProjectComplianceTrendDataPoint {
  failCount: Int
  passCount: Int
  score: Int
  time: DateTime!
}

type ProjectComplianceTrendDataSeries {
  dataPoints: [ProjectComplianceTrendDataPoint!]!
}

input ProjectComplianceTrendSelection {
  framework: String!
}

enum ProjectComplianceTrendTimeInterval {
  DAY
}

type ProjectConnection {
  edges: [ProjectEdge!]
  exportUrl(format: ExportFormats = CSV, issueAnalyticsSelection: ProjectIssueAnalyticsSelection, limit: Int = 1000): String
  HBICount: Int!
  LBICount: Int!
  MBICount: Int!
  nodes: [Project!]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ProjectDataType {
  CLASSIFIED
  HEALTH
  PII
  PCI
  FINANCIAL
  CUSTOMER
}

type ProjectEdge {
  cursor: String!
  node: Project!
  permission: ProjectPermission!
}

type ProjectEntrypoint {
  environment: Environment!
  url: String!
}

input ProjectEntrypointInput {
  url: String!
  environment: Environment!
}

input ProjectFilters {
  impact: [BusinessImpact!]
  search: String
  includeArchived: Boolean
}

input ProjectIssueAnalyticsSelection {
  control: String
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
}

type ProjectKubernetesClusterLink {
  environment: Environment!
  kubernetesCluster: KubernetesCluster
  namespaces: [String!]
  shared: Boolean!
}

input ProjectKubernetesClusterLinkInput {
  kubernetesCluster: String!
  environment: Environment!
  shared: Boolean!
  namespaces: [String!]
}

input ProjectOrder {
  direction: OrderDirection!
  field: ProjectsOrderField!
}

enum ProjectPermission {
  VIEW
  EDIT
}

type ProjectRepositoryLink {
  repository: Repository!
}

input ProjectRepositoryLinkInput {
  repository: String!
}

type ProjectResourceTagLink {
  environment: Environment!
  resourceTags: [ResourceTag!]!
}

input ProjectResourceTagsLinkInput {
  environment: Environment!
  resourceTags: [ResourceTagInput!]!
}

type ProjectRiskProfile {
  businessImpact: BusinessImpact
  hasAuthentication: YesNoUnknown!
  hasExposedAPI: YesNoUnknown!
  hasUserInterface: YesNoUnknown! @deprecated(reason: "Deprecated property")
  isActivelyDeveloped: YesNoUnknown!
  isCustomerFacing: YesNoUnknown!
  isInternetFacing: YesNoUnknown!
  isRegulated: YesNoUnknown!
  regulatoryStandards: [RegulatoryStandard!]!
  sensitiveDataTypes: [ProjectDataType!]!
  storesData: YesNoUnknown!
}

input ProjectRiskProfileInput {
  isActivelyDeveloped: YesNoUnknown
  hasAuthentication: YesNoUnknown
  hasExposedAPI: YesNoUnknown
  isInternetFacing: YesNoUnknown
  isCustomerFacing: YesNoUnknown
  storesData: YesNoUnknown
  sensitiveDataTypes: [ProjectDataType!]
  businessImpact: BusinessImpact
  isRegulated: YesNoUnknown
  regulatoryStandards: [RegulatoryStandard!]
}

enum ProjectsOrderField {
  BUSINESS_IMPACT
  SECURITY_SCORE
  NAME
  ISSUE_COUNT
}

enum ProjectSubCategory {
  PUBLIC_CLOUD
  PRIVATE_CLOUD
  ON_PREMISE_DATACENTER
  DESKTOP_APPLICATION
  MOBILE_APPLICATION
  SERVER_APPLICATION
}

type ProjectWithComplianceAnalyticsConnection {
  edges: [ProjectWithComplianceAnalyticsEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 1000): String
  nodes: [Project!]
  overviewExportUrl(format: ExportFormats = CSV, selection: ComplianceAnalyticsOverviewSelection): String
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectWithComplianceAnalyticsEdge {
  cursor: String!
  node: Project!
}

input ProjectWithComplianceAnalyticsFilters {
  framework: String
  projectId: [String!]
  businessImpact: [BusinessImpactFilter!]
  search: String
  impact: [BusinessImpact!]
  policyTypes: [SecurityFrameworkPolicyType!]
}

input ProjectWithComplianceAnalyticsOrder {
  direction: OrderDirection!
  field: ProjectWithComplianceAnalyticsOrderField!
}

enum ProjectWithComplianceAnalyticsOrderField {
  POSTURE
  PASSED_CHECKS
}

input PublicInternetNetworkExposureFilters {
  hasApplicationEndpoint: Boolean
  applicationEndpointId: [String!]
}

type Query {
  actionTemplate(id: ID!): ActionTemplate!
  actionTemplates(after: String, filterBy: ActionTemplateFilters, first: Int): ActionTemplateConnection!
  admissionController(id: ID!): AdmissionController
  auditLogEntries(after: String, filterBy: AuditLogEntryFilters, first: Int): AuditLogEntryConnection!
  auditLogEntry(id: ID!): AuditLogEntry
  authMigration: AuthMigration
  automationAction(id: ID!): AutomationAction
  automationActions(after: String, filterBy: AutomationActionFilters, first: Int): AutomationActionConnection!
  automationRule(id: ID!): AutomationRule
  automationRules(after: String, filterBy: AutomationRuleFilters, first: Int): AutomationRuleConnection!
  availableRegions(region: String): AvailableRegions!
  basicAuthSettings: BasicAuthSettings
  billableWorkloadTrend(endDate: DateTime!, maxResults: Int, project: [String!], startDate: DateTime!): BillableWorkloadTrendData!
  builtinControl(slug: ID!): Control
  builtinSavedGraphQuery(slug: ID!): SavedGraphQuery
  cicdScan(id: ID!): CICDScan
  cicdScanPolicies(after: String, filterBy: CICDScanPolicyFilters, first: Int, orderBy: CICDScanPolicyOrder): CICDScanPolicyConnection!
  cicdScanPolicy(id: ID!): CICDScanPolicy
  cicdScans(after: String, filterBy: CICDScanFilters, first: Int, orderBy: CICDScanOrder): CICDScanConnection!
  cliConfigurationRules(after: String, filterBy: CLIConfigurationRulesFilters, first: Int): CLIConfigurationRulesConnection!
  cliDownloadInformation: CLIDownloadInformation!
  cloudAccount(id: ID!): CloudAccount
  cloudAccounts(after: String, filterBy: CloudAccountFilters, first: Int): CloudAccountConnection!
  cloudAccountsWithComplianceAnalytics(after: String, filterBy: CloudAccountWithComplianceAnalyticsFilters, first: Int, orderBy: CloudAccountWithComplianceAnalyticsOrder): CloudAccountWithComplianceAnalyticsConnection!
  cloudConfigurationRule(id: ID!): CloudConfigurationRule
  cloudConfigurationRuleIaCTest(IaCFileContent: String!, rule: String!, type: CloudConfigurationRuleMatcherType!): cloudConfigurationRuleIaCTest!
  cloudConfigurationRuleJsonTest(json: JSON!, rule: String!): CloudConfigurationRuleJsonTest!
  cloudConfigurationRules(after: String, filterBy: CloudConfigurationRuleFilters, first: Int, orderBy: CloudConfigurationRuleOrder): CloudConfigurationRuleConnection!
  cloudConfigurationRuleTest(after: String, cloudAccountIds: [String!], first: Int, nativeType: String, nativeTypes: [String!]!, rule: String!): CloudConfigurationRuleTest!
  cloudEvent(id: ID!): CloudEvent
  cloudEventExternalTypes(filterBy: CloudEventExternalTypeFilters): [CloudEventExternalType!]!
  cloudEventRule(id: ID!): CloudEventRule
  cloudEventRuleJsonTest(json: JSON!, rule: String!): CloudEventRuleJsonTest!
  cloudEventRules(after: String, filterBy: CloudEventRuleFilters, first: Int, orderBy: CloudEventRuleOrder): CloudEventRuleConnection!
  cloudEvents(after: String, filterBy: CloudEventFilters, first: Int, groupBy: CloudEventGroupBy, orderDirection: OrderDirection = DESC, projectId: [String!]): CloudEventSearchResultConnection!
  cloudEventTypes(filterBy: CloudEventTypeFilters): [CloudEventType!]!
  cloudOrganization(id: ID!): CloudOrganization
  cloudOrganizations(after: String, filterBy: CloudOrganizationFilters, first: Int): CloudOrganizationConnection!
  computeGroupTagsSet(id: ID!): ComputeGroupTagsSet
  computeGroupTagsSets: [ComputeGroupTagsSet!]
  configurationFinding(id: ID!): ConfigurationFinding
  configurationFindings(after: String, filterBy: ConfigurationFindingFilters, first: Int, orderBy: ConfigurationFindingOrder, quick: Boolean): ConfigurationFindingConnection!
  connector(id: ID!): Connector
  connectors(after: String, filterBy: ConnectorFilters, first: Int, orderBy: ConnectorOrder): ConnectorConnection!
  connectorType(id: ID!): ConnectorType
  connectorTypes: [ConnectorType!]!
  containerImage(id: ID!): ContainerImageBase
  containerImages(after: String, filterBy: ContainerImageFilters, first: Int, orderBy: ContainerImageOrder): ContainerImageConnection!
  containerRegistries(after: String, filterBy: ContainerRegistryFilters, first: Int, orderBy: ContainerRegistryOrder): ContainerRegistryConnection!
  containerRepositories(after: String, filterBy: ContainerRepositoryFilters, first: Int, orderBy: ContainerRepositoryOrder): ContainerRepositoryConnection!
  control(id: ID!): Control
  controls(after: String, filterBy: ControlFilters, first: Int, orderBy: ControlOrder): ControlConnection!
  convertIaCFileToResourceJson(IaCFileContent: String!, type: CloudConfigurationRuleMatcherType!): IaCFileConversionResult!
  customIPRange(id: ID!): CustomIPRange
  customIPRanges(after: String, filterBy: CustomIPRangeFilters, first: Int): CustomIPRangeConnection!
  dashboard(id: ID!): Dashboard
  dashboards(after: String, filterBy: DashboardFilters, first: Int): DashboardConnection!
  dataClassifier(id: ID!): DataClassifier
  dataClassifiers(after: String, filterBy: DataClassifierFilters, first: Int): DataClassifierConnection!
  dataClassifierTest(classifier: DataClassifierTestMatchInput!, data: String!): DataClassifierTestMatchResult!
  dataScannerSettings: DataScannerSettings!
  deployment(id: ID!): Deployment
  deployments(after: String, filterBy: DeploymentFilters, first: Int): DeploymentConnection!
  deploymentSources(after: String, filterBy: DeploymentSourceFilters, first: Int): DeploymentSourceConnection!
  digitalTrustDashboardSettings: DigitalTrustDashboardSettings!
  directoryUser(id: ID!): DirectoryUser
  directoryUsers(after: String, first: Int, search: String): DirectoryUserConnection!
  externalExposureScannerSettings: ExternalExposureScannerSettings!
  fileIntegrityMonitoringExclusion(id: ID!): FileIntegrityMonitoringExclusion
  fileIntegrityMonitoringExclusions(after: String, first: Int): FileIntegrityMonitoringExclusionConnection!
  fileIntegrityMonitoringSettings: FileIntegrityMonitoringSettings!
  getReportAvailableColumns(input: GetReportAvailableColumnsInput!): GetReportAvailableColumnsPayload!
  graphEntity(id: ID!): GraphEntity
  graphSearch(after: String, controlId: ID, first: Int, projectId: String, query: GraphEntityQueryInput, quick: Boolean): GraphSearchResultConnection!
  hostConfigurationRule(id: ID!): HostConfigurationRule
  hostConfigurationRuleAssessment(id: String): HostConfigurationRuleAssessment!
  hostConfigurationRuleAssessments(after: String, filterBy: HostConfigurationRuleAssessmentFilters, first: Int, orderBy: HostConfigurationRuleAssessmentOrder): HostConfigurationRuleAssessmentConnection!
  hostConfigurationRules(after: String, filterBy: HostConfigurationRuleFilters, first: Int, orderBy: HostConfigurationRuleOrder): HostConfigurationRuleConnection!
  hostConfigurationRuleTargetPlatform(id: ID!): HostConfigurationRuleTargetPlatform
  hostConfigurationRuleTargetPlatforms(filterBy: HostConfigurationTargetPlatformsFilters): [HostConfigurationRuleTargetPlatform!]! @deprecated(reason: "use hostConfigurationRuleTechnologies query instead")
  hostConfigurationTargetPlatforms(after: String, filterBy: HostConfigurationRuleTargetPlatformFilters, first: Int): HostConfigurationTargetPlatformConnection!
  ignoreRule(input: ID!): IgnoreRule
  ignoreRules(after: String, filterBy: IgnoreRuleFilters, first: Int): IgnoreRuleConnection!
  integration(id: ID!): Integration!
  integrations(after: String, filterBy: IntegrationFilters, first: Int): IntegrationConnection!
  ipRestrictions: IPRestrictions
  issue(id: ID!): Issue
  issueEvidenceMeta(issueId: ID!): IssueEvidenceMeta
  issues(after: String, filterBy: IssueFilters, first: Int, orderBy: IssueOrder): IssueConnection!
  issueSettings: IssueSettings!
  issuesGroupedByCloudAccount(after: String, filterBy: IssuesGroupedByCloudAccountFilters, first: Int, orderBy: IssuesGroupedByCloudAccountOrder): IssuesGroupedByCloudAccountConnection!
  issuesGroupedByEntity(after: String, filterBy: IssuesGroupedByEntityFilters, first: Int, orderBy: IssuesGroupedByEntityOrder): IssuesGroupedByEntityConnection!
  issuesTrend(endDate: DateTime!, filterBy: IssueFilters, interval: TimeInterval, startDate: DateTime!, type: IssueTrendType): [IssuesTrendDataSeries!]!
  kubernetesCluster(id: ID!): KubernetesCluster
  kubernetesClusters(after: String, filterBy: KubernetesClusterFilters, first: Int): KubernetesClusterConnection!
  lateralMovementPath(id: ID!): LateralMovementPath
  lateralMovementPaths(after: String, filterBy: LateralMovementPathFilters, first: Int): LateralMovementPathConnection!
  loginInfo(email: String!): LoginInfo!
  loginSettings: LoginSettings
  malwareExclusion(id: ID!): MalwareExclusion
  malwareExclusions(after: String, first: Int): MalwareExclusionConnection!
  networkExposures(after: String, filterBy: NetworkExposureFilters, first: Int): NetworkExposureConnection!
  nonOsDiskScanningSettings: NonOSDiskScanningSettings!
  osBenchmark(id: ID!): OSBenchmark
  osBenchmarks(after: String, filterBy: OSBenchmarkFilters, first: Int, orderBy: OSBenchmarksOrder): OSBenchmarksConnection!
  osBenchmarksRuleIds: [String!]!
  outpost(id: ID!): Outpost
  outpostCluster(id: ID!): OutpostCluster
  outpostDeploymentAssets(outpostId: ID!, version: String): OutpostAssets
  outposts(after: String, filterBy: OutpostFilters, first: Int, orderBy: OutpostOrder): OutpostConnection!
  outpostSupportedRegions(cloudEnvironment: OutpostCloudEnvironment!, serviceType: OutpostServiceType!): OutpostSupportedRegions
  outpostVersionManifest(id: ID!): OutpostVersionManifest
  outpostVersionManifests(onlyLatest: Boolean): [OutpostVersionManifest!]!
  policyAssessments(after: String, filterBy: PolicyAssessmentFilters, first: Int): PolicyAssessmentsConnection!
  portalInactivityTimeoutSettings: PortalInactivityTimeoutSettings!
  project(id: ID, slug: String): Project
  projects(after: String, filterBy: ProjectFilters, first: Int, orderBy: ProjectOrder): ProjectConnection!
  projectsWithComplianceAnalytics(after: String, filterBy: ProjectWithComplianceAnalyticsFilters, first: Int, orderBy: ProjectWithComplianceAnalyticsOrder): ProjectWithComplianceAnalyticsConnection!
  report(id: ID!): Report
  reportRun(id: ID!): ReportRun
  reportRuns(after: String, filterBy: ReportRunFilters, first: Int): ReportRunConnection!
  reports(after: String, filterBy: ReportFilters, first: Int): ReportConnection!
  reportSettings: ReportSettings!
  reportType(id: ID!): ReportType
  reportTypes(after: String, filterBy: ReportTypeFilters, first: Int): ReportTypeConnection!
  repositories(after: String, filterBy: RepositoryFilters, first: Int): RepositoryConnection!
  repository(id: ID!): Repository
  requestFileUpload(filename: String!): RequestFileUploadPayload!
  requestScannerSettingsCustomFileDetectionListUpload(filename: String!): RequestScannerSettingsCustomFileDetectionListUploadPayload!
  resourceTagKeys(filterBy: ResourceTagKeysFilters): [String!]!
  resourceTags(filterBy: ResourceTagFilters): [ResourceTag!]!
  samlIdentityProvider(id: ID!): SAMLIdentityProvider
  samlIdentityProviderConfig(name: String!, samlIdentityProviderId: String): SAMLIdentityProviderConfig
  samlIdentityProviderDefaultAttributeMapping: SAMLAttributeMapping!
  samlIdentityProviders(after: String, filterBy: SAMLIdentityProviderFilters, first: Int): SAMLIdentityProviderConnection!
  savedCloudEventFilter(id: ID!): SavedCloudEventFilter
  savedCloudEventFilters(after: String, filterBy: SavedCloudEventFilterFilters, first: Int): SavedCloudEventFilterConnection!
  savedGraphQueries(after: String, filterBy: SavedGraphQueryFilters, first: Int): SavedGraphQueryConnection!
  savedGraphQuery(id: ID!): SavedGraphQuery
  scan(id: ID!): Scan
  scannerAPIRateLimit(id: ID!): ScannerAPIRateLimit
  scannerApiRateLimits(after: String, first: Int): ScannerApiRateLimitConnection!
  scannerExclusionSettings: ScannerExclusionSettings!
  scannerResourceTags: [ScannerResourceTag]!
  scannerSettings: ScannerSettings
  securityCategories(after: String, filterBy: SecurityCategoryFilters, first: Int): SecurityCategoryConnection!
  securityCategory(id: ID!): SecurityCategory
  securityFramework(id: ID!): SecurityFramework
  securityFrameworks(after: String, filterBy: SecurityFrameworkFilters, first: Int): SecurityFrameworkConnection!
  securityScan(id: ID!): SecurityScan!
  securityScans(after: String, filterBy: SecurityScanFilters, first: Int): SecurityScanConnection!
  securityScanSources: [SecurityScanSource!]!
  securitySubCategory(id: ID!): SecuritySubCategory
  sensors(after: String, filterBy: SensorFilters, first: Int, orderBy: SensorOrder): SensorConnection!
  sensorsGroupedByCluster(after: String, filterBy: SensorsGroupedByClusterFilters, first: Int): SensorsGroupedByClusterConnection!
  serviceAccount(id: ID!): ServiceAccount
  serviceAccounts(after: String, filterBy: ServiceAccountFilters, first: Int): ServiceAccountConnection!
  sessionLifetimeSettings: SessionLifetimeSettings!
  signConnectorParams(azureAuthParams: SignAzureConnectorAuthParams, connectorType: String!): SignConnectorParamsResult!
  staticData: StaticDataPayload!
  systemActivities(after: String, filterBy: SystemActivityFilters, first: Int): SystemActivityConnection!
  systemHealthIssue(id: ID!): SystemHealthIssue
  systemHealthIssues(after: String, filterBy: SystemHealthIssueFilters, first: Int, orderBy: SystemHealthIssueOrder): SystemHealthIssueConnection!
  systemHealthIssuesGroupedByDeployment(after: String, filterBy: SystemHealthIssuesGroupedByDeploymentFilters, first: Int): SystemHealthIssuesGroupedByDeploymentConnection!
  systemHealthIssuesGroupedBySource(after: String, filterBy: SystemHealthIssuesGroupedBySourceFilters, first: Int): SystemHealthIssuesGroupedBySourceConnection!
  systemHealthIssuesGroupedByType(after: String, filterBy: SystemHealthIssuesGroupedByTypeFilters, first: Int): SystemHealthIssuesGroupedByTypeConnection!
  technologies(after: String, filterBy: TechnologyFilters, first: Int, orderBy: TechnologyOrder): TechnologyConnection!
  technology(id: ID!): Technology!
  tenantIdentityClient(cloudProvider: CloudProvider!): TenantIdentityClient
  testConnectorConfig(authParams: JSON!, type: ID!): ConnectorConfigTestResult!
  testIntegrationAction(input: TestIntegrationActionInput!): IntegrationActionTestResult!
  uiUserPreferences: UIUserPreferences!
  user(id: ID!): User
  userRoles(after: String, first: Int): UserRoleConnection!
  users(after: String, filterBy: UserFilters, first: Int): UserConnection!
  validatableCloudConfigurationRule(id: ID!): ValidatableCloudConfigurationRule! @deprecated(reason: "use cloudConfigurationRule query instead")
  viewer: User!
  vulnerabilities(after: String, filterBy: VulnerabilityFilters, first: Int, orderBy: VulnerabilityOrder): VulnerabilityConnection!
  vulnerability(id: ID!): Vulnerability
  vulnerabilityByExternalId(externalId: String!): Vulnerability
  vulnerabilityFinding(id: ID!): VulnerabilityFinding
  vulnerabilityFindings(after: String, filterBy: VulnerabilityFindingFilters, first: Int, orderBy: VulnerabilityFindingOrder): VulnerabilityFindingConnection!
  vulnerabilityFindingsGroupedByLayer(resourceId: ID!, resourceType: VulnerabilityFindingsGroupedByLayerResourceType!): [VulnerabilityFindingsGroupedByLayer!]!
  vulnerabilityVendorAdvisories(after: String, filterBy: VulnerabilityVendorAdvisoryFilters, first: Int): VulnerabilityVendorAdvisoryConnection!
  vulnerabilityVendorAdvisory(id: ID!): VulnerabilityVendorAdvisory!
}

input ReassessIssueInput {
  issueId: ID!
}

type ReassessIssuePayload {
  _stub: String!
}

input RegisterAgentClientConfigInput {
  version: String!
  policies: [String!]
  errorEnforcement: AdmissionControllerEnforcementMethod
  policyEnforcement: AdmissionControllerEnforcementMethod
}

input RegisterAgentInput {
  externalId: String!
  referenceObjectExternalId: String!
  referenceObjectObjectType: String!
  clientConfig: RegisterAgentClientConfigInput!
}

type RegisterAgentPayload {
  agentId: String!
}

enum RegulatoryStandard {
  ISO_20000_1_2011
  ISO_22301
  ISO_27001
  ISO_27017
  ISO_27018
  ISO_27701
  ISO_9001
  SOC
  FEDRAMP
  NIST_800_171
  NIST_CSF
  HIPPA_HITECH @deprecated(reason: "use HIPAA_HITECH instead")
  HIPAA_HITECH
  HITRUST
  PCI_DSS
  SEC_17A_4
  SEC_REGULATION_SCI
  SOX
  GDPR
}

type Report implements Node {
  columnSelection: [String!]
  createdBy: User!
  csvDelimiter: CSVDelimiter
  emailTarget: EmailTarget
  id: ID!
  lastRun: ReportRun
  lastSuccessfulRun: ReportRun
  name: String!
  nextRunAt: DateTime
  parameters: ReportParameters! @deprecated(reason: "Use params instead")
  params: ReportParams!
  project: Project
  runIntervalHours: Int
  runStartsAt: DateTime
  type: ReportType!
}

type ReportConnection {
  edges: [ReportEdge!]
  nodes: [Report!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReportEdge {
  cursor: String!
  node: Report!
}

input ReportFilters {
  search: String
  type: [String!]
  projectId: String
  lastReportRunStatus: [ReportRunStatus!]
}

type ReportGraphQueryEntityOptions {
  entityType: GraphEntityTypeValue!
  propertyOptions: [ReportGraphQueryPropertyOptions!]!
}

type ReportGraphQueryPropertyOptions {
  key: String!
}

type ReportParameters {
  entities: [GraphEntity]
  framework: SecurityFramework
  query: GraphEntityQueryValue
  subscriptions: [GraphEntity]
}

union ReportParams = ReportParamsGraphQuery | ReportParamsVulnerabilities | ReportParamsComplianceExecutiveSummary | ReportParamsComplianceAssessments | ReportParamsNetworkExposure | ReportParamsConfigurationFindings | ReportParamsSecurityFramework | ReportParamsIssue | ReportParamsHostConfiguration | ReportParamsCloudResource

type ReportParamsCloudResource {
  cloudPlatform: [String!]
  entityType: [GraphEntityTypeValue!]!
  includeCloudNativeJSON: Boolean!
  includeWizJSON: Boolean!
  nativeType: [String!]
  region: [String!]
  subscriptionId: [String!]
}

type ReportParamsComplianceAssessments {
  categories: [SecurityFramework]
  frameworks: [SecurityFramework]
  result: [PolicyAssessmentResult]
  subscriptions: [GraphEntity]
}

type ReportParamsComplianceExecutiveSummary {
  framework: SecurityFramework
  subscriptions: [GraphEntity]
}

type ReportParamsConfigurationFindings {
  entities: [GraphEntity]
  subscriptions: [GraphEntity]
}

type ReportParamsGraphQuery {
  entityOptions: [ReportGraphQueryEntityOptions!]
  query: GraphEntityQueryValue!
}

type ReportParamsHostConfiguration {
  hostConfigurationRuleAssessmentsFilters: JSON
}

type ReportParamsIssue {
  evidenceGraphEntityTypesToInclude: [GraphEntityTypeValue!]
  issueFilters: JSON
  issueReportType: IssueReportType!
}

type ReportParamsNetworkExposure {
  entities: [GraphEntity]
  subscriptions: [GraphEntity]
}

type ReportParamsSecurityFramework {
  entities: [GraphEntity]
  subscriptions: [GraphEntity]
}

type ReportParamsVulnerabilities {
  assetType: VulnerableAssetObjectType
  filters: JSON
  type: VulnerabilityReportType
}

type ReportRun implements Node {
  failedReason: String
  id: ID!
  progress: Int!
  report: Report!
  results: ReportRunResults
  runAt: DateTime!
  status: ReportRunStatus!
  url: String
}

type ReportRunConnection {
  edges: [ReportRunEdge!]
  nodes: [ReportRun!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReportRunEdge {
  cursor: String!
  node: ReportRun!
}

input ReportRunFilters {
  reportId: String
}

union ReportRunResults = ReportRunResultsBenchmark | ReportRunResultsGraphQuery | ReportRunResultsNetworkExposure | ReportRunResultsConfigurationFindings | ReportRunResultsVulnerabilities | ReportRunResultsIssues | ReportRunResultsCloudResource

type ReportRunResultsBenchmark {
  errorCount: Int!
  failedCount: Int!
  passedCount: Int!
  scannedCount: Int!
}

type ReportRunResultsCloudResource {
  count: Int!
  limitReached: Boolean!
}

type ReportRunResultsConfigurationFindings {
  findingsCount: Int!
}

type ReportRunResultsGraphQuery {
  entityCount: Int!
  resultCount: Int!
}

type ReportRunResultsIssues {
  count: Int!
}

type ReportRunResultsNetworkExposure {
  publiclyAccessibleCount: Int!
  scannedCount: Int!
}

type ReportRunResultsVulnerabilities {
  count: Int!
}

enum ReportRunStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  EXPIRED
}

type ReportSettings {
  retentionDays: Int!
}

type ReportType implements Node {
  description: String
  id: ID!
  name: String!
}

type ReportTypeConnection {
  edges: [ReportTypeEdge!]
  nodes: [ReportType!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReportTypeEdge {
  cursor: String!
  node: ReportType!
}

input ReportTypeFilters {
  search: String
}

type Repository implements Node {
  connector: Connector!
  id: ID!
  name: String!
}

type RepositoryConnection {
  edges: [RepositoryEdge!]
  nodes: [Repository!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryEdge {
  cursor: String!
  node: Repository!
}

input RepositoryFilters {
  search: [String!]
  projectId: String
}

input RequestConnectorEntityScanInput {
  id: String
  objectParams: EntityScanParamsInput
  externalId: String
  type: GraphEntityTypeValue!
  connectorId: String
}

input RequestConnectorScanInput {
  id: String!
}

type RequestFileUploadPayload {
  upload: FileUpload!
}

type RequestScannerSettingsCustomFileDetectionListUploadPayload {
  upload: ScannerSettingsCustomFileDetectionListUpload!
}

type RequestScanPayload {
  reason: String @deprecated(reason: "A failure will be returned using standard graphql failure, so this will always be empty")
  scan: Scan
  success: Boolean! @deprecated(reason: "A failure will be returned using standard graphql failure, so this will always be true")
}

input RerunReportInput {
  id: ID!
}

type RerunReportPayload {
  report: Report
}

input ResetUserPasswordInput {
  userId: ID!
}

type ResetUserPasswordPayload {
  _stub: String!
}

type ResourceTag {
  key: String!
  value: String!
}

input ResourceTagFilters {
  cloudAccountId: String
  keyEquals: String
  keyContains: String
  valueContains: String
  entityType: [GraphEntityTypeValue!]
}

input ResourceTagInput {
  key: String!
  value: String!
}

input ResourceTagKeysFilters {
  cloudAccountId: String
  search: String
  entityType: [GraphEntityTypeValue!]
}

type RotateServiceAccountSecretPayload {
  serviceAccount: ServiceAccount
}

type RunAllControlsPayload {
  _stub: String!
}

input RunCloudConfigurationRuleInput {
  id: ID!
}

type RunCloudConfigurationRulePayload {
  rule: CloudConfigurationRule
}

input RunControlInput {
  id: ID!
}

type RunControlPayload {
  control: Control
}

input RunControlsIntegrationInput {
  projectId: ID
  controlFilters: ControlFilters!
  integrationId: ID!
  actionTemplateType: ActionTemplateType!
  actionTemplateParams: ActionTemplateParamsInput
}

type RunControlsIntegrationPayload {
  results: [RunControlsIntegrationResult!]
  status: ManualIntegrationRunStatus!
}

type RunControlsIntegrationResult {
  control: Control!
  reason: String
  serviceTicket: ServiceTicket
}

type RunIssueAutomationActionError {
  issue: Issue!
  reason: String
}

input RunIssueAutomationActionInput {
  actionId: String!
  issueId: String!
  overrideActionParams: JSON
}

type RunIssueAutomationActionPayload {
  serviceTicket: ServiceTicket
}

input RunIssuesAutomationActionInput {
  actionId: String!
  issueIds: [String!]
  issueFilters: IssueFilters
  overrideActionParams: JSON
}

type RunIssuesAutomationActionPayload {
  errors: [RunIssueAutomationActionError!]
  failCount: Int!
  serviceTickets: [ServiceTicket!]
  successCount: Int!
}

input RunIssuesIntegrationInput {
  issueFilters: IssueFilters
  integrationId: ID!
  actionTemplateType: ActionTemplateType!
  actionTemplateParams: ActionTemplateParamsInput
}

type RunIssuesIntegrationPayload {
  results: [RunIssuesIntegrationResult!]
  status: IssuesIntegrationRunStatus!
}

type RunIssuesIntegrationResult {
  issue: Issue!
  reason: String
  serviceTicket: ServiceTicket
}

type SAMLAttributeMapping {
  email: String!
  groups: String!
  name: String!
  projectIds: String!
  role: String!
}

input SAMLAttributeMappingInput {
  name: String
  email: String
  groups: String
  role: String
  projectIds: String
}

type SAMLGroupMapping {
  projects: [Project!]
  providerGroupId: ID!
  role: UserRole!
}

input SAMLGroupMappingCreateInput {
  providerGroupId: String!
  role: String!
  projects: [String!]
}

input SAMLGroupMappingUpdateInput {
  providerGroupId: String!
  role: String!
  projects: [String!]
}

type SAMLIdentityProvider {
  allowManualRoleOverride: Boolean!
  attributeMapping: SAMLAttributeMapping
  certificate: String!
  domains: [String!]
  groupMapping: [SAMLGroupMapping!]
  id: ID!
  issuerURL: String
  loginURL: String!
  logoutURL: String!
  mergeGroupsMappingByRole: Boolean!
  name: String!
  useProviderManagedRoles: Boolean!
}

type SAMLIdentityProviderConfig {
  idpLoginUrl: String!
  serviceProviderId: String!
  spCertificate: String!
  spLogoutUrl: String!
  ssoUrl: String!
}

type SAMLIdentityProviderConnection {
  edges: [SAMLIdentityProviderEdge!]
  nodes: [SAMLIdentityProvider!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SAMLIdentityProviderEdge {
  cursor: String!
  node: SAMLIdentityProvider!
}

input SAMLIdentityProviderFilters {
  search: String
  source: AuthenticationSource
}

type SavedCloudEventFilter implements Node {
  createdAt: DateTime!
  createdBy: User
  description: String
  filters: JSON!
  id: ID!
  name: String!
  project: Project
  securitySubCategories: [SecuritySubCategory!]
  updatedAt: DateTime!
}

type SavedCloudEventFilterConnection {
  edges: [SavedCloudEventFilterEdge!]
  nodes: [SavedCloudEventFilter!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input SavedCloudEventFilterDateTimeFilter {
  before: DateTime
  after: DateTime
}

type SavedCloudEventFilterEdge {
  cursor: String!
  node: SavedCloudEventFilter!
}

input SavedCloudEventFilterFilters {
  search: String
  createdByType: SavedCloudEventFiltersCreatedByType
  frameworkCategory: [String!]
  project: [String!]
  updatedAt: SavedCloudEventFilterDateTimeFilter
}

enum SavedCloudEventFiltersCreatedByType {
  USER
  BUILT_IN
}

type SavedGraphQuery implements Node {
  createdAt: DateTime!
  createdBy: User
  description: String
  externalReferences: [SavedGraphQueryExternalReference!]
  id: ID!
  name: String!
  project: Project
  query: GraphEntityQueryValue!
  securitySubCategories: [SecuritySubCategory!]
  updatedAt: DateTime!
}

type SavedGraphQueryConnection {
  edges: [SavedGraphQueryEdge!]
  nodes: [SavedGraphQuery!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SavedGraphQueryEdge {
  cursor: String!
  node: SavedGraphQuery!
}

type SavedGraphQueryExternalReference {
  id: String!
  name: String!
}

input SavedGraphQueryFilters {
  search: String
  type: SavedGraphQueryType
  securityFramework: [String!]
  securitySubCategory: [String!]
  securityCategory: [String!]
  frameworkCategory: [String!]
  project: [String!]
}

enum SavedGraphQueryType {
  USER_CREATED
  BUILT_IN
}

type Scan implements Node {
  configurationFindings(after: String, filterBy: ConfigurationFindingFilters, first: Int): ConfigurationFindingConnection!
  errors: JSON
  findingsEvaluatedAt: DateTime
  findingsReady: Boolean!
  id: ID!
  initiatedAt: DateTime
  issues(after: String, filterBy: IssueFilters, first: Int): IssueConnection!
  issuesEvaluatedAt: DateTime
  issuesReady: Boolean!
  progressLog: JSON
}

type ScannerAPIRateLimit {
  cloudProvider: CloudProvider!
  id: ID!
  mutationRequestsPerSecond: Int
  queryRequestsPerSecond: Int
  service: ScannerAPIRateLimitService!
}

type ScannerApiRateLimitConnection {
  edges: [ScannerApiRateLimitEdge!]
  nodes: [ScannerAPIRateLimit!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ScannerApiRateLimitEdge {
  cursor: String!
  node: ScannerAPIRateLimit!
}

enum ScannerAPIRateLimitService {
  EC2
}

type ScannerExclusionSettings {
  sizeLimits: ScannerExclusionSizeLimits
  tags: [ScannerExclusionTag!]!
}

type ScannerExclusionSizeLimits {
  diskSizeGB: Int
}

type ScannerExclusionTag {
  key: String!
  value: String
}

type ScannerResourceTag {
  key: String!
  value: String
}

type ScannerSettings {
  computeResourceGroupByTags: [ComputeGroupTagsSet!] @deprecated(reason: "use createComputeGroupTagSet instead")
  computeResourceGroupMemberScanSamplingEnabled: Boolean!
  customFileDetectionList: ScannerSettingsCustomFileDetectionListUpload
  excessiveAccessDaysThreshold: Int!
  externalFindingSources: ScannerSettingsExternalFindingSources!
  maxComputeResourceGroupMemberScanCount: Int!
  prioritizeActiveComputeResourceGroupMembers: Boolean!
  unmanagedComputeResourceGroupScanSamplingDisabled: Boolean!
}

type ScannerSettingsAwsInspectorConfig {
  enabled: Boolean!
}

type ScannerSettingsAwsMacieConfig {
  enabled: Boolean!
}

type ScannerSettingsAzureSecurityCenterConfig {
  enabled: Boolean!
}

type ScannerSettingsCustomFileDetectionListUpload implements Node {
  createdAt: DateTime!
  createdBy: User!
  fileDetectionCount: Int!
  id: ID!
  name: String!
  url: String!
}

type ScannerSettingsExternalFindingSources {
  awsInspectorConfig: ScannerSettingsAwsInspectorConfig!
  awsMacieConfig: ScannerSettingsAwsMacieConfig!
  azureSecurityCenterConfig: ScannerSettingsAzureSecurityCenterConfig!
}

type SecurityCategory implements Node {
  description: String!
  externalId: String! @deprecated(reason: "Deprecated property")
  framework: SecurityFramework!
  id: ID!
  issueAnalytics(selection: SecurityCategoryIssueAnalyticsSelection): IssueAnalytics!
  name: String!
  subCategories: [SecuritySubCategory!]!
}

type SecurityCategoryComplianceAnalytics {
  averageCompliancePosture: Int
  category: SecurityCategory!
  emptyPostureReason: ComplianceEmptyPostureReason
  failSubCategoryCount: Int!
  passSubCategoryCount: Int!
  subCategoryAnalytics: [SecuritySubCategoryComplianceAnalytics!]!
}

type SecurityCategoryConnection {
  edges: [SecurityCategoryEdge!]
  nodes: [SecurityCategory!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SecurityCategoryEdge {
  cursor: String!
  node: SecurityCategory!
}

input SecurityCategoryFilters {
  search: String
  securityFramework: String
}

input SecurityCategoryInput {
  id: ID
  name: String!
  description: String
  externalId: String
  subCategories: [SecuritySubCategoryInput!]!
}

input SecurityCategoryIssueAnalyticsSelection {
  project: [String!]
}

type SecurityFramework implements Node {
  builtin: Boolean!
  categories: [SecurityCategory!]!
  cloudConfigurationRules(after: String, filterBy: CloudConfigurationRuleFilters, first: Int, orderBy: CloudConfigurationRuleOrder): CloudConfigurationRuleConnection!
  complianceAnalytics(selection: SecurityFrameworkComplianceAnalyticsSelection): SecurityFrameworkComplianceAnalytics!
  complianceTrend(endDate: DateTime!, interval: SecurityFrameworkComplianceTrendTimeInterval, selection: SecurityFrameworkComplianceTrendSelection, startDate: DateTime!): SecurityFrameworkComplianceTrendDataSeries!
  controls(after: String, filterBy: ControlFilters, first: Int, orderBy: ControlOrder): ControlConnection!
  description: String
  enabled: Boolean!
  hostConfigurationRules(after: String, filterBy: HostConfigurationRuleFilters, first: Int, orderBy: HostConfigurationRuleOrder): HostConfigurationRuleConnection!
  id: ID!
  name: String!
  policyTypes: [SecurityFrameworkPolicyType!]
}

type SecurityFrameworkComplianceAnalytics {
  averageCompliancePosture: Int
  categoryAnalytics: [SecurityCategoryComplianceAnalytics!]!
  emptyPostureReason: ComplianceEmptyPostureReason
  failSubCategoryCount: Int!
  passSubCategoryCount: Int!
}

input SecurityFrameworkComplianceAnalyticsSelection {
  projectId: [String!]
  cloudAccount: [String!]
}

type SecurityFrameworkComplianceTrendDataPoint {
  failCount: Int
  passCount: Int
  score: Int
  time: DateTime!
}

type SecurityFrameworkComplianceTrendDataSeries {
  dataPoints: [SecurityFrameworkComplianceTrendDataPoint!]!
}

input SecurityFrameworkComplianceTrendSelection {
  projectId: [String!]
  cloudAccount: [String!]
}

enum SecurityFrameworkComplianceTrendTimeInterval {
  DAY
}

type SecurityFrameworkConnection {
  edges: [SecurityFrameworkEdge!]
  nodes: [SecurityFramework!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SecurityFrameworkEdge {
  cursor: String!
  node: SecurityFramework!
}

enum SecurityFrameworkFamily {
  CLOUD
  HOST
}

input SecurityFrameworkFilters {
  search: String
  securityFramework: [String!]
  enabled: Boolean
  family: [SecurityFrameworkFamily!]
  policyTypes: [SecurityFrameworkPolicyType!]
}

input SecurityFrameworkPatch {
  name: String
  description: String
  enabled: Boolean
  categories: [SecurityCategoryInput!]
}

input SecurityFrameworkPatchOptions {
  unassignPoliciesOnAllEmptySubCategories: Boolean
}

enum SecurityFrameworkPolicyType {
  CLOUD
  HOST
}

type SecurityScan implements Node {
  addedBy: UserOrConnector!
  error: SecurityScanError
  file: FileUpload
  id: ID!
  scannedAt: DateTime
  scopeObject: GraphEntity
  scopeObjectHint: String
  scopeObjectType: GraphEntityTypeValue
  source: SecurityScanSource
  status: SecurityScanStatus!
  updatedAt: DateTime!
}

type SecurityScanConnection {
  edges: [SecurityScanEdge!]
  nodes: [SecurityScan!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SecurityScanEdge {
  cursor: String!
  node: SecurityScan!
}

enum SecurityScanError {
  UNKNOWN_FORMAT
  MALFORMED_FILE
  MISSING_SCOPE
}

input SecurityScanFilters {
  status: [SecurityScanStatus!]
  source: [String!]
  object: String
}

type SecurityScanSource implements Node {
  id: ID!
  name: String!
  technology: Technology!
}

enum SecurityScanStatus {
  PROCESSING
  SUCCESS
  ERROR
}

type SecuritySubCategory implements Node {
  category: SecurityCategory!
  cloudConfigurationRules(after: String, filterBy: CloudConfigurationRuleFilters, first: Int, orderBy: CloudConfigurationRuleOrder): CloudConfigurationRuleConnection!
  controls(after: String, filterBy: ControlFilters, first: Int, orderBy: ControlOrder): ControlConnection!
  description: String!
  externalId: String! @deprecated(reason: "Deprecated property")
  hostConfigurationRules(after: String, filterBy: HostConfigurationRuleFilters, first: Int, orderBy: HostConfigurationRuleOrder): HostConfigurationRuleConnection!
  id: ID!
  issueAnalytics(selection: SecuritySubCategoryIssueAnalyticsSelection): IssueAnalytics!
  resolutionRecommendation: String
  title: String!
}

type SecuritySubCategoryAssignmentError {
  message: String
  policy: SecuritySubCategoryPolicy
  subCategories: [SecuritySubCategoryDetails!]
  type: SecuritySubCategoryAssignmentErrorType!
}

enum SecuritySubCategoryAssignmentErrorType {
  INTERNAL_ERROR
  INVALID_TENANT_ID
  TENANT_NOT_FOUND
  INVALID_SECURITY_POLICY_ID
  SECURITY_POLICY_NOT_FOUND
  INVALID_SUBCATEGORY_ID
  SUBCATEGORY_NOT_FOUND
  SUBCATEGORY_ASSIGNMENT_FAILED
}

type SecuritySubCategoryComplianceAnalytics {
  compliancePosture: Int
  emptyPostureReason: ComplianceEmptyPostureReason
  policyAnalytics: [PolicyComplianceAnalytics!]
  subCategory: SecuritySubCategory!
}

union SecuritySubCategoryDetails = SecuritySubCategory | SecuritySubCategoryInvalidObject

input SecuritySubCategoryInput {
  id: ID
  title: String!
  description: String
  externalId: String
  resolutionRecommendation: String
  controls: [String!]
  cloudConfigurationRules: [String!]
  hostConfigurationRules: [String!]
}

type SecuritySubCategoryInvalidObject {
  id: String!
}

input SecuritySubCategoryIssueAnalyticsSelection {
  project: [String!]
}

union SecuritySubCategoryPolicy = Control | CloudConfigurationRule | HostConfigurationRule | SecuritySubCategoryInvalidObject

input SelfManagedOutpostClusterInput {
  perCloudConfig: PerCloudSelfManagedOutpostClusterInput!
}

input SendUserEmailInviteInput {
  userId: ID!
}

type SendUserEmailInvitePayload {
  _stub: String!
}

type Sensor implements Node {
  cluster: GraphEntity
  definitionsVersion: String!
  errors: [SensorError!]
  firstSeenAt: DateTime!
  id: ID!
  ipAddress: String!
  lastSeenAt: DateTime!
  name: String!
  sensorVersion: String!
  status: SensorStatus!
  workload: GraphEntity
}

type SensorConnection {
  edges: [SensorEdge!]
  nodes: [Sensor!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input SensorDateFilter {
  before: DateTime
  after: DateTime
  inLast: DurationFilter
  beforeLast: DurationFilter
}

type SensorEdge {
  cursor: String!
  node: Sensor!
}

type SensorEngineMatchedRule {
  rule: SensorEngineRule!
  version: Int!
}

type SensorEngineRule implements Node {
  description: String!
  externalId: String!
  id: ID!
  name: String!
  version: Int!
}

type SensorError {
  message: String
  type: SensorErrorType!
}

enum SensorErrorType {
  INTERNAL_ERROR
}

input SensorFilters {
  search: String
  status: [SensorStatus!]
  project: [String!]
  sensorVersion: SensorVersionFilter
  definitionsVersion: SensorVersionFilter
  lastSeenAt: SensorDateFilter
  firstSeenAt: SensorDateFilter
  cluster: [String!]
}

input SensorOrder {
  direction: OrderDirection!
  field: SensorOrderField!
}

enum SensorOrderField {
  STATUS
  LAST_SEEN
  FIRST_SEEN
}

type SensorsGroupedByCluster implements Node {
  id: ID!
  resource: GraphEntity
  sensors(after: String, filterBy: SensorFilters, first: Int): SensorConnection!
}

type SensorsGroupedByClusterConnection {
  edges: [SensorsGroupedByClusterEdge!]
  nodes: [SensorsGroupedByCluster!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SensorsGroupedByClusterEdge {
  cursor: String!
  node: SensorsGroupedByCluster!
}

input SensorsGroupedByClusterFilters {
  search: String
  cluster: [String!]
}

enum SensorStatus {
  ACTIVE
  INACTIVE
}

input SensorVersionFilter {
  min: String
  max: String
}

type ServiceAccount implements Node {
  assignedProjects: [Project!]
  authenticationSource: AuthenticationSource!
  clientId: String!
  clientSecret: String!
  createdAt: DateTime!
  id: ID!
  lastRotatedAt: DateTime!
  name: String!
  scopes: [String!]!
  type: ServiceAccountType!
}

type ServiceAccountConnection {
  edges: [ServiceAccountEdge!]
  nodes: [ServiceAccount!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ServiceAccountEdge {
  cursor: String!
  node: ServiceAccount!
}

input ServiceAccountFilters {
  name: String
  source: AuthenticationSource
  type: [ServiceAccountType!]
}

enum ServiceAccountType {
  THIRD_PARTY
  SENSOR
  KUBERNETES_ADMISSION_CONTROLLER
  BROKER
}

type ServiceNowActionCreateTicketTemplateParams {
  fields: ServiceNowTicketFields!
}

input ServiceNowActionCreateTicketTemplateParamsInput {
  fields: CreateServiceNowFieldsInput!
}

type ServiceNowActionUpdateTicketTemplateParams {
  attachIssuesReport: Boolean
  fields: JSON
  tableName: String!
}

input ServiceNowActionUpdateTicketTemplateParamsInput {
  tableName: String!
  fields: JSON
  attachIssuesReport: Boolean
}

type ServiceNowAutomationActionParams {
  baseUrl: String!
  clientId: String
  clientSecret: String
  password: String!
  ticketFields: ServiceNowTicketFields!
  user: String!
}

union ServiceNowIntegrationAuthorization = ServiceNowIntegrationBasicAuthorization | ServiceNowIntegrationOAuthAuthorization

input ServiceNowIntegrationAuthorizationInput {
  username: String!
  password: String!
  clientId: String
  clientSecret: String
}

type ServiceNowIntegrationBasicAuthorization {
  password: String!
  username: String!
}

type ServiceNowIntegrationOAuthAuthorization {
  clientId: String!
  clientSecret: String!
  password: String!
  username: String!
}

type ServiceNowIntegrationParams {
  authorization: ServiceNowIntegrationAuthorization!
  url: String!
}

type ServiceNowTicketFields {
  attachEvidenceCSV: Boolean
  customFields: JSON
  description: String!
  summary: String!
  tableName: String!
}

type ServiceNowUpdateTicketAutomationActionParams {
  baseUrl: String!
  clientId: String
  clientSecret: String
  fields: JSON
  password: String!
  tableName: String!
  user: String!
}

type ServiceTicket implements Node {
  action: AutomationAction
  externalId: ID!
  id: ID!
  integration: Integration
  name: String!
  project: Project
  url: String!
}

type SessionLifetimeSettings {
  serviceAccountSessionLifetimeMinutes: Int
  userSessionLifetimeMinutes: Int
}

input SessionLifetimeSettingsPatch {
  userSessionLifetimeMinutes: Int
  serviceAccountSessionLifetimeMinutes: Int
}

enum Severity {
  INFORMATIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

input SignAzureConnectorAuthParams {
  azureTenantId: String!
  code: String!
}

type SignConnectorParamsResult {
  code: String
  success: Boolean!
}

type SlackActionTemplateParams {
  channel: String @deprecated(reason: "This parameter is no longer supported by Slack")
  note: String
}

input SlackActionTemplateParamsInput {
  note: String
}

type SlackBotActionTemplateParams {
  channel: String!
  note: String
}

input SlackBotActionTemplateParamsInput {
  note: String
  channel: String!
}

type SlackBotIntegrationParams {
  token: String!
}

type SlackIntegrationParams {
  channel: String @deprecated(reason: "This parameter is no longer supported by Slack")
  url: String!
}

type SlackMessageAutomationActionParams {
  channel: String @deprecated(reason: "This parameter is no longer supported by Slack")
  note: String @deprecated(reason: "This parameter is no longer supported by Slack")
  url: String!
}

type SmoochAuth {
  externalId: String!
  token: String!
}

input SmoochFileUploadInput {
  conversationId: String!
  fileName: String!
  content: String!
}

type SmoochFileUploadPayload {
  fileUploadUrl: String!
}

type StaticDataPayload {
  diskAnalyzerOvalWindowsUrl: StaticDataURL!
  diskAnalyzerUrl: StaticDataURL!
  iacRegoLibsUrl: StaticDataURL!
}

type StaticDataURL {
  url: String!
  version: String!
}

enum SubscriptionPlanStatus {
  UNDEFINED
  PAID
  TRIAL
  EXPIRED
  TERMINATED
  PENDING
}

type SystemActivity implements Node {
  context: SystemActivityContext!
  createdAt: DateTime!
  endedAt: DateTime
  id: ID!
  name: String!
  startedAt: DateTime
  status: SystemActivityStatus!
  statusInfo: String
  summary: JSON
  triggeredBy: SystemActivityTrigger!
  triggerType: SystemActivityTriggerType!
}

type SystemActivityAnalyzerContext {
  name: String!
}

type SystemActivityAutomationActionContext {
  action: SystemActivityAutomationActionSnapshot!
  entity: SystemActivityGraphEntitySnapshot
  issue: SystemActivityIssueSnapshot
  parameters: JSON!
  project: SystemActivityAutomationActionProjectSnapshot
  rule: SystemActivityAutomationRuleSnapshot
}

type SystemActivityAutomationActionProjectSnapshot {
  id: String!
  name: String!
}

type SystemActivityAutomationActionSnapshot {
  id: String!
  name: String!
  type: AutomationActionTypeValue!
}

type SystemActivityAutomationRuleSnapshot {
  id: String!
  name: String!
}

type SystemActivityClusterSnapshot {
  name: String!
  region: String!
}

type SystemActivityConnection {
  edges: [SystemActivityEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 5000): String
  nodes: [SystemActivity!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SystemActivityConnectorSnapshot {
  id: String!
  name: String!
  type: ConnectorType!
}

union SystemActivityContext = SystemActivityAutomationActionContext | SystemActivityIntegrationActionContext | SystemActivityScanContext | SystemActivityAnalyzerContext | SystemActivityUninstallOutpostContext | SystemActivityReassessIssueContext

type SystemActivityControlSnapshot {
  id: String!
  name: String!
}

type SystemActivityEdge {
  cursor: String!
  node: SystemActivity!
}

input SystemActivityFilters {
  search: String
  automationActionId: [String!]
  integrationId: [String!]
  ruleId: [String!]
  issueId: [String!]
  controlId: [String!]
  resourceId: [String!]
  userId: [String!]
  serviceAccountId: [String!]
  triggeredByType: [SystemActivityTriggeredByType!]
  activityType: [SystemActivityType!]
  projectId: [String!]
  status: [SystemActivityStatus!]
  startedAt: SystemActivityTimestampFilter
  endedAt: SystemActivityTimestampFilter
  outpostId: [String!]
  connectorId: [String!]
}

type SystemActivityGraphEntitySnapshot {
  id: String!
  name: String!
  nativeType: String!
  type: GraphEntityTypeValue!
}

type SystemActivityIntegrationActionContext {
  action: SystemActivityIntegrationActionSnapshot!
  control: SystemActivityControlSnapshot
  entity: SystemActivityGraphEntitySnapshot
  integration: SystemActivityIntegrationSnapshot!
  issue: SystemActivityIssueSnapshot
  project: Project @deprecated(reason: "use projects instead")
  projects: [Project!]
  rule: SystemActivityAutomationRuleSnapshot
}

type SystemActivityIntegrationActionSnapshot {
  id: String!
  params: JSON
  type: String!
}

type SystemActivityIntegrationSnapshot {
  id: String!
  name: String!
  type: IntegrationTypeValue!
}

type SystemActivityIssueSnapshot {
  controlId: String
  controlName: String!
  id: String!
}

type SystemActivityOutpostSnapshot {
  id: String!
  name: String!
  serviceType: String!
}

enum SystemActivityOutpostUninstallStage {
  SCANNER_RESOURCES
  SCANNER_CLUSTER
  GENERAL_RESOURCES
}

type SystemActivityReassessIssueContext {
  issue: SystemActivityIssueSnapshot!
  projects: [Project!]
  resource: SystemActivityGraphEntitySnapshot!
}

type SystemActivityScanContext {
  connector: SystemActivityConnectorSnapshot
  projects: [Project!]
  scannedEntity: SystemActivityGraphEntitySnapshot
  type: SystemActivityScanType!
}

enum SystemActivityScanType {
  METADATA
  DISK_ANALYSIS
}

type SystemActivityServiceAccountSnapshot {
  id: String!
  name: String!
}

enum SystemActivityStatus {
  SUCCESS
  FAILURE
  IN_PROGRESS
  SKIPPED
  PENDING
}

type SystemActivitySystemTrigger {
  id: String!
}

input SystemActivityTimestampFilter {
  before: DateTime
  after: DateTime
}

union SystemActivityTrigger = SystemActivityUserSnapshot | SystemActivityServiceAccountSnapshot | SystemActivitySystemTrigger

enum SystemActivityTriggeredByType {
  USER
  SERVICE_ACCOUNT
  SYSTEM
}

enum SystemActivityTriggerType {
  ISSUE_CREATED
  ISSUE_UPDATED
  MANUAL
  SCHEDULED
  CLOUD_EVENT_MATCHED
  CONTROL_MATCHED
}

enum SystemActivityType {
  ACTION @deprecated(reason: "Use INTEGRATION_ACTION instead")
  ANALYZER
  SCAN
  UNINSTALLER
  ASSESSMENT
  INTEGRATION_ACTION
}

type SystemActivityUninstallOutpostContext {
  cluster: SystemActivityClusterSnapshot!
  outpost: SystemActivityOutpostSnapshot!
  stage: SystemActivityOutpostUninstallStage!
}

type SystemActivityUserSnapshot {
  id: String!
  name: String!
}

type SystemHealthIssue {
  deployment: Deployment!
  id: ID!
  impact: String!
  lastSeenAt: DateTime!
  name: String!
  region: String
  remediation: String!
  serviceTickets: [ServiceTicket!]
  severity: SystemHealthIssueSeverity!
  source: DeploymentSource
  status: SystemHealthIssueStatus!
  type: SystemHealthIssueType!
}

type SystemHealthIssueConnection {
  advisorySeverityCount: Int!
  criticalSeverityCount: Int!
  edges: [SystemHealthIssueEdge!]
  highSeverityCount: Int!
  informationalSeverityCount: Int!
  lowSeverityCount: Int!
  mediumSeverityCount: Int!
  nodes: [SystemHealthIssue!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SystemHealthIssueEdge {
  cursor: String!
  node: SystemHealthIssue!
}

input SystemHealthIssueFilters {
  search: String
  status: [SystemHealthIssueStatus!]
  severity: [SystemHealthIssueSeverity!]
  deploymentModule: [DeploymentModule!]
  region: [String!]
  deploymentId: [String!]
  systemHealthIssueTypeId: [String!]
  deploymentType: [DeploymentType!]
  sourceId: [String!]
  hasServiceTicket: Boolean
}

input SystemHealthIssueOrder {
  direction: OrderDirection!
  field: SystemHealthIssueOrderField!
}

enum SystemHealthIssueOrderField {
  SEVERITY
  CREATED_AT
}

enum SystemHealthIssueSeverity {
  INFORMATIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type SystemHealthIssuesGroupedByDeployment {
  deployment: Deployment!
  issues(after: String, filterBy: SystemHealthIssueFilters, first: Int, orderBy: SystemHealthIssueOrder): SystemHealthIssueConnection!
}

type SystemHealthIssuesGroupedByDeploymentConnection {
  edges: [SystemHealthIssuesGroupedByDeploymentEdge!]
  nodes: [SystemHealthIssuesGroupedByDeployment!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SystemHealthIssuesGroupedByDeploymentEdge {
  cursor: String!
  node: SystemHealthIssuesGroupedByDeployment!
}

input SystemHealthIssuesGroupedByDeploymentFilters {
  filters: DeploymentFilters
  issueFilters: SystemHealthIssueFilters
}

type SystemHealthIssuesGroupedBySource {
  issues(after: String, filterBy: SystemHealthIssueFilters, first: Int, orderBy: SystemHealthIssueOrder): SystemHealthIssueConnection!
  lastSeenAt: DateTime
  source: DeploymentSource!
}

type SystemHealthIssuesGroupedBySourceConnection {
  edges: [SystemHealthIssuesGroupedBySourceEdge!]
  nodes: [SystemHealthIssuesGroupedBySource!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SystemHealthIssuesGroupedBySourceEdge {
  cursor: String!
  node: SystemHealthIssuesGroupedBySource!
}

input SystemHealthIssuesGroupedBySourceFilters {
  search: String
  issueFilters: SystemHealthIssueFilters
}

type SystemHealthIssuesGroupedByType {
  issues(after: String, filterBy: SystemHealthIssueFilters, first: Int, orderBy: SystemHealthIssueOrder): SystemHealthIssueConnection!
  type: SystemHealthIssueType!
}

type SystemHealthIssuesGroupedByTypeConnection {
  edges: [SystemHealthIssuesGroupedByTypeEdge!]
  nodes: [SystemHealthIssuesGroupedByType!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SystemHealthIssuesGroupedByTypeEdge {
  cursor: String!
  node: SystemHealthIssuesGroupedByType!
}

input SystemHealthIssuesGroupedByTypeFilters {
  issueFilters: SystemHealthIssueFilters
}

enum SystemHealthIssueStatus {
  OPEN
  RESOLVED
  IGNORED
}

type SystemHealthIssueType {
  affectedModules: [DeploymentModule!]
  category: SystemHealthIssueTypeCategory!
  id: ID!
  name: String!
  severity: SystemHealthIssueSeverity!
}

enum SystemHealthIssueTypeCategory {
  ERROR
  PERMISSIONS
}

type Technology implements Node {
  categories: [TechnologyCategory!]!
  cloudAccountCount: Int!
  codeRepoCount: Int!
  color: String
  deploymentModel: DeploymentModel
  description: String!
  icon: String
  id: ID!
  instanceEntityType: GraphEntityTypeValue! @deprecated(reason: "Deprecated property, use 'instanceEntityTypes' instead.")
  instanceEntityTypes: [GraphEntityTypeValue!]!
  name: String!
  note: String
  onlyServiceUsageSupported: Boolean!
  projectCount: Int!
  propertySections: [TechnologyPropertySection!]!
  resourceCount: Int!
  risk: TechnologyRisk!
  stackLayer: TechnologyStackLayer!
  status: TechnologyStatus!
  usage: TechnologyUsage!
  vulnerabilityAnalytics: TechnologyVulnerabilityAnalytics
}

type TechnologyCategory implements Node {
  id: ID!
  name: String!
}

type TechnologyConnection {
  countPerStackLayer: [TechnologyCountPerStackLayer!]!
  edges: [TechnologyEdge!]
  nodes: [Technology!]
  pageInfo: PageInfo!
  pendingReviewCount: Int!
  requiredCount: Int!
  sanctionedCount: Int!
  totalCount: Int!
  unsanctionedCount: Int!
}

type TechnologyCountPerCategory {
  category: TechnologyCategory!
  totalCount: Int!
}

type TechnologyCountPerStackLayer {
  countPerCategory: [TechnologyCountPerCategory!]!
  layer: TechnologyStackLayer!
  totalCount: Int!
}

type TechnologyEdge {
  cursor: String!
  node: Technology!
}

input TechnologyFilters {
  search: String
  project: String
  risk: [TechnologyRisk!]
  usage: [TechnologyUsage!]
  status: [TechnologyStatus!]
  category: [String!]
  stackLayer: [TechnologyStackLayer!]
  hasNote: Boolean
  isCloudService: Boolean
  storesData: Boolean
  hasNetworkAccess: Boolean
  hasEndOfLifeWarning: Boolean
  potentiallyUnwanted: Boolean
  billableWorkload: Boolean
  deploymentModel: [DeploymentModel!]
  license: [License!]
  onlyServiceUsageSupported: Boolean
  entityId: String
  subscriptionId: [String!]
  region: [String!]
  usedByOrganization: Boolean
}

input TechnologyOrder {
  direction: OrderDirection!
  field: TechnologyOrderField!
}

enum TechnologyOrderField {
  RISK
  USAGE
  PROJECTS
  NAME
}

type TechnologyProperty {
  name: String!
  value: AnyValue
}

type TechnologyPropertySection {
  name: String!
  properties: [TechnologyProperty!]!
}

enum TechnologyRisk {
  NONE
  LOW
  MEDIUM
  HIGH
}

enum TechnologyStackLayer {
  APPLICATION_AND_DATA
  CI_CD
  SECURITY_AND_IDENTITY
  COMPUTE_PLATFORMS
  CODE
  CLOUD_ENTITLEMENTS
}

enum TechnologyStatus {
  UNREVIEWED
  SANCTIONED
  UNSANCTIONED
  REQUIRED
}

enum TechnologyUsage {
  RARE
  UNCOMMON
  COMMON
  VERY_COMMON
}

type TechnologyVulnerabilityAnalytics {
  categoryBreakdown: [VulnerabilityCountByCategory!]
  totalCount: Int!
  yearBreakdown: [VulnerabilityCountByYear!]
}

type Tenant implements Node {
  createdAt: DateTime!
  dataCenter: String!
  id: ID!
  license: TenantLicenseType! @deprecated(reason: "use licenses instead")
  licenses: [TenantLicense!]!
  name: String!
  primaryLicense: TenantLicense!
  quotaUsage: [TenantLicensesQuotaUsage!]!
  status: TenantStatus! @deprecated(reason: "use primaryLicense instead")
  subscriptionPlanStatus: SubscriptionPlanStatus! @deprecated(reason: "use status instead")
  tenantWizRegistryCredentials: TenantWizRegistryCredentials
}

type TenantIdentityClient {
  cloudProvider: CloudProvider!
  metadata: JSON!
}

type TenantLicense implements Node {
  createdAt: DateTime!
  endAt: DateTime!
  features: [ProductFeature!]!
  id: ID!
  isTrial: Boolean!
  name: String!
  quantity: Int @deprecated(reason: "Use quotas instead")
  quotas: [TenantLicenseQuota!]!
  sku: TenantLicenseSKU!
  startAt: DateTime!
  status: TenantLicenseStatus!
}

type TenantLicenseQuota {
  amount: Int!
  type: TenantLicenseQuotaType!
}

enum TenantLicenseQuotaType {
  LICENSED_WORKLOADS
}

enum TenantLicenseSKU {
  WIZ_SUPPORT_STANDARD @deprecated(reason: "old SKU")
  WIZ_SUPPORT_ADVANCED @deprecated(reason: "old SKU")
  WIZ_SUPPORT_PREMIUM @deprecated(reason: "old SKU")
  WIZ_EVENTS @deprecated(reason: "old SKU")
  WIZ_EVENTS_TRIAL @deprecated(reason: "old SKU")
  WIZ_STANDARD_TRIAL @deprecated(reason: "use WIZ_STANDARD + check isTrial on the license object")
  WIZ_STANDARD
  ESSENTIAL
  ADVANCED
  UPGRADE
  ADVANCED_CONTROL
  ADVANCED_WORKFLOW
  CLOUD_DETECTION_AND_RESPONSE
  DEDICATED_DATA_CENTER
  DATA_SECURITY_POSTURE_MANAGEMENT
  EXTENDED_SUPPORT
  FEDRAMP_STANDARD
  FEDRAMP_ADVANCED
  FEDRAMP_ESSENTIAL
}

type TenantLicensesQuotaUsage {
  totalAmount: Int!
  type: TenantLicenseQuotaType!
  usedAmount: Int!
}

enum TenantLicenseStatus {
  ACTIVE
  EXPIRED
  TERMINATED
  PENDING
}

enum TenantLicenseType {
  TRIAL
  PAID
}

enum TenantStatus {
  ACTIVE
  EXPIRED
  TERMINATED
  PENDING
  TRIAL
}

type TenantWizRegistryCredentials {
  password: String!
  username: String!
}

input TestIntegrationActionInput {
  id: ID!
  actionTemplateType: ActionTemplateType!
  params: ActionTemplateParamsInput
}

enum TimeInterval {
  DAY
  WEEK
  MONTH
}

type TLSConfig {
  clientCert: String
  clientPrivateKey: String
  serverCA: String!
  sniServerName: String
}

input TLSConfigInput {
  serverCA: String!
  sniServerName: String
  clientCert: String
  clientPrivateKey: String
}

type UIUserPreferences {
  preferences: JSON!
}

input UninstallOutpostInput {
  id: ID!
}

type UninstallOutpostPayload {
  outpost: Outpost
}

input UpdateAutomationRuleInput {
  id: ID!
  patch: UpdateAutomationRulePatch!
}

input UpdateAutomationRulePatch {
  name: String
  description: String
  triggerSource: AutomationRuleTriggerSource
  triggerType: [AutomationRuleTriggerType!]
  filters: JSON
  enabled: Boolean
  actions: [AutomationRuleActionInput!]
}

type UpdateAutomationRulePayload {
  automationRule: AutomationRule
}

input UpdateAwsSNSIntegrationParamsInput {
  topicARN: String
  accessMethod: AwsSNSIntegrationAccessMethodInput
}

input UpdateAzureServiceBusIntegrationParamsInput {
  queueUrl: String
  accessMethod: AzureServiceBusIntegrationAccessMethodInput
}

input UpdateBasicAuthSettingsInput {
  requireMFA: Boolean
}

type UpdateBasicAuthSettingsPayload {
  basicAuthSettings: BasicAuthSettings
}

input UpdateCICDScanPolicyDiskSecretsPatch {
  countThreshold: Int
  pathAllowList: [String!]
}

input UpdateCICDScanPolicyDiskVulnerabilitiesPatch {
  severity: DiskScanVulnerabilitySeverity
  packageCountThreshold: Int
  ignoreUnfixed: Boolean
  packageAllowList: [String!]
  detectionMethods: [VulnerabilityDetectionMethod!]
}

input UpdateCICDScanPolicyIACPatch {
  severityThreshold: IACScanSeverity
  countThreshold: Int
  ignoredRules: [String!]
  builtinIgnoreTagsEnabled: Boolean
  customIgnoreTags: [CICDPolicyCustomIgnoreTagUpdateInput!]
  securityFrameworks: [String!]
}

input UpdateCICDScanPolicyInput {
  id: ID!
  patch: UpdateCICDScanPolicyPatch!
}

input UpdateCICDScanPolicyPatch {
  name: String
  description: String
  diskVulnerabilitiesParams: UpdateCICDScanPolicyDiskVulnerabilitiesPatch
  diskSecretsParams: UpdateCICDScanPolicyDiskSecretsPatch
  iacParams: UpdateCICDScanPolicyIACPatch
}

type UpdateCICDScanPolicyPayload {
  scanPolicy: CICDScanPolicy
}

input UpdateClickUpIntegrationParamsInput {
  key: String!
}

type UpdateCloudConfigurationFindingPayload {
  configurationFinding: ConfigurationFinding
}

input UpdateCloudConfigurationRuleInput {
  id: ID!
  patch: UpdateCloudConfigurationRulePatch!
}

input UpdateCloudConfigurationRuleMatcherInput {
  type: CloudConfigurationRuleMatcherType!
  regoCode: String!
}

input UpdateCloudConfigurationRulePatch {
  name: String
  description: String
  targetNativeType: String
  targetNativeTypes: [String!]
  opaPolicy: String
  remediationInstructions: String
  severity: Severity
  enabled: Boolean
  scopeAccountIds: [String!]
  functionAsControl: Boolean
  securitySubCategories: [String!]
  iacMatchers: [UpdateCloudConfigurationRuleMatcherInput!]
}

type UpdateCloudConfigurationRulePayload {
  rule: CloudConfigurationRule
}

type UpdateCloudConfigurationRulesError {
  reason: String
  rule: CloudConfigurationRule!
}

input UpdateCloudConfigurationRulesInput {
  ids: [ID!]
  filters: CloudConfigurationRuleFilters
  patch: UpdateCloudConfigurationRulesPatch
  securitySubCategoriesToAdd: [String!]
  securitySubCategoriesToRemove: [String!]
}

input UpdateCloudConfigurationRulesPatch {
  severity: Severity
  enabled: Boolean
  functionAsControl: Boolean
  securitySubCategories: [String!]
}

type UpdateCloudConfigurationRulesPayload {
  errors: [UpdateCloudConfigurationRulesError!]
  failCount: Int!
  successCount: Int!
}

input UpdateCloudEventRuleInput {
  id: ID!
  patch: UpdateCloudEventRulePatch!
}

input UpdateCloudEventRulePatch {
  name: String
  description: String
  targetEventNames: [String!]
  opaMatcher: String
  enabled: Boolean
  generateFindings: Boolean
  severity: CloudEventRuleSeverity
  securitySubCategory: [String!]
  cloudProviders: [CloudProvider!]
}

type UpdateCloudEventRulePayload {
  rule: CloudEventRule
}

input UpdateComputeGroupTagsSetInput {
  id: ID!
  patch: UpdateComputeGroupTagsSetPatch!
}

input UpdateComputeGroupTagsSetPatch {
  name: String
  tags: [String!]
}

type UpdateComputeGroupTagsSetPayload {
  computeGroupTagsSet: ComputeGroupTagsSet!
}

input UpdateConnectorInput {
  id: ID!
  patch: UpdateConnectorPatch!
}

input UpdateConnectorPatch {
  name: String
  enabled: Boolean
  authParams: JSON
  extraConfig: JSON
}

type UpdateConnectorPayload {
  connector: Connector
}

input UpdateControlInput {
  id: ID!
  patch: UpdateControlPatch!
}

input UpdateControlPatch {
  query: GraphEntityQueryValue
  scopeQuery: JSON
  name: String
  description: String
  resolutionRecommendation: String
  severity: Severity
  enabled: Boolean
  enabledForLBI: Boolean
  enabledForMBI: Boolean
  enabledForHBI: Boolean
  enabledForUnattributed: Boolean
  securitySubCategories: [String!]
}

type UpdateControlPayload {
  control: Control
}

type UpdateControlsError {
  control: Control!
  reason: String
}

input UpdateControlsInput {
  ids: [ID!]
  filters: ControlFilters
  patch: UpdateControlsPatch
  securitySubCategoriesToAdd: [String!]
  securitySubCategoriesToRemove: [String!]
}

input UpdateControlsPatch {
  severity: Severity
  enabled: Boolean
  securitySubCategories: [String!]
}

type UpdateControlsPayload {
  errors: [UpdateControlsError!]
  failCount: Int!
  successCount: Int!
}

input UpdateCustomIPRangeInput {
  id: ID!
  patch: UpdateCustomIPRangePatch!
}

input UpdateCustomIPRangePatch {
  name: String
  ipRanges: [String!]
  isInternal: Boolean
}

type UpdateCustomIPRangePayload {
  customIPRange: CustomIPRange
}

input UpdateDataClassifierInput {
  id: ID!
  patch: UpdateDataClassifierPatch!
}

input UpdateDataClassifierPatch {
  name: String
  description: String
  enabled: Boolean
  category: DataClassifierCategory
  valueRegex: String
  excludeRegex: String
  keyRegex: String
  minLength: Int
  maxLength: Int
  minUniqueMatches: Int
  opaValidator: String
  exampleCount: Int
  anonymizerType: DataAnonymizerType
}

type UpdateDataClassifierPayload {
  dataClassifier: DataClassifier!
}

input UpdateDataScannerSettingsInput {
  patch: UpdateDataScannerSettingsPatch!
}

input UpdateDataScannerSettingsPatch {
  enabled: Boolean!
  bucketConfig: DataScannerSettingsBucketConfigInput
  diskFileConfig: DataScannerSettingsDiskFileConfigInput
  diskDbConfig: DataScannerSettingsDiskDbConfigInput
  cloudDbConfig: DataScannerSettingsCloudDbConfigInput
}

type UpdateDataScannerSettingsPayload {
  dataScannerSettings: DataScannerSettings!
}

input UpdateDigitalTrustDashboardSettingsInput {
  override: UpdateDigitalTrustDashboardSettingsOverride!
}

input UpdateDigitalTrustDashboardSettingsOverride {
  enabled: Boolean!
  brandLogo: String
  brandColor: String
}

type UpdateDigitalTrustDashboardSettingsPayload {
  digitalTrustDashboardSettings: DigitalTrustDashboardSettings!
}

input UpdateExternalExposureScannerSettingsInput {
  patch: UpdateExternalExposureScannerSettingsPatch!
}

input UpdateExternalExposureScannerSettingsPatch {
  isEnabled: Boolean
  scanIntervalDays: Int
  projectAllowlist: [String!]
  projectBlocklist: [String!]
}

type UpdateExternalExposureScannerSettingsPayload {
  externalExposureScannerSettings: ExternalExposureScannerSettings!
}

input UpdateFileIntegrityMonitoringExclusionInput {
  id: ID!
  override: UpdateFileIntegrityMonitoringExclusionOverride!
}

input UpdateFileIntegrityMonitoringExclusionOverride {
  name: String!
  resourceIDs: [String!]
  resourceNames: FileIntegrityMonitoringStringFilterInput
  tags: FileIntegrityMonitoringTagsFilterInput
  filePaths: FileIntegrityMonitoringStringFilterInput
  fileNames: FileIntegrityMonitoringStringFilterInput
}

type UpdateFileIntegrityMonitoringExclusionPayload {
  fileIntegrityMonitoringExclusion: FileIntegrityMonitoringExclusion
}

input UpdateFileIntegrityMonitoringSettingsInput {
  patch: UpdateFileIntegrityMonitoringSettingsPatch!
}

input UpdateFileIntegrityMonitoringSettingsPatch {
  enabled: Boolean!
}

type UpdateFileIntegrityMonitoringSettingsPayload {
  fileIntegrityMonitoringSettings: FileIntegrityMonitoringSettings!
}

input UpdateFindingInput {
  id: ID!
  patch: UpdateFindingPatch
  override: UpdateFindingPatch
}

input UpdateFindingPatch {
  status: FindingCommonStatus
  resolutionReason: FindingResolutionReason
  note: String
  dueAt: DateTime
  rejectionExpiredAt: DateTime
}

input UpdateGcpPubSubIntegrationParamsInput {
  projectId: String
  topicId: String
  accessMethod: GooglePubSubIntegrationAccessMethodInput
}

input UpdateGraphEntityInput {
  id: ID
  externalId: String
  type: GraphEntityTypeValue
  patch: UpdateGraphEntityPatch
  override: UpdateGraphEntityPatch
}

input UpdateGraphEntityMetadataPatch {
  note: String
  isInWatchlist: Boolean
  isIgnored: Boolean
  owner: String
}

input UpdateGraphEntityPatch {
  userMetadata: UpdateGraphEntityMetadataPatch
  userTags: JSON
}

type UpdateGraphEntityPayload {
  graphEntity: GraphEntity
}

type UpdateHostConfigurationRuleAssessmentPayload {
  hostConfigurationRuleAssessment: HostConfigurationRuleAssessment
}

input UpdateHostConfigurationRuleInput {
  id: ID!
  patch: UpdateHostConfigurationRulePatch!
}

input UpdateHostConfigurationRulePatch {
  enabled: Boolean
  severity: Severity
  securitySubCategories: [String!]
  name: String
  description: String
  remediationInstructions: String
  directOVAL: String
  targetPlatformIds: [String!]
  targetOperatingSystems: [String!]
  targetTechnologies: [String!]
}

type UpdateHostConfigurationRulePayload {
  rule: HostConfigurationRule
}

type UpdateHostConfigurationRulesError {
  reason: String
  rule: HostConfigurationRule!
}

input UpdateHostConfigurationRulesInput {
  ids: [ID!]
  filters: HostConfigurationRuleFilters
  patch: UpdateHostConfigurationRulesPatch
  securitySubCategoriesToAdd: [String!]
  securitySubCategoriesToRemove: [String!]
}

input UpdateHostConfigurationRulesPatch {
  enabled: Boolean
  securitySubCategories: [String!]
}

type UpdateHostConfigurationRulesPayload {
  errors: [UpdateHostConfigurationRulesError!]
  failCount: Int!
  successCount: Int!
}

input UpdateIgnoreRuleInput {
  id: ID!
  patch: UpdateIgnoreRulePatch!
}

input UpdateIgnoreRulePatch {
  name: String
  description: String
  findingType: IgnoreRuleFindingType
  disabledOnCloudScanning: Boolean
  projectId: String
  cloudConfigurationRuleIds: [String!]
  hostConfigurationRuleIds: [String!]
  vulnerabilityIds: [String!]
  findingIgnoreReason: FindingResolutionReason
  expiredAt: DateTime
  resourceConditions: IgnoreRuleResourceConditionsInput
  cloudConfigurationFindingConditions: IgnoreRuleCloudConfigurationFindingConditionsInput
  hostConfigurationFindingConditions: IgnoreRuleHostConfigurationFindingConditionsInput
  vulnerabilityFindingConditions: IgnoreRuleVulnerabilityFindingConditionsInput
  enabled: Boolean
}

type UpdateIgnoreRulePayload {
  rule: IgnoreRule!
}

input UpdateIntegrationInput {
  id: ID!
  patch: UpdateIntegrationPatch!
}

input UpdateIntegrationPatch {
  name: String
  params: UpdateIntegrationPatchParams
}

input UpdateIntegrationPatchParams {
  awsSNS: UpdateAwsSNSIntegrationParamsInput
  webhook: UpdateWebhookIntegrationParamsInput
  slack: UpdateSlackIntegrationParamsInput
  slackBot: UpdateSlackBotIntegrationParamsInput
  azureServiceBus: UpdateAzureServiceBusIntegrationParamsInput
  gcpPubSub: UpdateGcpPubSubIntegrationParamsInput
  pagerDuty: UpdatePagerDutyIntegrationParamsInput
  jira: UpdateJiraIntegrationParamsInput
  serviceNow: UpdateServiceNowIntegrationParamsInput
  opsgenie: UpdateOpsgenieIntegrationParamsInput
  clickUp: UpdateClickUpIntegrationParamsInput
}

type UpdateIntegrationPayload {
  integration: Integration!
}

input UpdateIPRestrictionsInput {
  allowedIPs: [String!]!
}

type UpdateIPRestrictionsPayload {
  ipRestrictions: IPRestrictions!
}

input UpdateIssueInput {
  id: ID!
  patch: UpdateIssuePatch
  override: UpdateIssuePatch
}

input UpdateIssueNoteInput {
  id: ID!
  patch: UpdateIssueNotePatch!
}

input UpdateIssueNotePatch {
  text: String!
}

type UpdateIssueNotePayload {
  issueNote: IssueNote!
}

input UpdateIssuePatch {
  status: IssueStatus
  resolutionReason: IssueResolutionReason
  note: String
  dueAt: DateTime
  rejectionExpiredAt: DateTime
}

type UpdateIssuePayload {
  issue: Issue
}

type UpdateIssuesError {
  issue: Issue!
  reason: String
}

input UpdateIssueSettingsInput {
  patch: UpdateIssueSettingsPatch
}

input UpdateIssueSettingsPatch {
  requireNoteOnRejection: Boolean
  daysToResolution: [IssueSettingsDaysToResolutionConfigInput!]
}

type UpdateIssueSettingsPayload {
  issueSettings: IssueSettings!
}

input UpdateIssuesInput {
  ids: [ID!]
  filters: IssueFilters
  patch: UpdateIssuesPatch
  override: UpdateIssuesPatch
}

input UpdateIssuesPatch {
  status: IssueStatus
  resolutionReason: IssueResolutionReason
  dueAt: DateTime
  rejectionExpiredAt: DateTime
  note: String
}

type UpdateIssuesPayload {
  errors: [UpdateIssuesError!]
  failCount: Int!
  successCount: Int!
}

input UpdateJiraIntegrationParamsInput {
  serverUrl: String
  serverType: JiraServerType
  isOnPrem: Boolean
  tlsConfig: IntegrationTLSConfigInput
  authorization: JiraIntegrationAuthorizationInput
}

input UpdateLoginSettingsInput {
  patch: UpdateLoginSettingsPatch!
}

input UpdateLoginSettingsPatch {
  approvedUserDomains: [String!]
}

type UpdateLoginSettingsPayload {
  loginSettings: LoginSettings
}

input UpdateMalwareExclusionInput {
  id: ID!
  override: UpdateMalwareExclusionOverride!
}

input UpdateMalwareExclusionOverride {
  name: String
  resourceIDs: [String!]
  paths: [String!]
  fileNames: [String!]
  fileExtensions: [String!]
}

type UpdateMalwareExclusionPayload {
  malwareExclusion: MalwareExclusion
}

input UpdateNonOSDiskScanningResourceTagInput {
  key: String!
  value: String
}

input UpdateNonOSDiskScanningSettingsInput {
  patch: UpdateNonOSDiskScanningSettingsPatch!
}

input UpdateNonOSDiskScanningSettingsPatch {
  enabled: Boolean
  excludedTags: [UpdateNonOSDiskScanningResourceTagInput!]
  includedTags: [UpdateNonOSDiskScanningResourceTagInput!]
  daysInterval: Int
}

type UpdateNonOSDiskScanningSettingsPayload {
  nonOSDiskScanningSettings: NonOSDiskScanningSettings!
}

input UpdateOpsgenieIntegrationParamsInput {
  key: String!
}

input UpdateOutpostAlibabaConfigInput {
  outpostCredentials: UpdateOutpostAlibabaOutpostCredentialsInput
  stateBucketName: String
}

input UpdateOutpostAlibabaOutpostCredentialsInput {
  orchestratorAccessKeyID: String!
  orchestratorAccessKeySecret: String!
}

input UpdateOutpostAWSConfigInput {
  accessKey: String
  secretKey: String
  stateBucketName: String
  resultsBucketName: String
  disableNatGateway: Boolean
}

input UpdateOutpostAzureConfigInput {
  orchestratorClient: UpdateOutpostAzureCredentialsInput
  stateStorageAccountName: String
}

input UpdateOutpostAzureCredentialsInput {
  id: String!
  secret: String
  privateKeyPem: String
  certificatePem: String
}

input UpdateOutpostConfigInput {
  awsConfig: UpdateOutpostAWSConfigInput
  gcpConfig: UpdateOutpostGCPConfigInput
  azureConfig: UpdateOutpostAzureConfigInput
  ociConfig: UpdateOutpostOCIConfigInput
  alibabaConfig: UpdateOutpostAlibabaConfigInput
}

input UpdateOutpostCustomConfigInput {
  podAnnotations: JSON
  resourceTags: JSON
}

input UpdateOutpostCustomTagInput {
  key: String!
  value: String
}

input UpdateOutpostGCPConfigInput {
  orchestratorKey: String
  stateBucketName: String
}

input UpdateOutpostInput {
  id: ID!
  patch: UpdateOutpostPatch!
}

input UpdateOutpostManagedConfigInput {
  resourceTags: [UpdateOutpostCustomTagInput!]
  kubernetesLoggingEnabled: Boolean
  kubernetesCloudMonitoringEnabled: Boolean
  allowedRegions: [String!]
}

input UpdateOutpostOCIConfigInput {
  orchestrator: UpdateOutpostOCIUserCredentialsInput
  stateBucketName: String
}

input UpdateOutpostOCIUserCredentialsInput {
  fingerprint: String!
  privateKey: String!
}

input UpdateOutpostPatch {
  name: String
  enabled: Boolean
  awsConfig: UpdateOutpostAWSConfigInput
  gcpConfig: UpdateOutpostGCPConfigInput
  azureConfig: UpdateOutpostAzureConfigInput
  ociConfig: UpdateOutpostOCIConfigInput
  alibabaConfig: UpdateOutpostAlibabaConfigInput
  selfManagedConfig: UpdateOutpostSelfManagedConfigInput
  managedConfig: UpdateOutpostManagedConfigInput
  podAnnotations: [UpdateOutpostCustomTagInput!]
  customConfig: UpdateOutpostCustomConfigInput
  config: UpdateOutpostConfigInput
}

type UpdateOutpostPayload {
  outpost: Outpost
}

input UpdateOutpostSelfManagedConfigInput {
  imageRepository: String
  imagePullSecret: String
  versionID: ID
  disableAutomaticConfigurationBucketSync: Boolean
}

input UpdatePagerDutyIntegrationParamsInput {
  integrationKey: String!
}

input UpdatePortalInactivityTimeoutSettingsInput {
  patch: PortalInactivityTimeoutSettingsPatch!
}

type UpdatePortalInactivityTimeoutSettingsPayload {
  portalInactivityTimeoutSettings: PortalInactivityTimeoutSettings!
}

input UpdateProjectInput {
  id: ID!
  patch: UpdateProjectPatch
  override: UpdateProjectPatch
}

input UpdateProjectPatch {
  name: String
  description: String
  identifiers: [String!]
  businessUnit: String
  archived: Boolean
  projectOwners: [String!]
  securityChampions: [String!]
  riskProfile: ProjectRiskProfileInput
  repositoryLinks: [ProjectRepositoryLinkInput!]
  cloudAccountLinks: [ProjectCloudAccountLinkInput!]
  cloudOrganizationLinks: [ProjectCloudOrganizationLinkInput!]
  kubernetesClusterLinks: [ProjectKubernetesClusterLinkInput!]
  resourceTagLinks: [ProjectResourceTagsLinkInput!]
  slug: String
}

type UpdateProjectPayload {
  project: Project
}

input UpdateReportChange {
  name: String!
  runIntervalHours: Int
  runStartsAt: DateTime
  emailTargetParams: EmailTargetParams
  graphQueryParams: UpdateReportGraphQueryParamsInput
  vulnerabilityParams: UpdateReportVulnerabilityParamsInput
  complianceExecutiveSummaryParams: UpdateReportComplianceExecutiveSummaryParamsInput
  complianceAssessmentsParams: UpdateReportComplianceAssessmentsParamsInput
  networkExposureParams: UpdateReportNetworkExposureParamsInput
  configurationFindingParams: UpdateReportConfigurationFindingParamsInput
  securityFrameworkParams: UpdateReportSecurityFrameworkParamsInput
  issueParams: UpdateReportIssuesParamsInput
  hostConfigurationParams: UpdateReportHostConfigurationParamsInput
  cloudResourceParams: UpdateReportCloudResourceParamsInput
  columnSelection: [String!]
  csvDelimiter: CSVDelimiter
}

input UpdateReportCloudResourceParamsInput {
  includeCloudNativeJSON: Boolean!
  includeWizJSON: Boolean!
  entityType: [GraphEntityTypeValue!]!
  subscriptionId: [String!]
  nativeType: [String!]
  region: [String!]
  cloudPlatform: [String!]
}

input UpdateReportComplianceAssessmentsParamsInput {
  subscriptionIds: [String!]
  securityFrameworkIds: [String!]
  securityCategories: [String!]
  result: [PolicyAssessmentResult!]
}

input UpdateReportComplianceExecutiveSummaryParamsInput {
  subscriptionIds: [String!]
  securityFrameworkId: String
}

input UpdateReportConfigurationFindingParamsInput {
  subscriptionIds: [String!]
  entityIds: [String!]
}

input UpdateReportGraphQueryEntityOptions {
  entityType: GraphEntityTypeValue!
  propertyOptions: [UpdateReportGraphQueryPropertyOptions!]!
}

input UpdateReportGraphQueryParamsInput {
  query: GraphEntityQueryValue!
  entityOptions: [UpdateReportGraphQueryEntityOptions!]
}

input UpdateReportGraphQueryPropertyOptions {
  key: String!
}

input UpdateReportHostConfigurationParamsInput {
  hostConfigurationRuleAssessmentsFilters: HostConfigurationRuleAssessmentFilters
}

input UpdateReportInput {
  id: ID!
  override: UpdateReportChange
}

input UpdateReportIssuesParamsInput {
  type: IssueReportType!
  evidenceGraphEntityTypesToInclude: [GraphEntityTypeValue!]
  issueFilters: IssueFilters
}

input UpdateReportNetworkExposureParamsInput {
  subscriptionIds: [String!]
  entityIds: [String!]
}

type UpdateReportPayload {
  report: Report!
}

input UpdateReportSecurityFrameworkParamsInput {
  subscriptionIds: [String!]
  entityIds: [String!]
}

input UpdateReportSettingsInput {
  patch: UpdateReportSettingsPatch
}

input UpdateReportSettingsPatch {
  retentionDays: Int
}

type UpdateReportSettingsPayload {
  reportSettings: ReportSettings!
}

input UpdateReportVulnerabilityParamsInput {
  type: VulnerabilityReportType
  assetType: VulnerableAssetObjectType
  filters: VulnerabilityFindingFilters
}

input UpdateSAMLIdentityProviderInput {
  id: ID!
  patch: UpdateSAMLIdentityProviderPatch!
}

input UpdateSAMLIdentityProviderPatch {
  name: String
  issuerURL: String
  loginURL: String
  logoutURL: String
  useProviderManagedRoles: Boolean
  allowManualRoleOverride: Boolean
  certificate: String
  domains: [String!]
  groupMapping: [SAMLGroupMappingUpdateInput!]
  mergeGroupsMappingByRole: Boolean
  attributeMapping: SAMLAttributeMappingInput
}

type UpdateSAMLIdentityProviderPayload {
  samlIdentityProvider: SAMLIdentityProvider
}

input UpdateSavedCloudEventFilterInput {
  id: ID!
  patch: UpdateSavedCloudEventFilterPatch!
}

input UpdateSavedCloudEventFilterPatch {
  name: String
  description: String
  securitySubCategories: [String!]
  filters: JSON
}

type UpdateSavedCloudEventFilterPayload {
  savedCloudEventFilter: SavedCloudEventFilter
}

input UpdateSavedGraphQueryInput {
  id: ID!
  patch: UpdateSavedGraphQueryPatch!
}

input UpdateSavedGraphQueryPatch {
  name: String
  description: String
  securitySubCategories: [String!]
  query: GraphEntityQueryValue
}

type UpdateSavedGraphQueryPayload {
  savedGraphQuery: SavedGraphQuery
}

input UpdateScannerAPIRateLimitInput {
  id: ID!
  patch: UpdateScannerAPIRateLimitPatch!
}

input UpdateScannerAPIRateLimitPatch {
  queryRequestsPerSecond: Int
  mutationRequestsPerSecond: Int
}

type UpdateScannerAPIRateLimitPayload {
  scannerAPIRateLimit: ScannerAPIRateLimit!
}

input UpdateScannerExclusionSizeLimitsInput {
  diskSizeGB: Int
}

input UpdateScannerExclusionSizeLimitsPatch {
  sizeLimits: UpdateScannerExclusionSizeLimitsInput
}

type UpdateScannerExclusionSizeLimitsPayload {
  scannerExclusionSettings: ScannerExclusionSettings!
}

input UpdateScannerExclusionTagInput {
  key: String!
  value: String
}

type UpdateScannerExclusionTagPayload {
  scannerExclusionSettings: ScannerExclusionSettings!
}

input UpdateScannerExclusionTagsPatch {
  tags: [UpdateScannerExclusionTagInput!]!
}

input UpdateScannerResourceTagInput {
  key: String!
  value: String
}

type UpdateScannerResourceTagPayload {
  scannerResourceTags: [ScannerResourceTag]!
}

input UpdateScannerResourceTagsInput {
  tags: [UpdateScannerResourceTagInput]!
}

input UpdateScannerSettingsAwsInspectorConfigPatch {
  enabled: Boolean
}

input UpdateScannerSettingsAwsMacieConfigPatch {
  enabled: Boolean
}

input UpdateScannerSettingsAzureSecurityCenterConfigPatch {
  enabled: Boolean
}

input UpdateScannerSettingsExternalFindingSourcesPatch {
  awsInspectorConfig: UpdateScannerSettingsAwsInspectorConfigPatch
  awsMacieConfig: UpdateScannerSettingsAwsMacieConfigPatch
  azureSecurityCenterConfig: UpdateScannerSettingsAzureSecurityCenterConfigPatch
}

input UpdateScannerSettingsInput {
  patch: UpdateScannerSettingsPatch
}

input UpdateScannerSettingsPatch {
  computeResourceGroupMemberScanSamplingEnabled: Boolean
  unmanagedComputeResourceGroupScanSamplingDisabled: Boolean
  maxComputeResourceGroupMemberScanCount: Int
  prioritizeActiveComputeResourceGroupMembers: Boolean
  externalFindingSources: UpdateScannerSettingsExternalFindingSourcesPatch
  customFileDetectionListUploadId: String
  excessiveAccessDaysThreshold: Int
}

type UpdateScannerSettingsPayload {
  scannerSettings: ScannerSettings!
}

input UpdateSecurityFrameworkInput {
  id: ID!
  patch: SecurityFrameworkPatch!
  patchOptions: SecurityFrameworkPatchOptions
}

type UpdateSecurityFrameworkPayload {
  errors: [SecuritySubCategoryAssignmentError!]
  framework: SecurityFramework
}

input UpdateSecurityScanInput {
  id: ID!
  patch: UpdateSecurityScanPatch!
}

input UpdateSecurityScanPatch {
  scopeObject: String
  source: String
}

type UpdateSecurityScanPayload {
  securityScan: SecurityScan
}

input UpdateServiceNowIntegrationParamsInput {
  url: String
  authorization: ServiceNowIntegrationAuthorizationInput
}

input UpdateSessionLifetimeSettingsInput {
  patch: SessionLifetimeSettingsPatch!
}

type UpdateSessionLifetimeSettingsPayload {
  sessionLifetimeSettings: SessionLifetimeSettings!
}

input UpdateSlackBotIntegrationParamsInput {
  token: String!
}

input UpdateSlackIntegrationParamsInput {
  url: String
}

input UpdateSystemHealthIssueInput {
  id: ID!
  patch: UpdateSystemHealthIssuePatch
}

input UpdateSystemHealthIssuePatch {
  ignored: Boolean
}

type UpdateSystemHealthIssuePayload {
  systemHealthIssue: SystemHealthIssue
}

input UpdateTechnologyInput {
  id: ID!
  patch: UpdateTechnologyPatch!
}

input UpdateTechnologyPatch {
  status: TechnologyStatus
  note: String
}

type UpdateTechnologyPayload {
  technology: Technology
}

input UpdateUIUserPreferencesInput {
  patch: JSON
  override: JSON
}

type UpdateUIUserPreferencesPayload {
  preferences: UIUserPreferences
}

input UpdateUserInput {
  id: ID!
  patch: UpdateUserPatch
  override: UpdateUserPatch
}

input UpdateUserPatch {
  name: String
  email: String
  role: String
  assignedProjectIds: [String!]
  isSuspended: Boolean
}

type UpdateUserPayload {
  user: User
}

input UpdateViewerPreferences {
  selectedSAMLGroupId: String
}

input UpdateViewerPreferencesInput {
  patch: UpdateViewerPreferences!
}

type UpdateViewerPreferencesPayload {
  userPreferences: UserPreferences
}

type UpdateVulnerabilityFindingPayload {
  vulnerabilityFinding: VulnerabilityFinding
}

input UpdateVulnerabilityInput {
  id: ID
  externalId: String
  patch: UpdateVulnerabilityPatch!
}

input UpdateVulnerabilityPatch {
  severity: VulnerabilitySeverity
}

type UpdateVulnerabilityPayload {
  vulnerability: Vulnerability
}

input UpdateWebhookIntegrationParamsInput {
  url: String
  isOnPrem: Boolean
  authorization: WebhookIntegrationAuthorizationInput
  headers: [WebhookHeaderInput!]
  tlsConfig: IntegrationTLSConfigInput
}

input UpsertAgentTelemetryInput {
  agentId: String!
  requestTime: DateTime!
  healthStatus: String!
}

type UpsertAgentTelemetryPayload {
  agentId: String!
}

type User implements Node {
  assignedProjects: [Project] @deprecated
  assignedSAMLGroups: [SAMLGroupMapping!]
  authenticationSource: AuthenticationSource!
  createdAt: DateTime!
  effectiveAssignedProjects: [Project]
  effectiveRole: UserRole
  email: String!
  id: ID!
  identityProvider: SAMLIdentityProvider
  identityProviderAssignedProjects: [Project]
  identityProviderRole: UserRole
  identityProviderType: UserIdentityProviderType!
  intercomUserHash: String
  ipAddress: String
  isAnalyticsEnabled: Boolean!
  isProjectScoped: Boolean! @deprecated(reason: "use isProjectScoped property from the role instead")
  isSuspended: Boolean!
  lastLoginAt: DateTime
  manualOverrideAssignedProjects: [Project]
  manualOverrideRole: UserRole
  name: String!
  preferences: UserPreferences
  readmeAuthToken: String
  role: UserRole @deprecated
  smoochAuth: SmoochAuth
  tenant: Tenant!
  updatedAt: DateTime!
  xmlLanguageServerToken: String
  zendeskAuthToken: String
}

type UserConnection {
  edges: [UserEdge!]
  exportUrl(format: ExportFormats = CSV, limit: Int = 5000): String
  nodes: [User!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  cursor: String!
  node: User!
}

input UserFilters {
  search: String
  role: [String!]
  authProviderType: [UserIdentityProviderType!]
  assignedProjects: [String!]
  source: AuthenticationSource
}

enum UserIdentityProviderType {
  WIZ
  SAML
}

union UserOrConnector = User | Connector

type UserPreferences {
  selectedSAMLGroup: SAMLGroupMapping
}

type UserRole implements Node {
  description: String
  id: ID!
  isProjectScoped: Boolean!
  name: String!
  scopes: [String!]!
}

type UserRoleConnection {
  edges: [UserRoleEdge!]
  nodes: [UserRole!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserRoleEdge {
  cursor: String!
  node: UserRole!
}

type ValidatableCloudConfigurationRule implements Node {
  id: ID!
  isValid: Boolean!
  rule: CloudConfigurationRule
}

type Vulnerability implements Node {
  affectedTechnologies: [Technology!]
  baseScore: Float
  cisaKevDueDate: DateTime
  cisaKevReleaseDate: DateTime
  cvss2: VulnerabilityCVSS2Metrics
  cvss3: VulnerabilityCVSS3Metrics
  cvssv2: VulnerabilityCVSSMetrics
  cvssv3: VulnerabilityCVSSMetrics
  description: String
  exploitabilityScore: Float
  exploitable: Boolean
  externalId: String!
  hasCisaKevExploit: Boolean!
  id: ID!
  name: String!
  publishedAt: DateTime
  severity: VulnerabilitySeverity
  sourceFeeds: [VulnerabilitySourceFeed!]!
  sourceUrl: String
}

type VulnerabilityAffectedPlatform implements Node {
  addedAt: DateTime!
  advisoryUrl: String
  affectedVersions: [String!]
  hasFix: Boolean
  id: ID!
  name: String
  severity: VulnerabilitySeverity
  technology: Technology
}

enum VulnerabilityAttackComplexity {
  LOW
  MEDIUM
  HIGH
}

enum VulnerabilityAttackVector {
  ADJACENT_NETWORK
  LOCAL
  NETWORK
  PHYSICAL
}

type VulnerabilityConnection {
  edges: [VulnerabilityEdge!]
  nodes: [Vulnerability!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type VulnerabilityCountByCategory {
  category: String!
  count: Int!
}

type VulnerabilityCountByYear {
  count: Int!
  year: Int!
}

type VulnerabilityCVSS2Metrics {
  attackComplexity: VulnerabilityAttackComplexity
  attackVector: String
  confidentialityImpact: VulnerabilityImpact
  integrityImpact: VulnerabilityImpact
  privilegesRequired: Boolean
  userInteractionRequired: Boolean
}

type VulnerabilityCVSS3Metrics {
  attackComplexity: VulnerabilityAttackComplexity
  attackVector: String
  confidentialityImpact: VulnerabilityImpact
  integrityImpact: VulnerabilityImpact
  privilegesRequired: Boolean
  userInteractionRequired: Boolean
}

type VulnerabilityCVSSMetrics {
  attackComplexity: VulnerabilityAttackComplexity
  attackVector: VulnerabilityAttackVector
  confidentialityImpact: VulnerabilityImpact
  integrityImpact: VulnerabilityImpact
  privilegesRequired: VulnerabilityPrivilegesRequired
  userInteractionRequired: Boolean
}

input VulnerabilityDateFilters {
  before: DateTime
  after: DateTime
}

enum VulnerabilityDetectionMethod {
  PACKAGE
  DEFAULT_PACKAGE
  LIBRARY
  CONFIG_FILE
  OPEN_PORT
  STARTUP_SERVICE
  CONFIGURATION
  CLONED_REPOSITORY
  OS
  ARTIFACTS_ON_DISK
  WINDOWS_REGISTRY
  INSTALLED_PROGRAM
  WINDOWS_SERVICE
  INSTALLED_PROGRAM_BY_SERVICE
  FILE_PATH
  UNKNOWN
}

type VulnerabilityEdge {
  cursor: String!
  node: Vulnerability!
}

input VulnerabilityFilters {
  search: String
  externalId: [String!]
  name: [String!]
  vendorAdvisory: [String!]
  affectedTechnology: [String!]
  severity: [VulnerabilitySeverity!]
  modifiedSeverity: Boolean
  publishedAt: VulnerabilityDateFilters
  hasExploit: Boolean
  hasFix: Boolean
  hasCisaKevExploit: Boolean
  hasSupportedDetectionMethod: Boolean
}

type VulnerabilityFinding {
  CVEDescription: String
  CVSSSeverity: VulnerabilitySeverity
  cvssv2: VulnerabilityCVSSMetrics
  cvssv3: VulnerabilityCVSSMetrics
  description: String
  detailedName: String
  detectionMethod: VulnerabilityDetectionMethod
  exploitabilityScore: Float
  firstDetectedAt: DateTime!
  fixedVersion: String
  hasCisaKevExploit: Boolean
  hasExploit: Boolean
  id: ID!
  ignoreRules: [IgnoreRule]
  impactScore: Float
  lastDetectedAt: DateTime!
  layerMetadata: LayerMetadata
  link: String
  locationPath: String
  name: String!
  note: VulnerabilityFindingNote
  portalUrl: String!
  projects: [Project]
  remediation: String
  resolutionReason: FindingResolutionReason
  resolvedAt: DateTime
  score: Float
  status: FindingCommonStatus!
  validatedInRuntime: Boolean
  vendorSeverity: VulnerabilitySeverity
  version: String
  vulnerabilityExternalId: String
  vulnerabilityId: ID
  vulnerableAsset: VulnerableAsset
}

type VulnerabilityFindingConnection {
  criticalSeverityCount: Int!
  edges: [VulnerabilityFindingEdge!]
  highSeverityCount: Int!
  informationalSeverityCount: Int!
  lowSeverityCount: Int!
  maxCountReached: Boolean
  mediumSeverityCount: Int!
  nodes: [VulnerabilityFinding!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type VulnerabilityFindingEdge {
  cursor: String!
  node: VulnerabilityFinding!
}

input VulnerabilityFindingFilters {
  id: [ID!]
  subscriptionExternalId: [String!]
  firstSeenAt: VulnerabilityDateFilters
  updatedAt: VulnerabilityDateFilters
  resolvedAt: VulnerabilityDateFilters
  assetType: [VulnerableAssetObjectType!]
  vendorSeverity: [VulnerabilitySeverity!]
  status: [FindingCommonStatus!]
  assetId: [String!]
  vulnerabilityId: [String!]
  vulnerabilityExternalId: [String!]
  hasFix: Boolean
  hasExploit: Boolean
  hasCisaKevExploit: Boolean
  detectionMethod: [VulnerabilityDetectionMethod!]
  validatedInRuntime: Boolean
  projectId: [String!]
  isAssetAccessibleFromInternet: Boolean
  IncludeLastDetected: Boolean
  isAssetOpenToAllInternet: Boolean
  assetHasHighPrivileges: Boolean
  assetHasAdminPrivileges: Boolean
  assetStatus: [CloudResourceStatus!]
  score: CommonNumberFilter
  isContainerImageScannedFromWorkload: Boolean
  isContainerImageScannedFromRegistry: Boolean
  containerRegistry: [String!]
  containerRepository: [String!]
  layerId: [String!]
  isBaseLayer: Boolean
}

type VulnerabilityFindingNote implements Node {
  createdAt: DateTime!
  id: ID!
  serviceAccount: ServiceAccount
  text: String!
  updatedAt: DateTime!
  user: User
}

input VulnerabilityFindingOrder {
  direction: OrderDirection!
}

type VulnerabilityFindingsGroupedByLayer implements Node {
  findings(after: String, filterBy: VulnerabilityFindingFilters, first: Int, orderBy: VulnerabilityFindingOrder): VulnerabilityFindingConnection
  id: ID!
  metadata: LayerMetadata!
}

enum VulnerabilityFindingsGroupedByLayerResourceType {
  CONTAINER_IMAGE
}

enum VulnerabilityImpact {
  NONE
  LOW
  MEDIUM
  HIGH
  PARTIAL
  COMPLETE
}

input VulnerabilityOrder {
  direction: OrderDirection!
  field: VulnerabilityOrderField!
}

enum VulnerabilityOrderField {
  PUBLISHED_AT
}

enum VulnerabilityPrivilegesRequired {
  NONE
  LOW
  HIGH
  SINGLE
  MULTIPLE
}

enum VulnerabilityReportGraphEntityType {
  VIRTUAL_MACHINE
  SERVERLESS
  CONTAINER_IMAGE
  CONTAINER
}

enum VulnerabilityReportType {
  DETAILED
  COMPACT
}

enum VulnerabilitySeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type VulnerabilitySourceFeed {
  affectedPlatforms: [VulnerabilityAffectedPlatform!]!
  icon: String!
  id: ID!
  name: String!
  publishedAt: DateTime
  url: String
}

type VulnerabilityVendorAdvisory {
  icon: String!
  id: ID!
  name: String!
}

type VulnerabilityVendorAdvisoryConnection {
  edges: [VulnerabilityVendorAdvisoryEdge!]
  nodes: [VulnerabilityVendorAdvisory!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type VulnerabilityVendorAdvisoryEdge {
  cursor: String!
  node: VulnerabilityVendorAdvisory!
}

input VulnerabilityVendorAdvisoryFilters {
  search: String
}

union VulnerableAsset = VulnerableAssetVirtualMachine | VulnerableAssetServerless | VulnerableAssetContainerImage | VulnerableAssetContainer

interface VulnerableAssetBase {
  cloudPlatform: CloudPlatform
  cloudProviderURL: String
  hasLimitedInternetExposure: Boolean
  hasWideInternetExposure: Boolean
  id: ID!
  isAccessibleFromOtherSubscriptions: Boolean
  isAccessibleFromOtherVnets: Boolean
  isAccessibleFromVPN: Boolean
  name: String
  providerUniqueId: String!
  region: String
  status: CloudResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  subscriptionName: String
  tags: JSON
  type: VulnerableAssetObjectType!
}

type VulnerableAssetContainer implements VulnerableAssetBase {
  cloudPlatform: CloudPlatform
  cloudProviderURL: String
  hasLimitedInternetExposure: Boolean
  hasWideInternetExposure: Boolean
  id: ID!
  ImageExternalId: String
  isAccessibleFromOtherSubscriptions: Boolean
  isAccessibleFromOtherVnets: Boolean
  isAccessibleFromVPN: Boolean
  name: String
  NodeName: String
  PodName: String
  PodNamespace: String
  providerUniqueId: String!
  region: String
  ServerlessContainer: Boolean
  status: CloudResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  subscriptionName: String
  tags: JSON
  type: VulnerableAssetObjectType!
  VmExternalId: String
}

type VulnerableAssetContainerImage implements VulnerableAssetBase {
  cloudPlatform: CloudPlatform
  cloudProviderURL: String
  hasLimitedInternetExposure: Boolean
  hasWideInternetExposure: Boolean
  id: ID!
  imageId: String!
  isAccessibleFromOtherSubscriptions: Boolean
  isAccessibleFromOtherVnets: Boolean
  isAccessibleFromVPN: Boolean
  layerMetadata: LayerMetadata @deprecated(reason: "Use layerMetadata as part of VulnerabilityFinding")
  name: String
  providerUniqueId: String!
  region: String
  registry: GEContainerRegistry
  repository: GEContainerRepository
  scanSource: [ContainerImageScanSource!]
  status: CloudResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  subscriptionName: String
  tags: JSON
  type: VulnerableAssetObjectType!
}

enum VulnerableAssetObjectType {
  VIRTUAL_MACHINE
  SERVERLESS
  CONTAINER_IMAGE
  CONTAINER
}

type VulnerableAssetServerless implements VulnerableAssetBase {
  cloudPlatform: CloudPlatform
  cloudProviderURL: String
  hasLimitedInternetExposure: Boolean
  hasWideInternetExposure: Boolean
  id: ID!
  isAccessibleFromOtherSubscriptions: Boolean
  isAccessibleFromOtherVnets: Boolean
  isAccessibleFromVPN: Boolean
  name: String
  providerUniqueId: String!
  region: String
  runtime: String
  status: CloudResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  subscriptionName: String
  tags: JSON
  type: VulnerableAssetObjectType!
}

type VulnerableAssetVirtualMachine implements VulnerableAssetBase {
  cloudPlatform: CloudPlatform
  cloudProviderURL: String
  hasLimitedInternetExposure: Boolean
  hasWideInternetExposure: Boolean
  id: ID!
  imageExternalId: String
  imageId: String
  imageName: String
  imageNativeType: String
  imageProviderUniqueId: String
  ipAddresses: [String!]
  isAccessibleFromOtherSubscriptions: Boolean
  isAccessibleFromOtherVnets: Boolean
  isAccessibleFromVPN: Boolean
  name: String
  operatingSystem: String
  providerUniqueId: String!
  region: String
  status: CloudResourceStatus
  subscriptionExternalId: String
  subscriptionId: String
  subscriptionName: String
  tags: JSON
  type: VulnerableAssetObjectType!
}

type WebhookActionTemplateParams {
  body: String!
  headers: [WebhookHeader!]
}

input WebhookActionTemplateParamsInput {
  body: String!
  headers: [WebhookHeaderInput!]
}

union WebhookAutomationActionAuthentication = WebhookAutomationActionAuthenticationBasic | WebhookAutomationActionAuthenticationTokenBearer

type WebhookAutomationActionAuthenticationBasic {
  password: String!
  username: String!
}

type WebhookAutomationActionAuthenticationTokenBearer {
  token: String!
}

type WebhookAutomationActionParams {
  authentication: WebhookAutomationActionAuthentication
  body: String!
  clientCertificate: String @deprecated(reason: "Use tlsConfig instead")
  headers: [WebhookHeader!]
  isOnPrem: Boolean!
  onPremTunnelDomain: String
  onPremTunnelToken: String
  tlsConfig: AutomationActionTLSConfig
  url: String!
}

type WebhookHeader {
  key: String!
  value: String!
}

input WebhookHeaderInput {
  key: String!
  value: String!
}

union WebhookIntegrationAuthorization = WebhookIntegrationBasicAuthorization | WebhookIntegrationBearerAuthorization

input WebhookIntegrationAuthorizationInput {
  username: String
  password: String
  token: String
}

type WebhookIntegrationBasicAuthorization {
  password: String
  username: String!
}

type WebhookIntegrationBearerAuthorization {
  token: String!
}

type WebhookIntegrationParams {
  authorization: WebhookIntegrationAuthorization
  headers: [WebhookHeader!]
  onPremConfig: OnPremIntegrationConfig
  tlsConfig: AutomationActionTLSConfig
  url: String!
}

enum YesNoUnknown {
  YES
  NO
  UNKNOWN
}
